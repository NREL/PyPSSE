{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pypsse","title":"PyPSSE","text":"<p>PyPSSE is a Python wrapper around psspy\u2014a Python application programming interface (API) for the Power System Simulator for Engineering (PSS/E)\u2014to perform time series power flow and dynamic simulation for power systems.</p> <p>The PSS/E Python API psspy follows functional programming methodology. The API exposes thousands of methods and can be difficult for new users to work with. PyPSSE wraps around hundreds of function calls in a few methods. This functionality allows users to set up cosimulations with minimal effort.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install using pip:</p> pip install NREL-pypsseInstalled"},{"location":"#usage","title":"Usage","text":"<p>Running an existing PyPSSE project from CLI</p> pypsse run &lt;project path&gt; <p>Building a new PyPSSE project from CLI</p> pypsse create-project &lt;args&gt; <p>Running a PyPSSE server</p> pypsse serve"},{"location":"#features","title":"Features","text":"<ul> <li>Supports time-series steady-state simulations, which are not inherently supported by PSS/E</li> <li>Fully supports dynamic simulations</li> <li>Built in HELICS interface (for both steady-state and dynamic simulations) enables quick cosimulation setup without a without writing a single line of code</li> <li>Built in OpenMDAO interface for co-optimization / co-design type use cases </li> <li>Command line interface allows users to create new projects, run simulations, and view reports</li> <li>Offers RESTful API interface</li> <li>Profile and result management modules allow users to interface with external profiles and mange results</li> <li>Results manger can be configured to work with PSS/E channels and psspy API calls</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the BSD 3-Clause License - see the LICENSE file for details.</p>"},{"location":"#support","title":"Support","text":"<p>If you have questions or need help, please contact [aadil.latif@nrel.gov].</p>"},{"location":"license/","title":"License","text":"<p>Copyright (c) 2018, Alliance for Sustainable Energy LLC, All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ul> <li> <p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p> </li> </ul> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#installing-pypsse","title":"Installing PyPSSE","text":"<p>Create a new python environment using the following command. Make sure you install the correct python version supported by the local PSS/e installation. Also make sure correcly choose a 32 or 64 bit python installer.</p> # Creating a new environmentconda create -n pypsse python==3.9conda activate pypsse # Install the package# For local minimal installation, use the following commandpip install NREL-pypsse# For pypsse server implmentation, usepip install NREL-pypsse[server]# To use pypsse OpenMDAO interface, usepip install NREL-pypsse[mdao]# For development, in a new directory, use the following commandsgit clone https://github.com/NREL/PyPSSEconda install pygraphvizpip install -e.[mdao,server,doc,dev]"},{"location":"tutorials/#cli-commands","title":"CLI commands","text":"# Using the CLI# For CLI commands, type the following commandpypsse --help&gt; Usage: pypsse [OPTIONS] COMMAND [ARGS]...&gt;&gt; PyPSSE commands&gt;&gt; Options:&gt;  --help  Show this message and exit.0&gt;&gt; Commands:&gt;  create-profiles  Creates profiles for PyPSSE project.&gt;  create-project   Create a new PyPSSE project.&gt;  run              Runs a valid PyPSSE simulation.&gt;  serve            Run a PyPSSE RESTful API server."},{"location":"tutorials/#building-a-new-project","title":"Building a new project","text":"# CLI project build optionspypsse create-project --help&gt; Usage: pypsse create-project [OPTIONS] PATH&gt;  &gt;   Create a new PyPSSE project.&gt; &gt; Options:&gt;   -o, --overwrite                 Overwrite project is it already exists&gt;                                   [default: True]&gt;   -a, --autofill                  Attempt to auto fill settings. (Verify&gt;                                   manually settings file is correct)&gt;                                   [default: True]&gt;   -m, --profile-mapping TEXT      Path to a valid Profile_mapping.toml&gt;                                   file (used to map profile to PSSE&gt;                                   elements)&gt;   -s, --profile-store TEXT        Path to a valid Profiles.hdf5 file&gt;                                   (Contains profiles for time series&gt;                                   simulations)&gt;   -e, --export-settings-file TEXT&gt;                                   Export settings toml file path&gt;   -f, --simulation-file TEXT      Simulation settings toml file path&gt;   -F, --psse-project-folder PATH  PSS/E project folder path&gt;   -p, --project TEXT              project name  [required]&gt;   --help                          Show this message and exit."},{"location":"tutorials/#setting-a-new-project-using-cli","title":"setting a new project using cli","text":"# Building a project from scratch. Users will have to manually make all # required changes to the created project skeleton. pypsse create-project . -p test_project # Building a project from an existing PSS/e project. PyPSSE will attemp# to autofill most settings. pypsse create-project . -p test_project -F &lt;project path&gt; <p>Simulation settings can be changed within the simulation_settings.toml file.</p> <ul> <li>Simution type / time / duration</li> <li>Settung upEnabling / disabling the HELICS interface</li> <li>Setting up log preferences</li> <li>Setting up simulation contingencies</li> <li>Setting up simulation storage</li> <li>Setting up simulation profiles</li> </ul> <p></p>"},{"location":"tutorials/#running-a-simulation","title":"Running a simulation","text":"# Project run optionspypsse run --help &gt; Usage: pypsse run [OPTIONS] PROJECT_PATH&gt; &gt;   Runs a valid PyPSSE simulation.&gt; Options:&gt;   -s, --simulations-file TEXT  scenario toml file to run (over rides&gt;                                default)  [default:&gt;                                simulation_settings.toml]&gt;   --help                       Show this message and exit.# Running an existing PyPSSE projectpypsse run &lt;project path&gt;"},{"location":"tutorials/#working-with-a-pypsse-server","title":"Working with a PyPSSE server","text":"<p>PyPSSE implments both a REST API and a Web Socket interface for the PyPSSE server. Usage of both interfaces is similar. The server can be started from the command line using the following command. </p> # Starting a PyPSSE serverpypsse serve&gt; 2023-12-23 11:59:01,913 - INFO - Start PyPSSE server&gt; 2023-12-23 11:59:01,914 - INFO - Initializing service handler&gt; 2023-12-23 11:59:01,924 - INFO - Building web application&gt; 2023-12-23 11:59:01,932 - INFO - Building API endpoints&gt; INFO:     Started server process [15760]&gt; INFO:     Waiting for application startup.&gt; INFO:     Application startup complete.&gt; INFO:     Uvicorn running on http://127.0.0.1:9090 (Press CTRL+C to quit)# Open the link in the browser to view API documentation (Also documented in the reference guide) <p></p>"},{"location":"code/api/","title":"API interface","text":""},{"location":"code/api/#api-interfaces","title":"API interfaces","text":"<p>The PyPSSE REST API interface enables users to run PyPSSE on a server machine. The interface enables orchestration of multiple simualtion runs in parallel. Future extenions will support</p> <ul> <li>User management</li> <li>Result retrival during simulation runs using web socket implementation</li> <li>Ability to upload existing PyPSSE project to the server machine</li> </ul>"},{"location":"code/api/#fastapi-010","title":"FastAPI 0.1.0","text":""},{"location":"code/api/#endpoints","title":"Endpoints","text":""},{"location":"code/api/#put-simulator","title":"PUT /simulator/","text":"<p>Put Psse</p> <p>Request body</p> <p>application/json</p> <p></p><pre><code>{\n    \"uuid\": \"string\",\n    \"command\": \"run_simulation\",\n    \"parameters\": null\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the request body</p> <pre><code>{\n    \"properties\": {\n        \"uuid\": {\n            \"type\": \"string\",\n            \"format\": \"uuid4\",\n            \"title\": \"Uuid\"\n        },\n        \"command\": {\n            \"$ref\": \"#/components/schemas/ApiCommands\"\n        },\n        \"parameters\": {\n            \"anyOf\": [\n                {\n                    \"$ref\": \"#/components/schemas/ApiAssetQuery\"\n                },\n                {\n                    \"type\": \"null\"\n                }\n            ]\n        }\n    },\n    \"type\": \"object\",\n    \"required\": [\n        \"uuid\",\n        \"command\"\n    ],\n    \"title\": \"ApiPssePutRequest\"\n}\n</code></pre>"},{"location":"code/api/#response-200-ok","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#response-422-unprocessable-entity","title":"Response 422 Unprocessable Entity","text":"<p>application/json</p> <p></p><pre><code>{\n    \"detail\": [\n        {\n            \"loc\": [\n                null\n            ],\n            \"msg\": \"string\",\n            \"type\": \"string\"\n        }\n    ]\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the response body</p> <pre><code>{\n    \"properties\": {\n        \"detail\": {\n            \"items\": {\n                \"$ref\": \"#/components/schemas/ValidationError\"\n            },\n            \"type\": \"array\",\n            \"title\": \"Detail\"\n        }\n    },\n    \"type\": \"object\",\n    \"title\": \"HTTPValidationError\"\n}\n</code></pre>"},{"location":"code/api/#post-simulator","title":"POST /simulator/","text":"<p>Post Psse</p> <p>Description Create UUID and intialize and push to queue</p> <p>Request body</p> <p>application/json</p> <p></p><pre><code>{\n    \"project_name\": \"string\"\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the request body</p> <pre><code>{\n    \"properties\": {\n        \"project_name\": {\n            \"type\": \"string\",\n            \"title\": \"Project Name\",\n            \"default\": \"static_example\"\n        }\n    },\n    \"type\": \"object\",\n    \"title\": \"ApiPssePostRequest\"\n}\n</code></pre>"},{"location":"code/api/#response-200-ok_1","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#response-422-unprocessable-entity_1","title":"Response 422 Unprocessable Entity","text":"<p>application/json</p> <p></p><pre><code>{\n    \"detail\": [\n        {\n            \"loc\": [\n                null\n            ],\n            \"msg\": \"string\",\n            \"type\": \"string\"\n        }\n    ]\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the response body</p> <pre><code>{\n    \"properties\": {\n        \"detail\": {\n            \"items\": {\n                \"$ref\": \"#/components/schemas/ValidationError\"\n            },\n            \"type\": \"array\",\n            \"title\": \"Detail\"\n        }\n    },\n    \"type\": \"object\",\n    \"title\": \"HTTPValidationError\"\n}\n</code></pre>"},{"location":"code/api/#delete-simulatoruuiduuid","title":"DELETE /simulator/uuid/{uuid}","text":"<p>Delete Psse</p> <p>Description Delete an instance of simulation</p> <p>Input parameters</p> Parameter In Type Default Nullable Description uuid path string No"},{"location":"code/api/#response-200-ok_2","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#response-422-unprocessable-entity_2","title":"Response 422 Unprocessable Entity","text":"<p>application/json</p> <p></p><pre><code>{\n    \"detail\": [\n        {\n            \"loc\": [\n                null\n            ],\n            \"msg\": \"string\",\n            \"type\": \"string\"\n        }\n    ]\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the response body</p> <pre><code>{\n    \"properties\": {\n        \"detail\": {\n            \"items\": {\n                \"$ref\": \"#/components/schemas/ValidationError\"\n            },\n            \"type\": \"array\",\n            \"title\": \"Detail\"\n        }\n    },\n    \"type\": \"object\",\n    \"title\": \"HTTPValidationError\"\n}\n</code></pre>"},{"location":"code/api/#get-simulatoruuids","title":"GET /simulator/uuids","text":"<p>Get Instance Uuids</p> <p>Description Get all running simulation uuids</p>"},{"location":"code/api/#response-200-ok_3","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#get-simulatorstatusuuiduuid","title":"GET /simulator/status/uuid/{uuid}","text":"<p>Get Instance Status</p> <p>Description Get status of the current provided simuation instance</p> <p>Input parameters</p> Parameter In Type Default Nullable Description uuid path string No"},{"location":"code/api/#response-200-ok_4","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#response-422-unprocessable-entity_3","title":"Response 422 Unprocessable Entity","text":"<p>application/json</p> <p></p><pre><code>{\n    \"detail\": [\n        {\n            \"loc\": [\n                null\n            ],\n            \"msg\": \"string\",\n            \"type\": \"string\"\n        }\n    ]\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the response body</p> <pre><code>{\n    \"properties\": {\n        \"detail\": {\n            \"items\": {\n                \"$ref\": \"#/components/schemas/ValidationError\"\n            },\n            \"type\": \"array\",\n            \"title\": \"Detail\"\n        }\n    },\n    \"type\": \"object\",\n    \"title\": \"HTTPValidationError\"\n}\n</code></pre>"},{"location":"code/api/#get-simulatorresultsuuiduuid","title":"GET /simulator/results/uuid/{uuid}","text":"<p>Get Download Results</p> <p>Description Download results from a simulation instance</p> <p>Input parameters</p> Parameter In Type Default Nullable Description uuid path string No"},{"location":"code/api/#response-200-ok_5","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#response-422-unprocessable-entity_4","title":"Response 422 Unprocessable Entity","text":"<p>application/json</p> <p></p><pre><code>{\n    \"detail\": [\n        {\n            \"loc\": [\n                null\n            ],\n            \"msg\": \"string\",\n            \"type\": \"string\"\n        }\n    ]\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the response body</p> <pre><code>{\n    \"properties\": {\n        \"detail\": {\n            \"items\": {\n                \"$ref\": \"#/components/schemas/ValidationError\"\n            },\n            \"type\": \"array\",\n            \"title\": \"Detail\"\n        }\n    },\n    \"type\": \"object\",\n    \"title\": \"HTTPValidationError\"\n}\n</code></pre>"},{"location":"code/api/#get-simulatorloguuiduuid","title":"GET /simulator/log/uuid/{uuid}","text":"<p>Get Download Logs</p> <p>Description Download logs from a simulation instance</p> <p>Input parameters</p> Parameter In Type Default Nullable Description uuid path string No"},{"location":"code/api/#response-200-ok_6","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#response-422-unprocessable-entity_5","title":"Response 422 Unprocessable Entity","text":"<p>application/json</p> <p></p><pre><code>{\n    \"detail\": [\n        {\n            \"loc\": [\n                null\n            ],\n            \"msg\": \"string\",\n            \"type\": \"string\"\n        }\n    ]\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the response body</p> <pre><code>{\n    \"properties\": {\n        \"detail\": {\n            \"items\": {\n                \"$ref\": \"#/components/schemas/ValidationError\"\n            },\n            \"type\": \"array\",\n            \"title\": \"Detail\"\n        }\n    },\n    \"type\": \"object\",\n    \"title\": \"HTTPValidationError\"\n}\n</code></pre>"},{"location":"code/api/#get","title":"GET /","text":"<p>Get Main Page</p> <p>Description Method to handle service info route.</p>"},{"location":"code/api/#response-200-ok_7","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#post-upload","title":"POST /upload","text":"<p>Post Upload Zipped Project</p> <p>Description Upload a new zipped project to the server</p> <p>Request body</p> <p>multipart/form-data</p> <p></p><pre><code>{\n    \"file\": \"TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQ=\"\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the request body</p> <pre><code>{\n    \"properties\": {\n        \"file\": {\n            \"type\": \"string\",\n            \"format\": \"binary\",\n            \"title\": \"File\"\n        }\n    },\n    \"type\": \"object\",\n    \"required\": [\n        \"file\"\n    ],\n    \"title\": \"Body_post_upload_zipped_project_upload_post\"\n}\n</code></pre>"},{"location":"code/api/#response-200-ok_8","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#response-422-unprocessable-entity_6","title":"Response 422 Unprocessable Entity","text":"<p>application/json</p> <p></p><pre><code>{\n    \"detail\": [\n        {\n            \"loc\": [\n                null\n            ],\n            \"msg\": \"string\",\n            \"type\": \"string\"\n        }\n    ]\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the response body</p> <pre><code>{\n    \"properties\": {\n        \"detail\": {\n            \"items\": {\n                \"$ref\": \"#/components/schemas/ValidationError\"\n            },\n            \"type\": \"array\",\n            \"title\": \"Detail\"\n        }\n    },\n    \"type\": \"object\",\n    \"title\": \"HTTPValidationError\"\n}\n</code></pre>"},{"location":"code/api/#get-projects","title":"GET /projects","text":"<p>Get List Projects</p>"},{"location":"code/api/#response-200-ok_9","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#schemas","title":"Schemas","text":""},{"location":"code/api/#apiassetquery","title":"ApiAssetQuery","text":"Name Type asset_id asset_property asset_type ModelTypes"},{"location":"code/api/#apicommands","title":"ApiCommands","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#apipssepostrequest","title":"ApiPssePostRequest","text":"Name Type project_name string"},{"location":"code/api/#apipsseputrequest","title":"ApiPssePutRequest","text":"Name Type command ApiCommands parameters uuid string(uuid4)"},{"location":"code/api/#areaproperties","title":"AreaProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#body_post_upload_zipped_project_upload_post","title":"Body_post_upload_zipped_project_upload_post","text":"Name Type file string(binary)"},{"location":"code/api/#branchproperties","title":"BranchProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#busproperties","title":"BusProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#dclineproperties","title":"DCLineProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#fixedshuntproperties","title":"FixedShuntProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#httpvalidationerror","title":"HTTPValidationError","text":"Name Type detail Array&lt;ValidationError&gt;"},{"location":"code/api/#inductiongeneratorproperties","title":"InductionGeneratorProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#loadproperties","title":"LoadProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#machinesproperties","title":"MachinesProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#modeltypes","title":"ModelTypes","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#stationproperties","title":"StationProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#switchedshuntproperties","title":"SwitchedShuntProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#transformerproperties","title":"TransformerProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#validationerror","title":"ValidationError","text":"Name Type loc Array&lt;&gt; msg string type string"},{"location":"code/api/#zoneproperties","title":"ZoneProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/cli/","title":"CLI interface","text":""},{"location":"code/cli/#api-interfaces","title":"API interfaces","text":""},{"location":"code/cli/#create-project","title":"create-project","text":"<p>Create a new PyPSSE project.</p> <p>Usage:</p> <pre><code>create-project [OPTIONS] PATH\n</code></pre> <p>Options:</p> <pre><code>  -o, --overwrite                 Overwrite project is it already exists\n                                  [default: True]\n  -a, --autofill                  Attempt to auto fill settings. (Verify\n                                  manually settings file is correct)\n                                  [default: True]\n  -m, --profile-mapping TEXT      Path to a valid Profile_mapping.toml\n                                  file (used to map profile to PSSE\n                                  elements)\n  -s, --profile-store TEXT        Path to a valid Profiles.hdf5 file\n                                  (Contains profiles for time series\n                                  simulations)\n  -e, --export-settings-file TEXT\n                                  Export settings toml file path\n  -f, --simulation-file TEXT      Simulation settings toml file path\n  -F, --psse-project-folder PATH  PSS/E project folder path\n  -p, --project TEXT              project name  [required]\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"code/cli/#run","title":"run","text":"<p>Runs a valid PyPSSE simulation.</p> <p>Usage:</p> <pre><code>run [OPTIONS] PROJECT_PATH\n</code></pre> <p>Options:</p> <pre><code>  -s, --simulations-file TEXT  scenario toml file to run (over rides\n                               default)  [default:\n                               simulation_settings.toml]\n  --help                       Show this message and exit.\n</code></pre>"},{"location":"code/cli/#create-profiles","title":"create-profiles","text":"<p>Creates profiles for PyPSSE project.</p> <p>Usage:</p> <pre><code>create-profiles [OPTIONS] PROJECT_PATH\n</code></pre> <p>Options:</p> <pre><code>  -i, --profile-info TEXT    Profile time resolution in seconds\n  -r, --profile-res FLOAT    Profile time resolution in seconds  [default:\n                             1.0]\n  -T, --start-time TEXT      Time index for the first time step, format =\n                             Y-m-d H:M:S.f  [default: 2020-01-01\n                             00:00:00.00]\n  -t, --profile-type TEXT    Profile type; Possible values: ['Load',\n                             'Induction_machine', 'Machine', 'Plant']\n                             [default: Load]\n  -n, --profile-name TEXT    Profile name  [default: Default]\n  -p, --profile-folder TEXT  Path to folder containing csv profiles. CSV\n                             file names should follow the following\n                             format: {profile-type}_{profile-name}\n  -f, --csv-file-path TEXT   Path to a csv valid file\n  --help                     Show this message and exit.\n</code></pre>"},{"location":"code/cli/#serve","title":"serve","text":"<p>Run a PyPSSE RESTful API server.</p> <p>Usage:</p> <pre><code>serve [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -h, --host-ip TEXT  IP for the server  [default: 127.0.0.1]\n  -p, --port INTEGER  Socket port for the server  [default: 9090]\n  --help              Show this message and exit.\n</code></pre>"},{"location":"code/enumerations/","title":"Enumerations","text":""},{"location":"code/enumerations/#libray-enumerations","title":"Libray Enumerations","text":"<p>This page provides details on the enumerated classes part of the PyPSSE library.Enumerations map directly to .</p>"},{"location":"code/enumerations/#apicommands","title":"ApiCommands","text":"Key Value pypsse.enumerations.ApiCommands.RUN_SIMUALTION run_simulation pypsse.enumerations.ApiCommands.STATUS status pypsse.enumerations.ApiCommands.SOLVE_STEP run_step pypsse.enumerations.ApiCommands.OPEN_CASE open_case pypsse.enumerations.ApiCommands.CLOSE_CASE close_case pypsse.enumerations.ApiCommands.UDPATE_MODEL update_model pypsse.enumerations.ApiCommands.UPDATE_PARAMETERS update_settings pypsse.enumerations.ApiCommands.QUERY_ALL query_all pypsse.enumerations.ApiCommands.QUERY_BY_ID query_by_asset pypsse.enumerations.ApiCommands.QUERY_BY_PPTY query_by_ppty pypsse.enumerations.ApiCommands.QUERY_ASSET_LIST query_asset_list"},{"location":"code/enumerations/#areaproperties","title":"AreaProperties","text":"Key Value pypsse.enumerations.AreaProperties.LOAD LOAD pypsse.enumerations.AreaProperties.LOADID LOADID pypsse.enumerations.AreaProperties.LGDN LGDN pypsse.enumerations.AreaProperties.LDGNLD LDGNLD pypsse.enumerations.AreaProperties.GEN GEN pypsse.enumerations.AreaProperties.AREANAME AREANAME pypsse.enumerations.AreaProperties.AREANUMBER AREANUMBER"},{"location":"code/enumerations/#branchproperties","title":"BranchProperties","text":"Key Value pypsse.enumerations.BranchProperties.RATEn RATEn pypsse.enumerations.BranchProperties.RATEA RATEA pypsse.enumerations.BranchProperties.RATEB RATEB pypsse.enumerations.BranchProperties.RATEC RATEC pypsse.enumerations.BranchProperties.RATE RATE pypsse.enumerations.BranchProperties.LENGTH LENGTH pypsse.enumerations.BranchProperties.CHARG CHARG pypsse.enumerations.BranchProperties.CHARGZ CHARGZ pypsse.enumerations.BranchProperties.FRACT1 FRACT1 pypsse.enumerations.BranchProperties.FRACT2 FRACT2 pypsse.enumerations.BranchProperties.FRACT3 FRACT3 pypsse.enumerations.BranchProperties.FRACT4 FRACT4 pypsse.enumerations.BranchProperties.RX RX pypsse.enumerations.BranchProperties.ISHNT ISHNT pypsse.enumerations.BranchProperties.JSHNT JSHNT pypsse.enumerations.BranchProperties.RXZ RXZ pypsse.enumerations.BranchProperties.ISHNTZ ISHNTZ pypsse.enumerations.BranchProperties.JSHNTZ JSHNTZ pypsse.enumerations.BranchProperties.LOSSES LOSSES pypsse.enumerations.BranchProperties.O_LOSSES O_LOSSES pypsse.enumerations.BranchProperties.MVA MVA pypsse.enumerations.BranchProperties.AMPS AMPS pypsse.enumerations.BranchProperties.PUCUR PUCUR pypsse.enumerations.BranchProperties.CURANG CURANG pypsse.enumerations.BranchProperties.P P pypsse.enumerations.BranchProperties.O_P O_P pypsse.enumerations.BranchProperties.Q Q pypsse.enumerations.BranchProperties.O_Q O_Q pypsse.enumerations.BranchProperties.PLOS PLOS pypsse.enumerations.BranchProperties.O_PLOS O_PLOS pypsse.enumerations.BranchProperties.QLOS QLOS pypsse.enumerations.BranchProperties.O_QLOS O_QLOS"},{"location":"code/enumerations/#bulkwritemodes","title":"BulkWriteModes","text":"Key Value pypsse.enumerations.BulkWriteModes.CSV csv pypsse.enumerations.BulkWriteModes.PKL pkl"},{"location":"code/enumerations/#busproperties","title":"BusProperties","text":"Key Value pypsse.enumerations.BusProperties.BASE BASE pypsse.enumerations.BusProperties.FREQ FREQ pypsse.enumerations.BusProperties.PU PU pypsse.enumerations.BusProperties.KV KV pypsse.enumerations.BusProperties.ANGLE ANGLE pypsse.enumerations.BusProperties.ANGLED ANGLED pypsse.enumerations.BusProperties.NVLMHI NVLMHI pypsse.enumerations.BusProperties.NVLMLO NVLMLO pypsse.enumerations.BusProperties.EVLMHI EVLMHI pypsse.enumerations.BusProperties.EVLMLO EVLMLO"},{"location":"code/enumerations/#channeltypes","title":"ChannelTypes","text":"Key Value pypsse.enumerations.ChannelTypes.BUSES buses pypsse.enumerations.ChannelTypes.LOADS loads pypsse.enumerations.ChannelTypes.MACHINES machines"},{"location":"code/enumerations/#dclineproperties","title":"DCLineProperties","text":"Key Value pypsse.enumerations.DCLineProperties.DCLINENAME DCLINENAME pypsse.enumerations.DCLineProperties.MDC MDC pypsse.enumerations.DCLineProperties.RECT RECT pypsse.enumerations.DCLineProperties.INV INV pypsse.enumerations.DCLineProperties.METER METER pypsse.enumerations.DCLineProperties.NBR NBR pypsse.enumerations.DCLineProperties.NBI NBI pypsse.enumerations.DCLineProperties.ICR ICR pypsse.enumerations.DCLineProperties.ICI ICI pypsse.enumerations.DCLineProperties.NDR NDR pypsse.enumerations.DCLineProperties.NDI NDI"},{"location":"code/enumerations/#enum","title":"Enum","text":"Key Value"},{"location":"code/enumerations/#exportmodes","title":"ExportModes","text":"Key Value pypsse.enumerations.ExportModes.CSV csv pypsse.enumerations.ExportModes.H5 h5"},{"location":"code/enumerations/#fixedshuntproperties","title":"FixedShuntProperties","text":"Key Value pypsse.enumerations.FixedShuntProperties.ACT ACT pypsse.enumerations.FixedShuntProperties.O_ACT O_ACT pypsse.enumerations.FixedShuntProperties.NOM NOM pypsse.enumerations.FixedShuntProperties.O_NOM O_NOM pypsse.enumerations.FixedShuntProperties.PQZERO PQZERO pypsse.enumerations.FixedShuntProperties.PQZ PQZ pypsse.enumerations.FixedShuntProperties.O_PQZ O_PQZ"},{"location":"code/enumerations/#helicscoretypes","title":"HelicsCoreTypes","text":"Key Value pypsse.enumerations.HelicsCoreTypes.ZMQ zmq"},{"location":"code/enumerations/#inductiongeneratorproperties","title":"InductionGeneratorProperties","text":"Key Value pypsse.enumerations.InductionGeneratorProperties.MBASE MBASE pypsse.enumerations.InductionGeneratorProperties.RATEKV RATEKV pypsse.enumerations.InductionGeneratorProperties.PSET PSET pypsse.enumerations.InductionGeneratorProperties.RA RA pypsse.enumerations.InductionGeneratorProperties.XA XA pypsse.enumerations.InductionGeneratorProperties.R1 R1 pypsse.enumerations.InductionGeneratorProperties.X1 X1 pypsse.enumerations.InductionGeneratorProperties.R2 R2 pypsse.enumerations.InductionGeneratorProperties.X2 X2 pypsse.enumerations.InductionGeneratorProperties.X3 X3 pypsse.enumerations.InductionGeneratorProperties.E1 E1 pypsse.enumerations.InductionGeneratorProperties.SE1 SE1 pypsse.enumerations.InductionGeneratorProperties.E2 E2 pypsse.enumerations.InductionGeneratorProperties.SE2 SE2 pypsse.enumerations.InductionGeneratorProperties.IA1 IA1 pypsse.enumerations.InductionGeneratorProperties.IA2 IA2 pypsse.enumerations.InductionGeneratorProperties.XAMULT XAMULT pypsse.enumerations.InductionGeneratorProperties.TRQA TRQA pypsse.enumerations.InductionGeneratorProperties.TRQB TRQB pypsse.enumerations.InductionGeneratorProperties.TRQD TRQD pypsse.enumerations.InductionGeneratorProperties.TRQE TRQE pypsse.enumerations.InductionGeneratorProperties.H H pypsse.enumerations.InductionGeneratorProperties.IRATIO IRATIO pypsse.enumerations.InductionGeneratorProperties.ROVERX ROVERX pypsse.enumerations.InductionGeneratorProperties.RZERO RZERO pypsse.enumerations.InductionGeneratorProperties.XZERO XZERO pypsse.enumerations.InductionGeneratorProperties.RGRND RGRND pypsse.enumerations.InductionGeneratorProperties.XGRND XGRND pypsse.enumerations.InductionGeneratorProperties.P P pypsse.enumerations.InductionGeneratorProperties.O_P O_P pypsse.enumerations.InductionGeneratorProperties.Q Q pypsse.enumerations.InductionGeneratorProperties.O_Q O_Q pypsse.enumerations.InductionGeneratorProperties.MVA MVA pypsse.enumerations.InductionGeneratorProperties.O_MVA O_MVA pypsse.enumerations.InductionGeneratorProperties.SLIP SLIP pypsse.enumerations.InductionGeneratorProperties.ZA ZA pypsse.enumerations.InductionGeneratorProperties.Z1 Z1 pypsse.enumerations.InductionGeneratorProperties.Z2 Z2 pypsse.enumerations.InductionGeneratorProperties.ZZERO ZZERO pypsse.enumerations.InductionGeneratorProperties.ZGRND ZGRND pypsse.enumerations.InductionGeneratorProperties.PQ PQ pypsse.enumerations.InductionGeneratorProperties.O_PQ O_PQ"},{"location":"code/enumerations/#intenum","title":"IntEnum","text":"Key Value"},{"location":"code/enumerations/#loadproperties","title":"LoadProperties","text":"Key Value pypsse.enumerations.LoadProperties.MVA MVA pypsse.enumerations.LoadProperties.IL IL pypsse.enumerations.LoadProperties.YL YL pypsse.enumerations.LoadProperties.TOTAL TOTAL pypsse.enumerations.LoadProperties.YNEG YNEG pypsse.enumerations.LoadProperties.YZERO YZERO pypsse.enumerations.LoadProperties.FmA FmA pypsse.enumerations.LoadProperties.FmB FmB pypsse.enumerations.LoadProperties.FmC FmC pypsse.enumerations.LoadProperties.FmD FmD pypsse.enumerations.LoadProperties.Fel Fel pypsse.enumerations.LoadProperties.PFel PFel pypsse.enumerations.LoadProperties.TD TD pypsse.enumerations.LoadProperties.TC TC"},{"location":"code/enumerations/#logginglevels","title":"LoggingLevels","text":"Key Value pypsse.enumerations.LoggingLevels.NOTSET 0 pypsse.enumerations.LoggingLevels.DEBUG 10 pypsse.enumerations.LoggingLevels.INFO 20 pypsse.enumerations.LoggingLevels.WARN 30 pypsse.enumerations.LoggingLevels.ERROR 40 pypsse.enumerations.LoggingLevels.CRITICAL 50"},{"location":"code/enumerations/#machinesproperties","title":"MachinesProperties","text":"Key Value pypsse.enumerations.MachinesProperties.QMAX QMAX pypsse.enumerations.MachinesProperties.O_QMAX O_QMAX pypsse.enumerations.MachinesProperties.QMIN QMIN pypsse.enumerations.MachinesProperties.O_QMIN O_QMIN pypsse.enumerations.MachinesProperties.PMAX PMAX pypsse.enumerations.MachinesProperties.O_PMAX O_PMAX pypsse.enumerations.MachinesProperties.PMIN PMIN pypsse.enumerations.MachinesProperties.O_PMIN O_PMIN pypsse.enumerations.MachinesProperties.MBASE MBASE pypsse.enumerations.MachinesProperties.MVA MVA pypsse.enumerations.MachinesProperties.O_MVA O_MVA pypsse.enumerations.MachinesProperties.P P pypsse.enumerations.MachinesProperties.O_P O_P pypsse.enumerations.MachinesProperties.Q Q pypsse.enumerations.MachinesProperties.O_Q O_Q pypsse.enumerations.MachinesProperties.PERCENT PERCENT pypsse.enumerations.MachinesProperties.GENTAP GENTAP pypsse.enumerations.MachinesProperties.VSCHED VSCHED pypsse.enumerations.MachinesProperties.WPF WPF pypsse.enumerations.MachinesProperties.RMPCT RMPCT pypsse.enumerations.MachinesProperties.RPOS RPOS pypsse.enumerations.MachinesProperties.XSUBTR XSUBTR pypsse.enumerations.MachinesProperties.XTRANS XTRANS pypsse.enumerations.MachinesProperties.XSYNCH XSYNCH pypsse.enumerations.MachinesProperties.PQ PQ pypsse.enumerations.MachinesProperties.O_PQ O_PQ pypsse.enumerations.MachinesProperties.ZSORCE ZSORCE pypsse.enumerations.MachinesProperties.XTRAN XTRAN pypsse.enumerations.MachinesProperties.ZPOS ZPOS pypsse.enumerations.MachinesProperties.ZNEG ZNEG pypsse.enumerations.MachinesProperties.ZZERO ZZERO pypsse.enumerations.MachinesProperties.ZGRND ZGRND"},{"location":"code/enumerations/#modelproperties","title":"ModelProperties","text":"Key Value pypsse.enumerations.ModelProperties.PU PU pypsse.enumerations.ModelProperties.FREQ FREQ pypsse.enumerations.ModelProperties.ANGLE ANGLE pypsse.enumerations.ModelProperties.ANGLED ANGLED"},{"location":"code/enumerations/#modeltypes","title":"ModelTypes","text":"Key Value pypsse.enumerations.ModelTypes.BUSES Buses pypsse.enumerations.ModelTypes.BRANCHES Branches pypsse.enumerations.ModelTypes.LOADS Loads pypsse.enumerations.ModelTypes.GENERATORS Induction_generators pypsse.enumerations.ModelTypes.MACHINES Machines pypsse.enumerations.ModelTypes.FIXED_SHUNTS Fixed_shunts pypsse.enumerations.ModelTypes.SWITCHED_SHUNTS Switched_shunts pypsse.enumerations.ModelTypes.TRANSFORMERS Transformers pypsse.enumerations.ModelTypes.AREAS Areas pypsse.enumerations.ModelTypes.ZONES Zones pypsse.enumerations.ModelTypes.DC_LINES DCtransmissionlines pypsse.enumerations.ModelTypes.STATIONS Stations"},{"location":"code/enumerations/#projectfolders","title":"ProjectFolders","text":"Key Value pypsse.enumerations.ProjectFolders.CASESTUDY case_study pypsse.enumerations.ProjectFolders.EXPORTS exports pypsse.enumerations.ProjectFolders.GISDATA gis_data pypsse.enumerations.ProjectFolders.LOGS logs pypsse.enumerations.ProjectFolders.PROFILES profiles"},{"location":"code/enumerations/#simulationmodes","title":"SimulationModes","text":"Key Value pypsse.enumerations.SimulationModes.PCM PCM pypsse.enumerations.SimulationModes.SNAP Snap pypsse.enumerations.SimulationModes.STATIC Steady-state pypsse.enumerations.SimulationModes.DYNAMIC Dynamic"},{"location":"code/enumerations/#simulationstatus","title":"SimulationStatus","text":"Key Value pypsse.enumerations.SimulationStatus.NOT_INITIALIZED Instance not initialized pypsse.enumerations.SimulationStatus.STARTING_INSTANCE Starting PyPSSE instance pypsse.enumerations.SimulationStatus.INITIALIZATION_COMPLETE PyPSSE initialization complete pypsse.enumerations.SimulationStatus.RUNNING_SIMULATION Running simulation pypsse.enumerations.SimulationStatus.SIMULATION_COMPLETE Simulation complete pypsse.enumerations.SimulationStatus.STARTING_RESULT_EXPORT Starting exports pypsse.enumerations.SimulationStatus.RESULT_EXPORT_COMPLETE Export coplete"},{"location":"code/enumerations/#stationproperties","title":"StationProperties","text":"Key Value pypsse.enumerations.StationProperties.SUBNAME SUBNAME pypsse.enumerations.StationProperties.SUBNUMBER SUBNUMBER pypsse.enumerations.StationProperties.BUSES BUSES pypsse.enumerations.StationProperties.GENERATORS GENERATORS pypsse.enumerations.StationProperties.TRANSFORMERS TRANSFORMERS pypsse.enumerations.StationProperties.NOMKV NOMKV pypsse.enumerations.StationProperties.LOADMW LOADMW pypsse.enumerations.StationProperties.GENMW GENMW"},{"location":"code/enumerations/#streamedwritemodes","title":"StreamedWriteModes","text":"Key Value pypsse.enumerations.StreamedWriteModes.H5 h5"},{"location":"code/enumerations/#subscriptionfilerequiredcolumns","title":"SubscriptionFileRequiredColumns","text":"Key Value pypsse.enumerations.SubscriptionFileRequiredColumns.bus_subsystem_id bus_subsystem_id pypsse.enumerations.SubscriptionFileRequiredColumns.element_type element_type pypsse.enumerations.SubscriptionFileRequiredColumns.element_id element_id pypsse.enumerations.SubscriptionFileRequiredColumns.element_property element_property pypsse.enumerations.SubscriptionFileRequiredColumns.sub_tag sub_tag pypsse.enumerations.SubscriptionFileRequiredColumns.scaler scaler pypsse.enumerations.SubscriptionFileRequiredColumns.bus bus"},{"location":"code/enumerations/#switchedshuntproperties","title":"SwitchedShuntProperties","text":"Key Value pypsse.enumerations.SwitchedShuntProperties.VSWHI VSWHI pypsse.enumerations.SwitchedShuntProperties.VSWLO VSWLO pypsse.enumerations.SwitchedShuntProperties.RMPCT RMPCT pypsse.enumerations.SwitchedShuntProperties.BINIT BINIT pypsse.enumerations.SwitchedShuntProperties.O_BINIT O_BINIT"},{"location":"code/enumerations/#transformerproperties","title":"TransformerProperties","text":"Key Value pypsse.enumerations.TransformerProperties.RATIO RATIO pypsse.enumerations.TransformerProperties.RATIO2 RATIO2 pypsse.enumerations.TransformerProperties.ANGLE ANGLE pypsse.enumerations.TransformerProperties.RMAX RMAX pypsse.enumerations.TransformerProperties.RMIN RMIN pypsse.enumerations.TransformerProperties.VMAX VMAX pypsse.enumerations.TransformerProperties.VMIN VMIN pypsse.enumerations.TransformerProperties.STEP STEP pypsse.enumerations.TransformerProperties.CR CR pypsse.enumerations.TransformerProperties.CX CX pypsse.enumerations.TransformerProperties.CNXANG CNXANG pypsse.enumerations.TransformerProperties.SBASE1 SBASE1 pypsse.enumerations.TransformerProperties.NOMV1 NOMV1 pypsse.enumerations.TransformerProperties.NOMV2 NOMV2 pypsse.enumerations.TransformerProperties.GMAGNT GMAGNT pypsse.enumerations.TransformerProperties.BMAGNT BMAGNT pypsse.enumerations.TransformerProperties.RG1 RG1 pypsse.enumerations.TransformerProperties.XG1 XG1 pypsse.enumerations.TransformerProperties.R01 R01 pypsse.enumerations.TransformerProperties.X01 X01 pypsse.enumerations.TransformerProperties.RG2 RG2 pypsse.enumerations.TransformerProperties.XG2 XG2 pypsse.enumerations.TransformerProperties.R02 R02 pypsse.enumerations.TransformerProperties.X02 X02 pypsse.enumerations.TransformerProperties.RNUTRL RNUTRL pypsse.enumerations.TransformerProperties.XNUTRL XNUTRL pypsse.enumerations.TransformerProperties.RX1_2 RX1-2 pypsse.enumerations.TransformerProperties.RX2_3 RX2-3 pypsse.enumerations.TransformerProperties.RX3_1 RX3-1 pypsse.enumerations.TransformerProperties.YMAGNT YMAGNT pypsse.enumerations.TransformerProperties.ZG1 ZG1 pypsse.enumerations.TransformerProperties.Z01 Z01 pypsse.enumerations.TransformerProperties.ZG2 ZG2 pypsse.enumerations.TransformerProperties.Z02 Z02 pypsse.enumerations.TransformerProperties.ZG3 ZG3 pypsse.enumerations.TransformerProperties.Z03 Z03 pypsse.enumerations.TransformerProperties.ZNUTRL ZNUTRL"},{"location":"code/enumerations/#usemodes","title":"UseModes","text":"Key Value pypsse.enumerations.UseModes.REGEX regex pypsse.enumerations.UseModes.LIST list pypsse.enumerations.UseModes.ALL all"},{"location":"code/enumerations/#writablemodeltypes","title":"WritableModelTypes","text":"Key Value pypsse.enumerations.WritableModelTypes.LOAD Load pypsse.enumerations.WritableModelTypes.PLANT Plant pypsse.enumerations.WritableModelTypes.MACHINE Machine pypsse.enumerations.WritableModelTypes.GENERATOR Induction_machine"},{"location":"code/enumerations/#zoneproperties","title":"ZoneProperties","text":"Key Value pypsse.enumerations.ZoneProperties.LOAD LOAD pypsse.enumerations.ZoneProperties.LOADID LOADID pypsse.enumerations.ZoneProperties.LGDN LGDN pypsse.enumerations.ZoneProperties.LDGNLD LDGNLD pypsse.enumerations.ZoneProperties.GEN GEN pypsse.enumerations.ZoneProperties.ZONENAME ZONENAME pypsse.enumerations.ZoneProperties.ZONENUMBER ZONENUMBER"},{"location":"code/helics_interface/","title":"HELICS","text":""},{"location":"code/helics_interface/#reference-manual","title":"Reference manual","text":"<p>PyPSSE enables out of the box integration for co-simulation and co-optimization / co-design frameworks.</p>"},{"location":"code/helics_interface/#the-helics-co-simulation-framework","title":"The HELICS co-simulation framework","text":"<p>HELICS is a scalable open-source co-simulation framework is designed to integrate simulators designed for separate TDC domains to simulate regional and interconnection-scale power system behaviors at unprecedented levels of detail and speed. </p>"},{"location":"code/helics_interface/#setting-up-the-helics-co-simulation-interface","title":"Setting up the HELICS co-simulation interface","text":"<p>To enabled the HELICS interface, set <code>cosimulation_mode = true</code> in the <code>`simulation_settings.toml</code> file.</p> <p>The helics interface requires an existing HELCIS broker running either locally or remotely that the federate can connect to. Broker settings ca also be defined in the same file.</p> <p>Valid HELICS interface settings are:</p> <p> </p>"},{"location":"code/helics_interface/#setting-up-subscriptions","title":"Setting up subscriptions","text":"<p>Federate subscriptions can be set up by creating a <code>Subscription.csv</code>. The table below presents an example implementation.  </p> bus_subsystem_id bus element_type element_id element_property sub_tag scaler 0 153 Load 1 ['PL'] test.load1.P [1.0] 0 153 Load 1 ['QL'] test.load1.Q [1.0] 0 154 Load 2 ['PL'] test.load2.P [1.0] 0 154 Load 2 ['QL'] test.load2.Q [1.0]"},{"location":"code/helics_interface/#setting-up-publications","title":"Setting up publications","text":"<p>Valid publiations can be defined in PyPSSE in two ways.</p>"},{"location":"code/helics_interface/#pulishing-results-from-the-result-container","title":"Pulishing results from the result container","text":"<p>PyPSSE allows publication of results stored in the simulation store. Publications are set up directly in  <code>simulation_settings.toml</code> file in the PyPSSE project structure.</p> <pre><code>[[helics.publications]]\nbus_subsystems = [ 0,]\nasset_type = \"Buses\"\nasset_properties = [ \"FREQ\", \"PU\",]\n</code></pre> <p>All fields are validated against availble datasets in the simulation store. Valid model types and properties are documented here</p> <p></p>"},{"location":"code/helics_interface/#publishing-results-collected-from-channels","title":"Publishing results collected from channels","text":"<p>Results from channels in PSSE can also be published via the HELICS (dynamic simulation only). The setup mechanism is different.</p> <p>Channels can be set up in the <code>export_settings.toml</code> file in a PyPSSE project structure.</p> <p>The following data models can be refered to ensure valid implementation. Results from all channels are published to the simulation store and the HLEICS interface. </p> <p> </p> <p>Both interfaces can be used simultaneously as well</p>"},{"location":"code/helics_interface/#running-the-provided-helics-example","title":"Running the provided HELICS example","text":""},{"location":"code/mdao/","title":"OpenMDAO","text":""},{"location":"code/mdao/#reference-manual","title":"Reference manual","text":"<p>PyPSSE enables out of the box integration for co-simulation and co-optimization / co-design frameworks.</p>"},{"location":"code/mdao/#co-optimization-co-design-with-openmdao","title":"Co-optimization / co-design with OpenMDAO","text":"<p>The OpenMDAO framework enables multi-domain co-optimization by structuring the problem as a group of sub problems. (Ssee OpenMDAO documentation). The OpenMDAO interface implemented in PyPSSE enables it to a subproblem in a larger co-optimization or co-design problem. </p>"},{"location":"code/mdao/#runnning-the-provided-mdao-example","title":"Runnning the provided MDAO example","text":""},{"location":"code/models/","title":"Data models","text":""},{"location":"code/models/#library-data-models","title":"Library data models","text":"<p>This page provides details on the data models part of the PyPSSE library.</p> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class ApiAssetQuery(BaseModel):\n    asset_type: ModelTypes\n    asset_property: Optional[\n        Union[\n            BusProperties,\n            AreaProperties,\n            ZoneProperties,\n            StationProperties,\n            DCLineProperties,\n            LoadProperties,\n            FixedShuntProperties,\n            SwitchedShuntProperties,\n            TransformerProperties,\n            BranchProperties,\n            InductionGeneratorProperties,\n            MachinesProperties,\n        ]\n    ] = None\n    asset_id: Optional[str] = None\n\n    @model_validator(mode=\"after\")\n    def define_atleast_one(self):\n        assert not (\n            self.asset_id is None and self.asset_property is None\n        ), \"Atleast one 'asset_id' or 'asset_property' should be defined\"\n        return self\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class ApiPsseException(BaseModel):\n    message: str\n    uuid: Union[UUID4, None] = None\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class ApiPssePostRequest(BaseModel):\n    project_name: str = \"static_example\"\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class ApiPssePutRequest(BaseModel):\n    uuid: UUID4\n    command: ApiCommands\n    parameters: Optional[ApiAssetQuery] = None\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class ApiPsseReply(BaseModel):\n    status: str\n    message: str\n    uuid: Union[UUID4, None] = None\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class ApiPsseReplyInstances(BaseModel):\n    status: str\n    message: str\n    simulators: List[UUID4] = []\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class ApiWebSocketRequest(BaseModel):\n    command: ApiCommands\n    parameters: Optional[Dict] = None\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Bus channel model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class BusChannel(BaseModel):\n    \"Bus channel model defination\"\n\n    asset_type: Literal[ChannelTypes.BUSES.value]\n    use: UseModes = UseModes.LIST\n    regex: str = \"\"\n    asset_list: List[int] = []\n    asset_properties: List[str] = [\"voltage_and_angle\", \"frequency\"]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Bus fault model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class BusFault(BaseModel):\n    \"Bus fault model defination\"\n    time: float = 0.2\n    bus_id: int = 38205\n    duration: float = 0.3\n    bus_trip: bool = False\n    trip_delay: float = 0.05\n    fault_impedance: List[int] = [\n        1.0,\n        1.0,\n    ]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Bus subsystem model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class BusSubsystems(BaseModel):\n    \"Bus subsystem model defination\"\n    from_file: bool = False\n    bus_file: Optional[str] = None\n    bus_subsystem_list: List[List[int]] = [\n        [\n            74012,\n            17735,\n            20115,\n            38205,\n            70008,\n            80511,\n        ],\n    ]\n    publish_subsystems: List[int] = [\n        0,\n    ]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Bus trip model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class BusTrip(BaseModel):\n    \"Bus trip model defination\"\n    time: float = 0.2\n    bus_id: int = 38205\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Valid export models and associated options</p> Source code in <code>pypsse\\models.py</code> <pre><code>class ExportAssetTypes(BaseModel):\n    \"Valid export models and associated options\"\n\n    buses: Optional[List[BusProperties]] = None\n    areas: Optional[List[AreaProperties]] = None\n    zones: Optional[List[ZoneProperties]] = None\n    stations: Optional[List[StationProperties]] = None\n    dctransmissionlines: Optional[List[DCLineProperties]] = None\n    loads: Optional[List[LoadProperties]] = None\n    fixed_shunts: Optional[List[FixedShuntProperties]] = None\n    switched_shunts: Optional[List[SwitchedShuntProperties]] = None\n    transformers: Optional[List[TransformerProperties]] = None\n    branches: Optional[List[BranchProperties]] = None\n    induction_generators: Optional[List[InductionGeneratorProperties]] = None\n    machines: Optional[List[MachinesProperties]] = None\n</code></pre> <p> </p> <p>             Bases: <code>ExportAssetTypes</code></p> <p>Export settings for a PyPSSE project</p> Source code in <code>pypsse\\models.py</code> <pre><code>class ExportFileOptions(ExportAssetTypes):\n    \"Export settings for a PyPSSE project\"\n\n    export_results_using_channels: bool = False\n    defined_subsystems_only: bool = True\n    file_format: ExportModes = \"h5\"\n    channels: Optional[List[str]] = None\n    channel_setup: Optional[List[channel_types]] = None\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Export setting model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class ExportSettings(BaseModel):\n    \"Export setting model defination\"\n\n    outx_file: Path = \"test.outx\"\n    out_file: Path = \"20LS11p.out\"\n    excel_file: Path = \"20LS11p.xls\"\n    log_file: Path = \"20LS11p.log\"\n    coordinate_file: Path = \"\"\n    networkx_graph_file: Path = \"20LS11p.gpickle\"\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>GIC export setting model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class GICExportSettings(BaseModel):\n    \"GIC export setting model defination\"\n    include_substation_connections: bool = False\n    include_transfomer_connections: bool = False\n    include_branch_connections: bool = True\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Generator model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class GeneratorSettings(BaseModel):\n    \"Generator model defination\"\n    missing_machine_model: int = 1\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>HELICS co-simualtion setting model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class HelicsSettings(BaseModel):\n    \"HELICS co-simualtion setting model defination\"\n    cosimulation_mode: bool = False\n    federate_name: str = \"psse\"\n    time_delta: timedelta = timedelta(seconds=0.00333333333)\n    core_type: HelicsCoreTypes = \"zmq\"\n    uninterruptible: bool = True\n    helics_logging_level: int = Field(5, ge=1, le=10)\n    create_subscriptions: bool = True\n    iterative_mode: bool = False\n    error_tolerance: float = Field(1e-5, g=0)\n    max_coiterations: int = Field(15, ge=1)\n    broker_ip: IPvAnyAddress = \"127.0.0.1\"\n    broker_port: int = 23404\n    disable_generation_on_coupled_buses: bool = True\n    publications: List[PublicationDefination]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Line fault model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LineFault(BaseModel):\n    \"Line fault model defination\"\n    time: float = 0.2\n    bus_ids: List[int]\n    duration: float = 0.3\n    bus_trip: bool = False\n    trip_delay: float = 0.05\n    fault_impedance: List[int] = [\n        1.0,\n        1.0,\n    ]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Line trip model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LineTrip(BaseModel):\n    \"Line trip model defination\"\n    time: float = 0.2\n    bus_ids: List[int]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Load ZIP model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LoadBreakdown(BaseModel):\n    \"Load ZIP model defination\"\n    constant_current_percentage: float = 0.0\n    constant_admittance_percentage: float = 0.0\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Load channel model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LoadChannel(BaseModel):\n    \"Load channel model defination\"\n\n    asset_type: Literal[ChannelTypes.LOADS.value]\n    use: UseModes = UseModes.LIST\n    regex: str = \"\"\n    asset_list: List[List[str]] = [[]]\n    asset_properties: List[str] = []\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Load model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LoadSettings(BaseModel):\n    \"Load model defination\"\n    convert: bool = True\n    active_load: LoadBreakdown\n    reactive_load: LoadBreakdown\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Logger setting model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LogSettings(BaseModel):\n    \"Logger setting model defination\"\n    disable_psse_logging: bool = True\n    logging_level: LoggingLevels\n    log_to_external_file: bool = True\n    display_on_screen: bool = True\n    clear_old_log_file: bool = True\n    pre_configured_logging: bool = False\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Machine channel model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class MachineChannel(BaseModel):\n    \"Machine channel model defination\"\n\n    asset_type: Literal[ChannelTypes.MACHINES.value]\n    use: UseModes = UseModes.LIST\n    regex: str = \"\"\n    asset_list: List[List[str]] = [[]]\n    asset_properties: List[str] = [\"PELEC\", \"QELEC\", \"SPEED\"]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Machine trip model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class MachineTrip(BaseModel):\n    \"Machine trip model defination\"\n    time: float = 0.2\n    bus_id: int = 38205\n    machine_id: str = \"\"\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class MdaoInput(BaseModel):\n    asset_type: WritableModelTypes\n    asset_bus: int\n    asset_id: str\n    attributes: Dict\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class MdaoOutput(BaseModel):\n    buses: List[int]\n    quantities: Dict[ModelTypes, List[str]]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class MdaoProblem(BaseModel):\n    outputs: MdaoOutput\n    inputs: List[MdaoInput]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Plotting setting model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class PlotSettings(BaseModel):\n    \"Plotting setting model defination\"\n    enable_dynamic_plots: bool = False\n    columns: int = Field(15, ge=1)\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>PyPSSE project defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class ProjectDefination(BaseModel):\n    \"PyPSSE project defination\"\n    overwrite: bool = False\n    autofill: bool = True\n    project_name: str\n    project_folders: List[ProjectFolders] = list(ProjectFolders)\n    simulation_settings: SimulationSettings\n    export_settings: ExportFileOptions\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Publication setting model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class PublicationDefination(BaseModel):\n    \"\"\"Publication setting model defination\"\"\"\n\n    bus_subsystems: List[int] = [\n        0,\n    ]\n    asset_type: ModelTypes = \"buses\"\n    asset_properties: List[ModelProperties] = [\"FREQ\", \"PU\"]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Simulation setting  model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class SimSettings(BaseModel):\n    \"Simulation setting  model defination\"\n    simulation_time: timedelta = timedelta(seconds=3.0)\n    simulation_step_resolution: timedelta = timedelta(seconds=0.025)\n    psse_solver_timestep: timedelta = timedelta(seconds=0.00333333333)\n    start_time: datetime = \"01/01/2020 00:00:00\"\n    use_profile_manager: bool\n    psse_path: Path = \"C:/Program Files/PTI/PSSE35/35.4/PSSPY39232\"\n    project_path: Path = \"C:/Users/alatif/Desktop/NAERM/models/pyPSSEModel\"\n    case_study: Optional[Path] = None\n    raw_file: Optional[Path] = None\n    snp_file: Optional[Path] = None\n    dyr_file: Optional[Path] = None\n    rwm_file: Optional[Path] = None\n    gic_file: Optional[Path] = None\n    subscriptions_file: Optional[Path] = None\n    user_models: List[str] = []\n    setup_files: List[str] = []\n    simulation_mode: SimulationModes\n\n    @model_validator(mode=\"after\")\n    def sim_res_smaller_than_sim_time(self):\n        assert (\n            self.simulation_step_resolution &lt;= self.simulation_time\n        ), \"simulation_step_resolution should be smaller than simulation_time\"\n        return self\n\n    @model_validator(mode=\"after\")\n    def psse_res_smaller_than_sim_time(self):\n        assert (\n            self.psse_solver_timestep &lt;= self.simulation_time\n        ), \"psse_solver_timestep should be smaller than simulation_time\"\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_case_study(self):\n        file_types = [\"case_study\", \"raw_file\", \"snp_file\", \"dyr_file\", \"rwm_file\", \"gic_file\"]\n        base_project_path = self.project_path\n        for file in file_types:\n            file_path = getattr(self, file)\n            if file_path and str(file_path) != \".\":\n                file_path = base_project_path / CASESTUDY_FOLDER / file_path\n                setattr(self, file, file_path)\n                assert file_path.exists(), f\"{file_path} does not exist\"\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_subscription_file(self):\n        base_project_path = self.project_path\n        if self.subscriptions_file and str(self.subscriptions_file) != \".\":\n            self.subscriptions_file = base_project_path / self.subscriptions_file\n            assert self.subscriptions_file.exists(), f\"{self.subscriptions_file} does not exist\"\n            data = pd.read_csv(self.subscriptions_file)\n            csv_cols = set(data.columns)\n            sub_cols = {e.value for e in SubscriptionFileRequiredColumns}\n            assert sub_cols.issubset(csv_cols), f\"{sub_cols} are required columns for a valid subscription file\"\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_user_models(self):\n        base_project_path = self.project_path\n        if self.user_models:\n            paths = []\n            for file in self.user_models:\n                model_file = base_project_path / CASESTUDY_FOLDER / file\n                assert model_file.exists(), f\"{model_file} does not esist\"\n                assert model_file.suffix == \".dll\", \"Invalid file extension. Use dll files\"\n                paths.append(model_file)\n            self.user_models = paths\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_simulation_mode(self):\n        if self.simulation_mode in [SimulationModes.DYNAMIC, SimulationModes.SNAP]:\n            assert (\n                not self.use_profile_manager\n            ), \"Profile manager can not be used for dynamic simulations. Set 'Use profile manager' to False\"\n        return self\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>PyPSSE project settings</p> Source code in <code>pypsse\\models.py</code> <pre><code>class SimulationSettings(BaseModel):\n    \"PyPSSE project settings\"\n\n    simulation: SimSettings\n    export: ExportSettings\n    helics: Optional[HelicsSettings] = None\n    log: LogSettings\n    plots: Optional[PlotSettings] = None\n    gic_export_settings: Optional[GICExportSettings] = None\n    bus_subsystems: BusSubsystems\n    loads: LoadSettings\n    generators: GeneratorSettings\n    contingencies: Optional[List[Union[BusFault, LineFault, LineTrip, BusTrip, MachineTrip]]] = None\n\n    @model_validator(mode=\"after\")\n    def validate_export_paths(self):\n        base_project_path = self.simulation.project_path\n        if self.export.outx_file:\n            self.export.outx_file = base_project_path / EXPORTS_FOLDER / self.export.outx_file\n        if self.export.out_file:\n            self.export.out_file = base_project_path / EXPORTS_FOLDER / self.export.out_file\n        if self.export.excel_file:\n            self.export.excel_file = base_project_path / EXPORTS_FOLDER / self.export.excel_file\n        if self.export.log_file:\n            self.export.log_file = base_project_path / LOGS_FOLDER / self.export.log_file\n        if self.export.networkx_graph_file:\n            self.export.networkx_graph_file = base_project_path / EXPORTS_FOLDER / self.export.networkx_graph_file\n        if self.export.coordinate_file:\n            self.export.coordinate_file = base_project_path / EXPORTS_FOLDER / self.export.coordinate_file\n        return self\n</code></pre>"},{"location":"code/reference/","title":"PyPSSE package","text":""},{"location":"code/reference/#reference-manual","title":"Reference manual","text":""},{"location":"code/reference/#simulation-components","title":"Simulation components","text":"<p>Base class for the simulator</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>class Simulator:\n    \"Base class for the simulator\"\n\n    _status: SimulationStatus = SimulationStatus.NOT_INITIALIZED\n\n    def __init__(self, settings_toml_path=\"\", psse_path=\"\"):\n        \"Load a valid PyPSSE project and sets up simulation\"\n        self._status = SimulationStatus.STARTING_INSTANCE\n        settings = self.read_settings(settings_toml_path)\n        self.settings = SimulationSettings.model_validate(settings)\n        export_settings_path = self.settings.simulation.project_path / EXPORTS_SETTINGS_FILENAME\n        assert export_settings_path.exists(), f\"{export_settings_path} does nor exist\"\n        export_settings = self.read_settings(export_settings_path)\n        self.export_settings = ExportFileOptions.model_validate(export_settings)\n\n        log_path = os.path.join(self.settings.simulation.project_path, LOGS_FOLDER)\n        self.logger = logger.get_logger(\"pyPSSE\", log_path, logger_options=self.settings.log)\n        self.logger.debug(\"Starting PSSE instance\")\n\n        if psse_path != \"\" and Path(psse_path).exists():\n            self.settings.simulation.psse_path = Path(psse_path)\n            sys.path.append(psse_path)\n            os.environ[\"PATH\"] += \";\" + psse_path\n        else:\n            sys.path.append(str(self.settings.simulation.psse_path))\n            os.environ[\"PATH\"] += \";\" + str(self.settings.simulation.psse_path)\n\n        n_bus = 200000\n        if \"psse34\" in str(self.settings.simulation.psse_path).lower():\n            self.logger.debug(\"Instantiating psse version 34\")\n            import psse34  # noqa: F401\n        elif \"psse35\" in str(self.settings.simulation.psse_path).lower():\n            self.logger.debug(\"Instantiating psse version 35\")\n            import psse35  # noqa: F401\n        else:\n            self.logger.debug(\"Instantiating psse version 36\")\n            import psse36  # noqa: F401\n        import dyntools\n        import psspy\n\n        self.dyntools = dyntools\n        self.psse = psspy\n        # self.logger.debug('Initializing PSS/E. connecting to license server')\n        ierr = self.psse.psseinit(n_bus)\n        assert ierr == 0, f\"Error code: {ierr}\"\n        self.psse.psseinit(n_bus)\n\n        self.start_simulation()\n        self.init()\n        self._status = SimulationStatus.INITIALIZATION_COMPLETE\n\n    def dump_settings(self, dest_dir):\n        setting_toml_file = os.path.join(os.path.dirname(__file__), \"defaults\", \"pyPSSE_settings.toml\")\n        export_toml_file = os.path.join(os.path.dirname(__file__), \"defaults\", \"export_settings.toml\")\n        shutil.copy(setting_toml_file, dest_dir)\n        shutil.copy(export_toml_file, dest_dir)\n\n    def start_simulation(self):\n        \"Starts a loaded simulation\"\n        self.hi = None\n        self.simStartTime = time.time()\n\n        if self.settings.simulation.case_study.exists():\n            self.psse.case(str(self.settings.simulation.case_study))\n        elif self.settings.simulation.raw_file.exists():\n            self.psse.read(0, str(self.settings.simulation.raw_file))\n        else:\n            msg = \"Please pass a RAW or SAV file in the settings dictionary\"\n            raise Exception(msg)\n\n        self.logger.info(f\"Trying to read a file &gt;&gt;{self.settings.simulation.case_study}\")\n        self.raw_data = rd.Reader(self.psse, self.logger)\n        (\n            self.bus_subsystems,\n            self.all_subsysten_buses,\n        ) = self.define_bus_subsystems()\n\n        if self.export_settings.defined_subsystems_only:\n            valid_buses = self.all_subsysten_buses\n        else:\n            valid_buses = self.raw_data.buses\n\n        self.sim = sc.sim_controller(\n            self.psse,\n            self.dyntools,\n            self.settings,\n            self.export_settings,\n            self.logger,\n            valid_buses,\n            self.raw_data,\n        )\n\n        self.contingencies = self.build_contingencies()\n\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            if self.settings.simulation.simulation_mode in [\n                SimulationModes.DYNAMIC,\n                SimulationModes.SNAP,\n            ]:\n                ...\n            self.hi = HelicsInterface(\n                self.psse,\n                self.sim,\n                self.settings,\n                self.export_settings,\n                self.bus_subsystems,\n                self.logger,\n            )\n            self.publications = self.hi.register_publications(self.bus_subsystems)\n            if self.settings.helics.create_subscriptions:\n                self.subscriptions = self.hi.register_subscriptions()\n\n        if self.settings.simulation.gic_file:\n            self.network_graph = self.parse_gic_file()\n            self.bus_ids = self.network_graph.nodes.keys()\n        else:\n            self.network_graph = None\n\n        self.results = Container(self.settings, self.export_settings)\n        self.exp_vars = self.results.get_export_variables()\n        self.inc_time = True\n\n    def init(self):\n        \"Initializes the model\"\n\n        self.sim.init(self.bus_subsystems)\n\n        if self.settings.simulation.use_profile_manager:\n            self.pm = ProfileManager(None, self.sim, self.settings, self.logger)\n            self.pm.setup_profiles()\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            self.hi.enter_execution_mode()\n\n    def parse_gic_file(self):\n        \"Parses the GIC file (if included in the project)\"\n\n        gicdata = gp.GICParser(self.settings, self.logger)\n        return gicdata.psse_graph\n\n    def define_bus_subsystems(self):\n        \"Defines a bussystem in the loaded PSSE model\"\n\n        bus_subsystems_dict = {}\n        bus_subsystems = self.get_bus_indices()\n        # valid bus subsystem ID. Valid bus subsystem IDs range from 0 to 11 (PSSE documentation)\n        if len(bus_subsystems) &gt; MAX_PSSE_BUSSYSTEMS:\n            msg = \"Number of subsystems can not be more that 12. See PSSE documentation\"\n            raise Exception(msg)\n\n        all_subsysten_buses = []\n        for i, buses in enumerate(bus_subsystems):\n            if not buses:\n                continue\n\n            all_subsysten_buses.extend(buses)\n            ierr = self.psse.bsysinit(i)\n            if ierr:\n                msg = \"Failed to create bus subsystem chosen buses.\"\n                raise Exception(msg)\n            else:\n                self.logger.debug(f'Bus subsystem \"{i}\" created')\n\n            ierr = self.psse.bsys(sid=i, numbus=len(buses), buses=buses)\n            if ierr:\n                msg = \"Failed to add buses to bus subsystem.\"\n                raise Exception(msg)\n            else:\n                bus_subsystems_dict[i] = buses\n                self.logger.debug(f'Buses {buses} added to subsystem \"{i}\"')\n        all_subsysten_buses = [str(x) for x in all_subsysten_buses]\n        return bus_subsystems_dict, all_subsysten_buses\n\n    def get_bus_indices(self):\n        \"Retuens bus indices for bus subsystems\"\n\n        if self.settings.bus_subsystems.from_file:\n            bus_file = self.settings.bus_subsystems.bus_file\n            bus_info = pd.read_csv(bus_file, index_col=None)\n            bus_info = bus_info.values\n            _, n_cols = bus_info.shape\n            bus_data = []\n            for col in range(n_cols):\n                data = [int(x) for x in bus_info[:, col] if not np.isnan(x)]\n                bus_data.append(data)\n        else:\n            bus_data = self.settings.bus_subsystems.bus_subsystem_list\n        return bus_data\n\n    def read_settings(self, settings_toml_path):\n        \"Read the user defined settings\"\n\n        settings_text = \"\"\n        f = open(settings_toml_path)\n        text = settings_text.join(f.readlines())\n        toml_data = toml.loads(text)\n        toml_data = {str(k): (str(v) if isinstance(v, str) else v) for k, v in toml_data.items()}\n        f.close()\n        return toml_data\n\n    def run(self):\n        \"Launches the simulation\"\n        self._status = SimulationStatus.RUNNING_SIMULATION\n        if self.sim.initialization_complete:\n            if self.settings.plots and self.settings.plots.enable_dynamic_plots:\n                bokeh_server_proc = subprocess.Popen([\"bokeh\", \"serve\"], stdout=subprocess.PIPE)  # noqa: S603,S607\n            else:\n                bokeh_server_proc = None\n\n            self.logger.debug(\n                f\"Running dynamic simulation for time {self.settings.simulation.simulation_time.total_seconds()} sec\"\n            )\n            total_simulation_time = self.settings.simulation.simulation_time.total_seconds()\n            t = 0\n            while True:\n                self.step(t)\n                if self.inc_time:\n                    t += self.settings.simulation.simulation_step_resolution.total_seconds()\n                if t &gt;= total_simulation_time:\n                    break\n\n            self.psse.pssehalt_2()\n            if not self.export_settings.export_results_using_channels:\n                self.results.export_results()\n            else:\n                self.sim.export()\n\n            if bokeh_server_proc is not None:\n                bokeh_server_proc.terminate()\n        else:\n            self.logger.error(\"Run init() command to initialize models before running the simulation\")\n        self._status = \"Simulation complete\"\n\n    def get_bus_ids(self):\n        \"Returns bus IDs\"\n\n        ierr, iarray = self.psse.abusint(-1, 1, \"NUMBER\")\n        assert ierr == 0, f\"Error code: {ierr}\"\n        return iarray\n\n    def step(self, t):\n        \"Steps through a single simulation time step. Is called iteratively to increment the simualtion\"\n        self.update_contingencies(t)\n        if self.settings.simulation.use_profile_manager:\n            self.pm.update()\n        ctime = time.time() - self.simStartTime\n        self.logger.debug(f\"Simulation time: {t} seconds; Run time: {ctime}; pyPSSE time: {self.sim.get_time()}\")\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            if self.settings.helics.create_subscriptions:\n                self.update_subscriptions()\n                self.logger.debug(f\"Time requested: {t}\")\n                self.inc_time, helics_time = self.update_federate_time(t)\n                self.logger.debug(f\"Time granted: {helics_time}\")\n\n        if self.inc_time:\n            self.sim.step(t)\n        else:\n            self.sim.resolve_step()\n\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            self.publish_data()\n\n        curr_results = self.update_result_container(t)\n        return curr_results\n\n    def update_result_container(self, t):\n        if self.export_settings.defined_subsystems_only:\n            curr_results = self.sim.read_subsystems(self.exp_vars, self.all_subsysten_buses)\n        else:\n            curr_results = self.sim.read_subsystems(self.exp_vars, self.raw_data.buses)\n\n        if not USING_NAERM:\n            if not self.export_settings.export_results_using_channels:\n                self.results.update(curr_results, t, self.sim.get_time(), self.sim.has_converged())\n        return curr_results\n\n    def update_subscriptions(self):\n        \"Updates subscriptions (co-simulation mode only)\"\n\n        self.hi.subscribe()\n\n    def update_federate_time(self, t):\n        \"Makes a time request to teh HELICS broker (co-simulation mode only)\"\n\n        inc_time, curr_time = self.hi.request_time(t)\n        return inc_time, curr_time\n\n    def publish_data(self):\n        \"Updates publications (co-simulation mode only)\"\n        self.hi.publish()\n\n    def get_results(self, params):\n        \"Returns queried simulation results\"\n        self._status = SimulationStatus.STARTING_RESULT_EXPORT\n        self.exp_vars = self.results.update_export_variables(params)\n        curr_results = (\n            self.sim.read_subsystems(self.exp_vars, self.all_subsysten_buses)\n            if self.export_settings.defined_subsystems_only\n            else self.sim.read_subsystems(self.exp_vars, self.raw_data.buses)\n        )\n        self._status = SimulationModes.RESULT_EXPORT_COMPLETE\n        return curr_results\n\n    def status(self):\n        return self._status.value\n\n    def restructure_results(self, results, class_name):\n        \"Restructure results for the improved user experience\"\n\n        # c_names = []\n        p_names = []\n        data = []\n        bud_id = []\n        uuid = []\n        ckt_id = []\n        to_bus = []\n        to_bus2 = []\n        for class_ppty, v_dict in results.items():\n            if len(class_ppty.split(\"_\")) == 3:  # noqa: PLR2004\n                c_name = class_ppty.split(\"_\")[0] + \"_\" + class_ppty.split(\"_\")[1]\n                p_name = class_ppty.split(\"_\")[2]\n            else:\n                c_name = class_ppty.split(\"_\")[0]\n                p_name = class_ppty.split(\"_\")[1]\n            if c_name == class_name:\n                # c_names.append(c_name)\n                p_names.append(p_name)\n                keys = list(v_dict.keys())\n                bud_id = []\n                ckt_id = []\n                uuid = []\n                to_bus = []\n                to_bus2 = []\n\n                for k_raw in keys:\n                    k = str(k_raw)\n                    if \"_\" in k:\n                        if len(k.split(\"_\")) == 2:  # noqa: PLR2004\n                            bud_id.append(k.split(\"_\")[1])\n                            uuid.append(k.split(\"_\")[0])\n                        if len(k.split(\"_\")) == 3:  # noqa: PLR2004\n                            bud_id.append(k.split(\"_\")[0])\n                            ckt_id.append(k.split(\"_\")[2])\n                            to_bus.append(k.split(\"_\")[1])\n                        if len(k.split(\"_\")) == 4:  # noqa: PLR2004\n                            bud_id.append(k.split(\"_\")[0])\n                            ckt_id.append(k.split(\"_\")[3])\n                            to_bus.append(k.split(\"_\")[1])\n                            to_bus2.append(k.split(\"_\")[2])\n                    else:\n                        bud_id.append(k)\n                data.append(list(v_dict.values()))\n        return p_names, bud_id, uuid, to_bus, to_bus2, ckt_id, data\n\n    def get_bus_data(self, t, bus_subsystem_id):\n        \"Return bus data\"\n\n        bus_data_formated = []\n        ierr, rarray = self.psse.abusint(bus_subsystem_id, 1, \"NUMBER\")\n        assert ierr == 0, f\"Error code: {ierr}\"\n        bus_numbers = rarray[0]\n        ierr, bus_data = self.psse.abusreal(bus_subsystem_id, 1, [\"PU\", \"ANGLED\", \"MISMATCH\"])\n        assert ierr == 0, f\"Error code: {ierr}\"\n        if ierr:\n            self.logger.warning(f\"Unable to read voltage data at time {t} (seconds)\")\n        bus_data = np.array(bus_data)\n\n        for i, j in enumerate(bus_numbers):\n            bus_data_formated.append([j, bus_data[0, i], bus_data[1, i], bus_data[2, i]])\n        return bus_data_formated\n\n    def build_contingencies(self):\n        \"Builds user defined contengingies\"\n\n        contingencies = c.build_contingencies(self.psse, self.settings, self.logger)\n        return contingencies\n\n    def update_contingencies(self, t):\n        \"Updates contingencies during the simualtion run\"\n        for contingency in self.contingencies:\n            contingency.update(t)\n\n    def __del__(self):\n        if hasattr(self, \"PSSE\"):\n            self.psse.pssehalt_2()\n</code></pre> <p>This class defines the structure of a PyPSSE project</p> Source code in <code>pypsse\\project.py</code> <pre><code>class Project:\n    \"This class defines the structure of a PyPSSE project\"\n\n    def __init__(self):\n        logging.root.setLevel(\"DEBUG\")\n        self.basepath = Path(__file__).parent\n\n    def create(\n        self,\n        parent_path,\n        project_name,\n        psse_folder,\n        simulation_settings_file,\n        export_settings_file,\n        profile_store_file,\n        profile_mapping_file,\n        overwrite=True,\n        autofill=True,\n    ):\n        \"The methods creates a new PyPSSE project\"\n\n        exports_dict = toml.load(self.basepath / DEFAULTS_FOLDER / EXPORTS_SETTINGS_FILENAME)\n        export_settings = ExportFileOptions(**exports_dict)\n\n        if export_settings_file:\n            export_settings_file = Path(export_settings_file)\n            assert export_settings_file.exists(), f\"Export file '{export_settings_file}' does not exist\"\n            new_export_settings = toml.load(export_settings_file)\n            export_settings.update(**new_export_settings)\n\n        sim_setting_dict = toml.load(self.basepath / DEFAULTS_FOLDER / SIMULATION_SETTINGS_FILENAME)\n        simulation_settings = SimulationSettings(**sim_setting_dict)\n\n        if simulation_settings_file:\n            simulation_settings_file = Path(simulation_settings_file)\n            assert simulation_settings_file.exists(), f\"Export file '{simulation_settings_file}' does not exist\"\n            sim_setting_dict = toml.load(simulation_settings_file)\n            simulation_settings.update(**sim_setting_dict)\n\n        simulation_settings.simulation.project_path = Path(parent_path) / project_name\n\n        self.project = ProjectDefination(\n            project_name=project_name,\n            simulation_settings=simulation_settings,\n            export_settings=export_settings,\n            overwrite=overwrite,\n            autofill=autofill,\n        )\n        self.project_path = Path(parent_path) / project_name\n\n        self._create_folders()\n\n        if psse_folder:\n            psse_files = self._copy_psse_project_files(psse_folder)\n            if autofill and psse_files:\n                self._autofill_settings(psse_files, profile_store_file, profile_mapping_file)\n\n        self._update_export_files()\n        self._write_setting_files()\n\n    def _update_export_files(self):\n        self.project.simulation_settings.export.out_file = DEFAULT_OUT_FILE\n        self.project.simulation_settings.export.outx_file = DEFAULT_OUTX_FILE\n        self.project.simulation_settings.export.log_file = DEFAULT_LOG_FILE\n        self.project.simulation_settings.export.excel_file = DEFAULT_EXCEL_FILE\n        self.project.simulation_settings.export.coordinate_file = DEFAULT_COORDINATES_FILE\n        self.project.simulation_settings.export.networkx_graph_file = DEFAULT_GRAPH_FILE\n\n    def _psse_project_file_dict(self, path):\n        \"Creates a mapping of all PyPSSE project files\"\n        file_dict = {}\n        for _, _, files in os.walk(path):\n            for file in files:\n                _, ext = file.split(\".\")\n                if ext not in file_dict:\n                    file_dict[ext.lower()] = [file]\n                else:\n                    file_dict[ext.lower()].append(file)\n        return file_dict\n\n    def _copy_psse_project_files(self, psse_folder):\n        \"Copies PSSE file to the new project folder\"\n        psse_folder = Path(psse_folder)\n        if psse_folder.exists():\n            new_path = self.project_path / CASESTUDY_FOLDER\n            copy_tree(str(psse_folder.absolute()), str(new_path.absolute()))\n            psse_files = self._psse_project_file_dict(new_path)\n        else:\n            msg = f\"PSSE project path does not exist. ({psse_folder}) {os.getcwd()}\"\n            raise Exception(msg)\n        return psse_files\n\n    def _write_setting_files(self):\n        sim_file_path = self.project_path / SIMULATION_SETTINGS_FILENAME\n        with open(sim_file_path, \"w\") as f:\n            toml.dump(json.loads(self.project.simulation_settings.model_dump_json()), f)\n\n        export_file_path = self.project_path / EXPORTS_SETTINGS_FILENAME\n        with open(export_file_path, \"w\") as f:\n            toml.dump(json.loads(self.project.export_settings.model_dump_json()), f)\n\n    def _create_folders(self):\n        \"Creates folder structure for a new project. Older project can be over-written\"\n\n        for folder in self.project.project_folders:\n            project_folder = self.project_path / folder.value\n            if project_folder.exists() and not self.project.overwrite:\n                msg = \"Project folder already exists. Set overwrite=true to overwrite existing projects\"\n                raise Exception(msg)\n            elif not project_folder.exists():\n                project_folder.mkdir(parents=True, exist_ok=True)\n\n    def _autofill_settings(self, psse_files, profile_store_file, profile_mapping_file):\n        \"The method auto populates fields for a new PyPSSE project\"\n\n        self._update_setting(\"sav\", \"case_study\", psse_files)\n        self._update_setting(\"raw\", \"raw_file\", psse_files)\n        self._update_setting(\"snp\", \"snp_file\", psse_files)\n        self._update_setting(\"dyr\", \"dyr_file\", psse_files)\n        self._update_setting(\"gic\", \"gic_file\", psse_files)\n        self._update_setting(\"rwm\", \"rwm_file\", psse_files)\n\n        if \"dll\" in psse_files:\n            self.project.simulation_settings.simulation.user_models = psse_files[\"dll\"]\n            logging.info(f\"user_models={psse_files['dll']}\")\n        else:\n            logging.info(\"No DLL files found in project path\")\n\n        if \"idv\" in psse_files:\n            self.project.simulation_settings.simulation.setup_files = psse_files[\"idv\"]\n            logging.info(\n                f\"setup_files={psse_files['idv']}\"\n                f\"\\nSequence of IDV setup files is important. Manually change in TOML file if needed\"\n            )\n        else:\n            logging.info(\"No IDV files found in project path\")\n\n        store_path = self.project_path / PROFILES_FOLDER\n        if profile_store_file and Path(profile_store_file).exists():\n            assert Path(profile_store_file).suffix.lower() == \".hdf5\", \"Store file should be a valid hdf5 file\"\n            copy(profile_store_file, store_path)\n        else:\n            ProfileManager(None, None, self.project.simulation_settings, logging)\n\n        if profile_mapping_file and Path(profile_mapping_file).exists():\n            assert Path(profile_mapping_file).suffix.lower() == \".toml\", \"Profile mapping should be a valid toml file\"\n            copy(profile_mapping_file, store_path)\n            self.project.simulation_settings.simulation.use_profile_manager = True\n        else:\n            # TODO: auto generate mapping file from bus subsystem files\n            with open(os.path.join(store_path, DEFAULT_PROFILE_MAPPING_FILENAME), \"w\") as _:\n                pass\n            self.project.simulation_settings.simulation.use_profile_manager = False\n\n        self._create_default_sub_file()\n\n    def _create_default_sub_file(self):\n        \"Method creates a subscription file for the HELICS interface\"\n        subscription_fields = [x.value for x in SubscriptionFileRequiredColumns]\n        data = pd.DataFrame({}, columns=list(subscription_fields))\n        data.to_csv(self.project_path / DEFAULT_SUBSCRIPTION_FILENAME, index=False)\n        logging.info(\"Creating subscription template\")\n        self.project.simulation_settings.simulation.subscriptions_file = DEFAULT_SUBSCRIPTION_FILENAME\n\n    def _update_setting(self, f_type, key, psse_files):\n        if f_type in psse_files:\n            relevent_files = psse_files[f_type]\n            setattr(self.project.simulation_settings.simulation, key, relevent_files[0])\n            logging.info(f\"Settings:{key}={relevent_files[0]}\")\n            if len(relevent_files) &gt; 1:\n                logging.warning(\n                    f\"More than one file with extension {f_type} exist.\"\n                    f\"\\nFiles found: {relevent_files}\"\n                    f\"\\nManually update the settings toml file\"\n                )\n        else:\n            logging.warning(f\"No file with extension '{f_type}'\")\n</code></pre> <p>Class defination for the simulation result container</p> Source code in <code>pypsse\\result_container.py</code> <pre><code>class Container:\n    \"Class defination for the simulation result container\"\n\n    BULK_WRITE_MODES = [m.value for m in BulkWriteModes]\n    STREAMED_WRITE_MODES = [m.value for m in StreamedWriteModes]\n\n    def __init__(self, settings: SimulationSettings, export_settings: ExportAssetTypes):\n        \"Sets up the result container object\"\n\n        export__list = [m.value for m in ModelTypes]\n        self.export_path = settings.simulation.project_path / EXPORTS_FOLDER\n        self.export_settings = export_settings\n        self.settings = settings\n        self.results = {}\n        self.export_vars = {}\n        for class_name in export__list:\n            mapped_name = MAPPED_CLASS_NAMES[class_name.lower()]\n            variables = getattr(export_settings, class_name.lower())\n            if variables:\n                for variable in variables:\n                    self.results[f\"{mapped_name}_{variable.value}\"] = None\n                    if mapped_name not in self.export_vars:\n                        self.export_vars[mapped_name] = []\n                    self.export_vars[mapped_name].append(variable.value)\n\n        time_steps = int(\n            self.settings.simulation.simulation_time.total_seconds()\n            / self.settings.simulation.simulation_step_resolution.total_seconds()\n        )\n        if self.export_settings.file_format not in self.BULK_WRITE_MODES:\n            self.dataWriter = DataWriter(self.export_path, export_settings.file_format.value, time_steps)\n\n    def update_export_variables(self, params):\n        \"\"\"Updates the container with current system state.\n        Method is called iteratively to store results as a simulation executes\"\"\"\n\n        export__list = [m.value for m in ModelTypes]\n        self.results = {}\n        self.export_vars = {}\n\n        class_assets = ExportAssetTypes(**params) if params else self.export_settings\n\n        for class_name in export__list:\n            if class_name in params:\n                mapped_name = MAPPED_CLASS_NAMES[class_name]\n                variables = getattr(class_assets, class_name)\n                if variables:\n                    for variable in variables:\n                        self.results[f\"{mapped_name}_{variable.value}\"] = None\n                        if mapped_name not in self.export_vars:\n                            self.export_vars[mapped_name] = []\n                        self.export_vars[mapped_name].append(variable.value)\n\n        return self.export_vars\n\n    def get_export_variables(self):\n        \"Queries and return results from the current timestep\"\n        return self.export_vars\n\n    def update(self, bus_data, _, time, has_converged):\n        \"Updates the results cotainer\"\n        if self.export_settings.file_format not in self.BULK_WRITE_MODES:\n            self.dataWriter.write(time, bus_data, has_converged)\n        else:\n            for variable_name, _ in bus_data.items():\n                if not isinstance(self.results[f\"{variable_name}\"], pd.DataFrame):\n                    self.results[f\"{variable_name}\"] = pd.DataFrame(bus_data[variable_name], index=[0])\n                else:\n                    df1 = self.results[f\"{variable_name}\"]\n                    df2 = pd.DataFrame.from_dict([bus_data[variable_name]])\n                    concatenated = pd.concat([df1, df2])\n                    self.results[f\"{variable_name}\"] = concatenated\n\n    def export_results(self):\n        \"Exports all results stored to an external file.\"\n        if self.export_settings.file_format in self.BULK_WRITE_MODES:\n            for df_name, df in self.results.items():\n                export_path = (\n                    self.settings.simulation.project_path\n                    / EXPORTS_FOLDER\n                    / f'{df_name}.{self.export_settings[\"Write format\"]}'\n                )\n                if self.export_settings.file_format == BulkWriteModes.CSV:\n                    if isinstance(df, pd.DataFrame):\n                        df.to_csv(export_path)\n                elif self.export_settings.file_format == BulkWriteModes.PKL:\n                    df.to_pickle(export_path)\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.__init__","title":"<code>__init__(settings_toml_path='', psse_path='')</code>","text":"<p>Load a valid PyPSSE project and sets up simulation</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def __init__(self, settings_toml_path=\"\", psse_path=\"\"):\n    \"Load a valid PyPSSE project and sets up simulation\"\n    self._status = SimulationStatus.STARTING_INSTANCE\n    settings = self.read_settings(settings_toml_path)\n    self.settings = SimulationSettings.model_validate(settings)\n    export_settings_path = self.settings.simulation.project_path / EXPORTS_SETTINGS_FILENAME\n    assert export_settings_path.exists(), f\"{export_settings_path} does nor exist\"\n    export_settings = self.read_settings(export_settings_path)\n    self.export_settings = ExportFileOptions.model_validate(export_settings)\n\n    log_path = os.path.join(self.settings.simulation.project_path, LOGS_FOLDER)\n    self.logger = logger.get_logger(\"pyPSSE\", log_path, logger_options=self.settings.log)\n    self.logger.debug(\"Starting PSSE instance\")\n\n    if psse_path != \"\" and Path(psse_path).exists():\n        self.settings.simulation.psse_path = Path(psse_path)\n        sys.path.append(psse_path)\n        os.environ[\"PATH\"] += \";\" + psse_path\n    else:\n        sys.path.append(str(self.settings.simulation.psse_path))\n        os.environ[\"PATH\"] += \";\" + str(self.settings.simulation.psse_path)\n\n    n_bus = 200000\n    if \"psse34\" in str(self.settings.simulation.psse_path).lower():\n        self.logger.debug(\"Instantiating psse version 34\")\n        import psse34  # noqa: F401\n    elif \"psse35\" in str(self.settings.simulation.psse_path).lower():\n        self.logger.debug(\"Instantiating psse version 35\")\n        import psse35  # noqa: F401\n    else:\n        self.logger.debug(\"Instantiating psse version 36\")\n        import psse36  # noqa: F401\n    import dyntools\n    import psspy\n\n    self.dyntools = dyntools\n    self.psse = psspy\n    # self.logger.debug('Initializing PSS/E. connecting to license server')\n    ierr = self.psse.psseinit(n_bus)\n    assert ierr == 0, f\"Error code: {ierr}\"\n    self.psse.psseinit(n_bus)\n\n    self.start_simulation()\n    self.init()\n    self._status = SimulationStatus.INITIALIZATION_COMPLETE\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.build_contingencies","title":"<code>build_contingencies()</code>","text":"<p>Builds user defined contengingies</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def build_contingencies(self):\n    \"Builds user defined contengingies\"\n\n    contingencies = c.build_contingencies(self.psse, self.settings, self.logger)\n    return contingencies\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.define_bus_subsystems","title":"<code>define_bus_subsystems()</code>","text":"<p>Defines a bussystem in the loaded PSSE model</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def define_bus_subsystems(self):\n    \"Defines a bussystem in the loaded PSSE model\"\n\n    bus_subsystems_dict = {}\n    bus_subsystems = self.get_bus_indices()\n    # valid bus subsystem ID. Valid bus subsystem IDs range from 0 to 11 (PSSE documentation)\n    if len(bus_subsystems) &gt; MAX_PSSE_BUSSYSTEMS:\n        msg = \"Number of subsystems can not be more that 12. See PSSE documentation\"\n        raise Exception(msg)\n\n    all_subsysten_buses = []\n    for i, buses in enumerate(bus_subsystems):\n        if not buses:\n            continue\n\n        all_subsysten_buses.extend(buses)\n        ierr = self.psse.bsysinit(i)\n        if ierr:\n            msg = \"Failed to create bus subsystem chosen buses.\"\n            raise Exception(msg)\n        else:\n            self.logger.debug(f'Bus subsystem \"{i}\" created')\n\n        ierr = self.psse.bsys(sid=i, numbus=len(buses), buses=buses)\n        if ierr:\n            msg = \"Failed to add buses to bus subsystem.\"\n            raise Exception(msg)\n        else:\n            bus_subsystems_dict[i] = buses\n            self.logger.debug(f'Buses {buses} added to subsystem \"{i}\"')\n    all_subsysten_buses = [str(x) for x in all_subsysten_buses]\n    return bus_subsystems_dict, all_subsysten_buses\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.get_bus_data","title":"<code>get_bus_data(t, bus_subsystem_id)</code>","text":"<p>Return bus data</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def get_bus_data(self, t, bus_subsystem_id):\n    \"Return bus data\"\n\n    bus_data_formated = []\n    ierr, rarray = self.psse.abusint(bus_subsystem_id, 1, \"NUMBER\")\n    assert ierr == 0, f\"Error code: {ierr}\"\n    bus_numbers = rarray[0]\n    ierr, bus_data = self.psse.abusreal(bus_subsystem_id, 1, [\"PU\", \"ANGLED\", \"MISMATCH\"])\n    assert ierr == 0, f\"Error code: {ierr}\"\n    if ierr:\n        self.logger.warning(f\"Unable to read voltage data at time {t} (seconds)\")\n    bus_data = np.array(bus_data)\n\n    for i, j in enumerate(bus_numbers):\n        bus_data_formated.append([j, bus_data[0, i], bus_data[1, i], bus_data[2, i]])\n    return bus_data_formated\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.get_bus_ids","title":"<code>get_bus_ids()</code>","text":"<p>Returns bus IDs</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def get_bus_ids(self):\n    \"Returns bus IDs\"\n\n    ierr, iarray = self.psse.abusint(-1, 1, \"NUMBER\")\n    assert ierr == 0, f\"Error code: {ierr}\"\n    return iarray\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.get_bus_indices","title":"<code>get_bus_indices()</code>","text":"<p>Retuens bus indices for bus subsystems</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def get_bus_indices(self):\n    \"Retuens bus indices for bus subsystems\"\n\n    if self.settings.bus_subsystems.from_file:\n        bus_file = self.settings.bus_subsystems.bus_file\n        bus_info = pd.read_csv(bus_file, index_col=None)\n        bus_info = bus_info.values\n        _, n_cols = bus_info.shape\n        bus_data = []\n        for col in range(n_cols):\n            data = [int(x) for x in bus_info[:, col] if not np.isnan(x)]\n            bus_data.append(data)\n    else:\n        bus_data = self.settings.bus_subsystems.bus_subsystem_list\n    return bus_data\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.get_results","title":"<code>get_results(params)</code>","text":"<p>Returns queried simulation results</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def get_results(self, params):\n    \"Returns queried simulation results\"\n    self._status = SimulationStatus.STARTING_RESULT_EXPORT\n    self.exp_vars = self.results.update_export_variables(params)\n    curr_results = (\n        self.sim.read_subsystems(self.exp_vars, self.all_subsysten_buses)\n        if self.export_settings.defined_subsystems_only\n        else self.sim.read_subsystems(self.exp_vars, self.raw_data.buses)\n    )\n    self._status = SimulationModes.RESULT_EXPORT_COMPLETE\n    return curr_results\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.init","title":"<code>init()</code>","text":"<p>Initializes the model</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def init(self):\n    \"Initializes the model\"\n\n    self.sim.init(self.bus_subsystems)\n\n    if self.settings.simulation.use_profile_manager:\n        self.pm = ProfileManager(None, self.sim, self.settings, self.logger)\n        self.pm.setup_profiles()\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        self.hi.enter_execution_mode()\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.parse_gic_file","title":"<code>parse_gic_file()</code>","text":"<p>Parses the GIC file (if included in the project)</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def parse_gic_file(self):\n    \"Parses the GIC file (if included in the project)\"\n\n    gicdata = gp.GICParser(self.settings, self.logger)\n    return gicdata.psse_graph\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.publish_data","title":"<code>publish_data()</code>","text":"<p>Updates publications (co-simulation mode only)</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def publish_data(self):\n    \"Updates publications (co-simulation mode only)\"\n    self.hi.publish()\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.read_settings","title":"<code>read_settings(settings_toml_path)</code>","text":"<p>Read the user defined settings</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def read_settings(self, settings_toml_path):\n    \"Read the user defined settings\"\n\n    settings_text = \"\"\n    f = open(settings_toml_path)\n    text = settings_text.join(f.readlines())\n    toml_data = toml.loads(text)\n    toml_data = {str(k): (str(v) if isinstance(v, str) else v) for k, v in toml_data.items()}\n    f.close()\n    return toml_data\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.restructure_results","title":"<code>restructure_results(results, class_name)</code>","text":"<p>Restructure results for the improved user experience</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def restructure_results(self, results, class_name):\n    \"Restructure results for the improved user experience\"\n\n    # c_names = []\n    p_names = []\n    data = []\n    bud_id = []\n    uuid = []\n    ckt_id = []\n    to_bus = []\n    to_bus2 = []\n    for class_ppty, v_dict in results.items():\n        if len(class_ppty.split(\"_\")) == 3:  # noqa: PLR2004\n            c_name = class_ppty.split(\"_\")[0] + \"_\" + class_ppty.split(\"_\")[1]\n            p_name = class_ppty.split(\"_\")[2]\n        else:\n            c_name = class_ppty.split(\"_\")[0]\n            p_name = class_ppty.split(\"_\")[1]\n        if c_name == class_name:\n            # c_names.append(c_name)\n            p_names.append(p_name)\n            keys = list(v_dict.keys())\n            bud_id = []\n            ckt_id = []\n            uuid = []\n            to_bus = []\n            to_bus2 = []\n\n            for k_raw in keys:\n                k = str(k_raw)\n                if \"_\" in k:\n                    if len(k.split(\"_\")) == 2:  # noqa: PLR2004\n                        bud_id.append(k.split(\"_\")[1])\n                        uuid.append(k.split(\"_\")[0])\n                    if len(k.split(\"_\")) == 3:  # noqa: PLR2004\n                        bud_id.append(k.split(\"_\")[0])\n                        ckt_id.append(k.split(\"_\")[2])\n                        to_bus.append(k.split(\"_\")[1])\n                    if len(k.split(\"_\")) == 4:  # noqa: PLR2004\n                        bud_id.append(k.split(\"_\")[0])\n                        ckt_id.append(k.split(\"_\")[3])\n                        to_bus.append(k.split(\"_\")[1])\n                        to_bus2.append(k.split(\"_\")[2])\n                else:\n                    bud_id.append(k)\n            data.append(list(v_dict.values()))\n    return p_names, bud_id, uuid, to_bus, to_bus2, ckt_id, data\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.run","title":"<code>run()</code>","text":"<p>Launches the simulation</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def run(self):\n    \"Launches the simulation\"\n    self._status = SimulationStatus.RUNNING_SIMULATION\n    if self.sim.initialization_complete:\n        if self.settings.plots and self.settings.plots.enable_dynamic_plots:\n            bokeh_server_proc = subprocess.Popen([\"bokeh\", \"serve\"], stdout=subprocess.PIPE)  # noqa: S603,S607\n        else:\n            bokeh_server_proc = None\n\n        self.logger.debug(\n            f\"Running dynamic simulation for time {self.settings.simulation.simulation_time.total_seconds()} sec\"\n        )\n        total_simulation_time = self.settings.simulation.simulation_time.total_seconds()\n        t = 0\n        while True:\n            self.step(t)\n            if self.inc_time:\n                t += self.settings.simulation.simulation_step_resolution.total_seconds()\n            if t &gt;= total_simulation_time:\n                break\n\n        self.psse.pssehalt_2()\n        if not self.export_settings.export_results_using_channels:\n            self.results.export_results()\n        else:\n            self.sim.export()\n\n        if bokeh_server_proc is not None:\n            bokeh_server_proc.terminate()\n    else:\n        self.logger.error(\"Run init() command to initialize models before running the simulation\")\n    self._status = \"Simulation complete\"\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.start_simulation","title":"<code>start_simulation()</code>","text":"<p>Starts a loaded simulation</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def start_simulation(self):\n    \"Starts a loaded simulation\"\n    self.hi = None\n    self.simStartTime = time.time()\n\n    if self.settings.simulation.case_study.exists():\n        self.psse.case(str(self.settings.simulation.case_study))\n    elif self.settings.simulation.raw_file.exists():\n        self.psse.read(0, str(self.settings.simulation.raw_file))\n    else:\n        msg = \"Please pass a RAW or SAV file in the settings dictionary\"\n        raise Exception(msg)\n\n    self.logger.info(f\"Trying to read a file &gt;&gt;{self.settings.simulation.case_study}\")\n    self.raw_data = rd.Reader(self.psse, self.logger)\n    (\n        self.bus_subsystems,\n        self.all_subsysten_buses,\n    ) = self.define_bus_subsystems()\n\n    if self.export_settings.defined_subsystems_only:\n        valid_buses = self.all_subsysten_buses\n    else:\n        valid_buses = self.raw_data.buses\n\n    self.sim = sc.sim_controller(\n        self.psse,\n        self.dyntools,\n        self.settings,\n        self.export_settings,\n        self.logger,\n        valid_buses,\n        self.raw_data,\n    )\n\n    self.contingencies = self.build_contingencies()\n\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        if self.settings.simulation.simulation_mode in [\n            SimulationModes.DYNAMIC,\n            SimulationModes.SNAP,\n        ]:\n            ...\n        self.hi = HelicsInterface(\n            self.psse,\n            self.sim,\n            self.settings,\n            self.export_settings,\n            self.bus_subsystems,\n            self.logger,\n        )\n        self.publications = self.hi.register_publications(self.bus_subsystems)\n        if self.settings.helics.create_subscriptions:\n            self.subscriptions = self.hi.register_subscriptions()\n\n    if self.settings.simulation.gic_file:\n        self.network_graph = self.parse_gic_file()\n        self.bus_ids = self.network_graph.nodes.keys()\n    else:\n        self.network_graph = None\n\n    self.results = Container(self.settings, self.export_settings)\n    self.exp_vars = self.results.get_export_variables()\n    self.inc_time = True\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.step","title":"<code>step(t)</code>","text":"<p>Steps through a single simulation time step. Is called iteratively to increment the simualtion</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def step(self, t):\n    \"Steps through a single simulation time step. Is called iteratively to increment the simualtion\"\n    self.update_contingencies(t)\n    if self.settings.simulation.use_profile_manager:\n        self.pm.update()\n    ctime = time.time() - self.simStartTime\n    self.logger.debug(f\"Simulation time: {t} seconds; Run time: {ctime}; pyPSSE time: {self.sim.get_time()}\")\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        if self.settings.helics.create_subscriptions:\n            self.update_subscriptions()\n            self.logger.debug(f\"Time requested: {t}\")\n            self.inc_time, helics_time = self.update_federate_time(t)\n            self.logger.debug(f\"Time granted: {helics_time}\")\n\n    if self.inc_time:\n        self.sim.step(t)\n    else:\n        self.sim.resolve_step()\n\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        self.publish_data()\n\n    curr_results = self.update_result_container(t)\n    return curr_results\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.update_contingencies","title":"<code>update_contingencies(t)</code>","text":"<p>Updates contingencies during the simualtion run</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def update_contingencies(self, t):\n    \"Updates contingencies during the simualtion run\"\n    for contingency in self.contingencies:\n        contingency.update(t)\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.update_federate_time","title":"<code>update_federate_time(t)</code>","text":"<p>Makes a time request to teh HELICS broker (co-simulation mode only)</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def update_federate_time(self, t):\n    \"Makes a time request to teh HELICS broker (co-simulation mode only)\"\n\n    inc_time, curr_time = self.hi.request_time(t)\n    return inc_time, curr_time\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.update_subscriptions","title":"<code>update_subscriptions()</code>","text":"<p>Updates subscriptions (co-simulation mode only)</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def update_subscriptions(self):\n    \"Updates subscriptions (co-simulation mode only)\"\n\n    self.hi.subscribe()\n</code></pre>"},{"location":"code/reference/#pypsse.project.Project.create","title":"<code>create(parent_path, project_name, psse_folder, simulation_settings_file, export_settings_file, profile_store_file, profile_mapping_file, overwrite=True, autofill=True)</code>","text":"<p>The methods creates a new PyPSSE project</p> Source code in <code>pypsse\\project.py</code> <pre><code>def create(\n    self,\n    parent_path,\n    project_name,\n    psse_folder,\n    simulation_settings_file,\n    export_settings_file,\n    profile_store_file,\n    profile_mapping_file,\n    overwrite=True,\n    autofill=True,\n):\n    \"The methods creates a new PyPSSE project\"\n\n    exports_dict = toml.load(self.basepath / DEFAULTS_FOLDER / EXPORTS_SETTINGS_FILENAME)\n    export_settings = ExportFileOptions(**exports_dict)\n\n    if export_settings_file:\n        export_settings_file = Path(export_settings_file)\n        assert export_settings_file.exists(), f\"Export file '{export_settings_file}' does not exist\"\n        new_export_settings = toml.load(export_settings_file)\n        export_settings.update(**new_export_settings)\n\n    sim_setting_dict = toml.load(self.basepath / DEFAULTS_FOLDER / SIMULATION_SETTINGS_FILENAME)\n    simulation_settings = SimulationSettings(**sim_setting_dict)\n\n    if simulation_settings_file:\n        simulation_settings_file = Path(simulation_settings_file)\n        assert simulation_settings_file.exists(), f\"Export file '{simulation_settings_file}' does not exist\"\n        sim_setting_dict = toml.load(simulation_settings_file)\n        simulation_settings.update(**sim_setting_dict)\n\n    simulation_settings.simulation.project_path = Path(parent_path) / project_name\n\n    self.project = ProjectDefination(\n        project_name=project_name,\n        simulation_settings=simulation_settings,\n        export_settings=export_settings,\n        overwrite=overwrite,\n        autofill=autofill,\n    )\n    self.project_path = Path(parent_path) / project_name\n\n    self._create_folders()\n\n    if psse_folder:\n        psse_files = self._copy_psse_project_files(psse_folder)\n        if autofill and psse_files:\n            self._autofill_settings(psse_files, profile_store_file, profile_mapping_file)\n\n    self._update_export_files()\n    self._write_setting_files()\n</code></pre>"},{"location":"code/reference/#pypsse.result_container.Container.__init__","title":"<code>__init__(settings, export_settings)</code>","text":"<p>Sets up the result container object</p> Source code in <code>pypsse\\result_container.py</code> <pre><code>def __init__(self, settings: SimulationSettings, export_settings: ExportAssetTypes):\n    \"Sets up the result container object\"\n\n    export__list = [m.value for m in ModelTypes]\n    self.export_path = settings.simulation.project_path / EXPORTS_FOLDER\n    self.export_settings = export_settings\n    self.settings = settings\n    self.results = {}\n    self.export_vars = {}\n    for class_name in export__list:\n        mapped_name = MAPPED_CLASS_NAMES[class_name.lower()]\n        variables = getattr(export_settings, class_name.lower())\n        if variables:\n            for variable in variables:\n                self.results[f\"{mapped_name}_{variable.value}\"] = None\n                if mapped_name not in self.export_vars:\n                    self.export_vars[mapped_name] = []\n                self.export_vars[mapped_name].append(variable.value)\n\n    time_steps = int(\n        self.settings.simulation.simulation_time.total_seconds()\n        / self.settings.simulation.simulation_step_resolution.total_seconds()\n    )\n    if self.export_settings.file_format not in self.BULK_WRITE_MODES:\n        self.dataWriter = DataWriter(self.export_path, export_settings.file_format.value, time_steps)\n</code></pre>"},{"location":"code/reference/#pypsse.result_container.Container.export_results","title":"<code>export_results()</code>","text":"<p>Exports all results stored to an external file.</p> Source code in <code>pypsse\\result_container.py</code> <pre><code>def export_results(self):\n    \"Exports all results stored to an external file.\"\n    if self.export_settings.file_format in self.BULK_WRITE_MODES:\n        for df_name, df in self.results.items():\n            export_path = (\n                self.settings.simulation.project_path\n                / EXPORTS_FOLDER\n                / f'{df_name}.{self.export_settings[\"Write format\"]}'\n            )\n            if self.export_settings.file_format == BulkWriteModes.CSV:\n                if isinstance(df, pd.DataFrame):\n                    df.to_csv(export_path)\n            elif self.export_settings.file_format == BulkWriteModes.PKL:\n                df.to_pickle(export_path)\n</code></pre>"},{"location":"code/reference/#pypsse.result_container.Container.get_export_variables","title":"<code>get_export_variables()</code>","text":"<p>Queries and return results from the current timestep</p> Source code in <code>pypsse\\result_container.py</code> <pre><code>def get_export_variables(self):\n    \"Queries and return results from the current timestep\"\n    return self.export_vars\n</code></pre>"},{"location":"code/reference/#pypsse.result_container.Container.update","title":"<code>update(bus_data, _, time, has_converged)</code>","text":"<p>Updates the results cotainer</p> Source code in <code>pypsse\\result_container.py</code> <pre><code>def update(self, bus_data, _, time, has_converged):\n    \"Updates the results cotainer\"\n    if self.export_settings.file_format not in self.BULK_WRITE_MODES:\n        self.dataWriter.write(time, bus_data, has_converged)\n    else:\n        for variable_name, _ in bus_data.items():\n            if not isinstance(self.results[f\"{variable_name}\"], pd.DataFrame):\n                self.results[f\"{variable_name}\"] = pd.DataFrame(bus_data[variable_name], index=[0])\n            else:\n                df1 = self.results[f\"{variable_name}\"]\n                df2 = pd.DataFrame.from_dict([bus_data[variable_name]])\n                concatenated = pd.concat([df1, df2])\n                self.results[f\"{variable_name}\"] = concatenated\n</code></pre>"},{"location":"code/reference/#pypsse.result_container.Container.update_export_variables","title":"<code>update_export_variables(params)</code>","text":"<p>Updates the container with current system state. Method is called iteratively to store results as a simulation executes</p> Source code in <code>pypsse\\result_container.py</code> <pre><code>def update_export_variables(self, params):\n    \"\"\"Updates the container with current system state.\n    Method is called iteratively to store results as a simulation executes\"\"\"\n\n    export__list = [m.value for m in ModelTypes]\n    self.results = {}\n    self.export_vars = {}\n\n    class_assets = ExportAssetTypes(**params) if params else self.export_settings\n\n    for class_name in export__list:\n        if class_name in params:\n            mapped_name = MAPPED_CLASS_NAMES[class_name]\n            variables = getattr(class_assets, class_name)\n            if variables:\n                for variable in variables:\n                    self.results[f\"{mapped_name}_{variable.value}\"] = None\n                    if mapped_name not in self.export_vars:\n                        self.export_vars[mapped_name] = []\n                    self.export_vars[mapped_name].append(variable.value)\n\n    return self.export_vars\n</code></pre>"},{"location":"code/reference/#profile-management","title":"Profile management","text":""},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager","title":"<code>ProfileManager</code>","text":"<p>Implentation for the profile manager for PyPSSE. Enables attacheing profilse to all PSSE objects and associated properties</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>class ProfileManager:\n    \"\"\"Implentation for the profile manager for PyPSSE.\n    Enables attacheing profilse to all PSSE objects and associated properties\"\"\"\n\n    def __init__(self, pypsse_objects, solver, settings: SimulationSettings, logger, mode=\"r+\"):\n        self._logger = logger\n        self.solver = solver\n        self.objects = pypsse_objects\n        self.settings = settings\n\n        file_path = settings.simulation.project_path / PROFILES_FOLDER / DEFAULT_PROFILE_STORE_FILENAME\n\n        if file_path.exists():\n            self._logger.info(\"Loading existing h5 store\")\n            self.store = h5py.File(file_path, mode)\n        else:\n            self._logger.info(\"Creating new h5 store\")\n            self.store = h5py.File(file_path, \"w\")\n            for profile_group in ProfileTypes.names():\n                self.store.create_group(profile_group)\n\n    def load_data(self, file_path):\n        \"Load in external profile data\"\n        toml_dict = toml.load(file_path)\n        return toml_dict\n\n    def setup_profiles(self):\n        \"Sets up all profiles in the profile manager\"\n        mapping_path = self.settings.simulation.project_path / PROFILES_FOLDER / DEFAULT_PROFILE_MAPPING_FILENAME\n        if mapping_path.exists():\n            self.profile_mapping = self.load_data(mapping_path)\n            self.profiles = {}\n            for group, profile_map in self.profile_mapping.items():\n                if group in self.store:\n                    grp = self.store[group]\n                    for profile_name, mapping_dict in profile_map.items():\n                        if profile_name in grp:\n                            self.profiles[f\"{group}/{profile_name}\"] = Profile(\n                                grp[profile_name], self.solver, mapping_dict\n                            )\n                        else:\n                            self._logger.warning(rf\"Group {group} \\ data set {profile_name} not found in the h5 store\")\n                else:\n                    self._logger.warning(f\"Group {group} not found in the h5 store\")\n        else:\n            msg = f\"Profile_mapping.toml file does not exist in path {mapping_path}\"\n            raise Exception(msg)\n\n    def create_dataset(self, dname, p_type, data, start_time, resolution, _, info):\n        \"Craete datasets for a PyPSSE project\"\n        grp = self.store[p_type]\n        if dname not in grp:\n            sa, sa_type = self.df_to_sarray(data)\n            dset = grp.create_dataset(\n                dname, data=sa, chunks=True, compression=\"gzip\", compression_opts=4, shuffle=True, dtype=sa_type\n            )\n            self.create_metadata(dset, start_time, resolution, data, list(data.columns), info, p_type)\n        else:\n            self._logger.error(f'Data set \"{dname}\" already exists in group \"{p_type}\".')\n            msg = f'Data set \"{dname}\" already exists in group \"{p_type}\".'\n            raise Exception(msg)\n\n    def df_to_sarray(self, df):\n        \"Enables data converson\"\n\n        def make_col_type(col_type, col):\n            try:\n                if \"numpy.object_\" in str(col_type.type):\n                    maxlens = col.dropna().str.len()\n                    if maxlens.any():\n                        maxlen = maxlens.max().astype(int)\n                        col_type = (\"S%s\" % maxlen, 1)\n                    else:\n                        col_type = \"f2\"\n                return col.name, col_type\n            except:\n                raise\n\n        v = df.values\n        types = df.dtypes\n        numpy_struct_types = [make_col_type(types[col], df.loc[:, col]) for col in df.columns]\n        dtype = np.dtype(numpy_struct_types)\n        z = np.zeros(v.shape[0], dtype)\n        for i, k in enumerate(z.dtype.names):\n            # This is in case you have problems with the encoding, remove the if branch if not\n            try:\n                if dtype[i].str.startswith(\"|S\"):\n                    z[k] = df[k].str.encode(\"latin\").astype(\"S\")\n                else:\n                    z[k] = v[:, i]\n            except:\n                raise\n\n        return z, dtype\n\n    def add_profiles_from_csv(self, csv_file, name, p_type, start_time, resolution_sec=900, units=\"\", info=\"\"):\n        \"Enables profiles from existing csv files\"\n        if p_type not in PROFILE_VALIDATION:\n            msg = f\"Valid profile types are: {list(PROFILE_VALIDATION.keys())}\"\n            raise Exception(msg)\n        data = pd.read_csv(csv_file)\n        for c in data.columns:\n            if c not in PROFILE_VALIDATION[p_type]:\n                msg = f\"{c} is not valid, Valid subtypes for '{p_type}' are: {PROFILE_VALIDATION[p_type]}\"\n                raise Exception(msg)\n        self.add_profiles(name, p_type, data, start_time, resolution_sec=resolution_sec, units=units, info=info)\n\n    def add_profiles(self, name, p_type, data, start_time, resolution_sec=900, units=\"\", info=\"\"):\n        \"Adds a profile to the profile manager\"\n        if type(start_time) is not datetime.datetime:\n            msg = \"start_time should be a python datetime object\"\n            raise InvalidParameterError(msg)\n        if p_type not in ProfileTypes.names():\n            msg = f\"Valid values for p_type are {ProfileTypes.names()}\"\n            raise InvalidParameterError(msg)\n        self.create_dataset(name, p_type, data, start_time, resolution_sec, units=units, info=info)\n\n    def create_metadata(self, d_set, start_time, resolution, data, units, info, p_type):\n        \"Adds a metadata to a profile\"\n        metadata = {\n            \"sTime\": str(start_time),\n            \"eTime\": str(start_time + datetime.timedelta(seconds=resolution * len(data))),\n            \"resTime\": resolution,\n            \"npts\": len(data),\n            \"min\": data.min(),\n            \"max\": data.max(),\n            \"mean\": np.mean(data),\n            \"units\": units,\n            \"info\": info,\n            \"type\": p_type,\n        }\n        for key, value in metadata.items():\n            if isinstance(value, str):\n                value_mod = np.string_(value)\n            else:\n                value_mod = value\n            d_set.attrs[key] = value_mod\n\n    def update(self):\n        \"Returns data for the current timestep for all mapped profiles\"\n        results = {}\n        for profile_name, profile_obj in self.profiles.items():\n            result = profile_obj.update()\n            results[profile_name] = result\n        return results\n\n    def __del__(self):\n        self.store.flush()\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.add_profiles","title":"<code>add_profiles(name, p_type, data, start_time, resolution_sec=900, units='', info='')</code>","text":"<p>Adds a profile to the profile manager</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def add_profiles(self, name, p_type, data, start_time, resolution_sec=900, units=\"\", info=\"\"):\n    \"Adds a profile to the profile manager\"\n    if type(start_time) is not datetime.datetime:\n        msg = \"start_time should be a python datetime object\"\n        raise InvalidParameterError(msg)\n    if p_type not in ProfileTypes.names():\n        msg = f\"Valid values for p_type are {ProfileTypes.names()}\"\n        raise InvalidParameterError(msg)\n    self.create_dataset(name, p_type, data, start_time, resolution_sec, units=units, info=info)\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.add_profiles_from_csv","title":"<code>add_profiles_from_csv(csv_file, name, p_type, start_time, resolution_sec=900, units='', info='')</code>","text":"<p>Enables profiles from existing csv files</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def add_profiles_from_csv(self, csv_file, name, p_type, start_time, resolution_sec=900, units=\"\", info=\"\"):\n    \"Enables profiles from existing csv files\"\n    if p_type not in PROFILE_VALIDATION:\n        msg = f\"Valid profile types are: {list(PROFILE_VALIDATION.keys())}\"\n        raise Exception(msg)\n    data = pd.read_csv(csv_file)\n    for c in data.columns:\n        if c not in PROFILE_VALIDATION[p_type]:\n            msg = f\"{c} is not valid, Valid subtypes for '{p_type}' are: {PROFILE_VALIDATION[p_type]}\"\n            raise Exception(msg)\n    self.add_profiles(name, p_type, data, start_time, resolution_sec=resolution_sec, units=units, info=info)\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.create_dataset","title":"<code>create_dataset(dname, p_type, data, start_time, resolution, _, info)</code>","text":"<p>Craete datasets for a PyPSSE project</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def create_dataset(self, dname, p_type, data, start_time, resolution, _, info):\n    \"Craete datasets for a PyPSSE project\"\n    grp = self.store[p_type]\n    if dname not in grp:\n        sa, sa_type = self.df_to_sarray(data)\n        dset = grp.create_dataset(\n            dname, data=sa, chunks=True, compression=\"gzip\", compression_opts=4, shuffle=True, dtype=sa_type\n        )\n        self.create_metadata(dset, start_time, resolution, data, list(data.columns), info, p_type)\n    else:\n        self._logger.error(f'Data set \"{dname}\" already exists in group \"{p_type}\".')\n        msg = f'Data set \"{dname}\" already exists in group \"{p_type}\".'\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.create_metadata","title":"<code>create_metadata(d_set, start_time, resolution, data, units, info, p_type)</code>","text":"<p>Adds a metadata to a profile</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def create_metadata(self, d_set, start_time, resolution, data, units, info, p_type):\n    \"Adds a metadata to a profile\"\n    metadata = {\n        \"sTime\": str(start_time),\n        \"eTime\": str(start_time + datetime.timedelta(seconds=resolution * len(data))),\n        \"resTime\": resolution,\n        \"npts\": len(data),\n        \"min\": data.min(),\n        \"max\": data.max(),\n        \"mean\": np.mean(data),\n        \"units\": units,\n        \"info\": info,\n        \"type\": p_type,\n    }\n    for key, value in metadata.items():\n        if isinstance(value, str):\n            value_mod = np.string_(value)\n        else:\n            value_mod = value\n        d_set.attrs[key] = value_mod\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.df_to_sarray","title":"<code>df_to_sarray(df)</code>","text":"<p>Enables data converson</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def df_to_sarray(self, df):\n    \"Enables data converson\"\n\n    def make_col_type(col_type, col):\n        try:\n            if \"numpy.object_\" in str(col_type.type):\n                maxlens = col.dropna().str.len()\n                if maxlens.any():\n                    maxlen = maxlens.max().astype(int)\n                    col_type = (\"S%s\" % maxlen, 1)\n                else:\n                    col_type = \"f2\"\n            return col.name, col_type\n        except:\n            raise\n\n    v = df.values\n    types = df.dtypes\n    numpy_struct_types = [make_col_type(types[col], df.loc[:, col]) for col in df.columns]\n    dtype = np.dtype(numpy_struct_types)\n    z = np.zeros(v.shape[0], dtype)\n    for i, k in enumerate(z.dtype.names):\n        # This is in case you have problems with the encoding, remove the if branch if not\n        try:\n            if dtype[i].str.startswith(\"|S\"):\n                z[k] = df[k].str.encode(\"latin\").astype(\"S\")\n            else:\n                z[k] = v[:, i]\n        except:\n            raise\n\n    return z, dtype\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.load_data","title":"<code>load_data(file_path)</code>","text":"<p>Load in external profile data</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def load_data(self, file_path):\n    \"Load in external profile data\"\n    toml_dict = toml.load(file_path)\n    return toml_dict\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.setup_profiles","title":"<code>setup_profiles()</code>","text":"<p>Sets up all profiles in the profile manager</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def setup_profiles(self):\n    \"Sets up all profiles in the profile manager\"\n    mapping_path = self.settings.simulation.project_path / PROFILES_FOLDER / DEFAULT_PROFILE_MAPPING_FILENAME\n    if mapping_path.exists():\n        self.profile_mapping = self.load_data(mapping_path)\n        self.profiles = {}\n        for group, profile_map in self.profile_mapping.items():\n            if group in self.store:\n                grp = self.store[group]\n                for profile_name, mapping_dict in profile_map.items():\n                    if profile_name in grp:\n                        self.profiles[f\"{group}/{profile_name}\"] = Profile(\n                            grp[profile_name], self.solver, mapping_dict\n                        )\n                    else:\n                        self._logger.warning(rf\"Group {group} \\ data set {profile_name} not found in the h5 store\")\n            else:\n                self._logger.warning(f\"Group {group} not found in the h5 store\")\n    else:\n        msg = f\"Profile_mapping.toml file does not exist in path {mapping_path}\"\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.update","title":"<code>update()</code>","text":"<p>Returns data for the current timestep for all mapped profiles</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def update(self):\n    \"Returns data for the current timestep for all mapped profiles\"\n    results = {}\n    for profile_name, profile_obj in self.profiles.items():\n        result = profile_obj.update()\n        results[profile_name] = result\n    return results\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile.Profile","title":"<code>Profile</code>","text":"<p>Class defination fora single profile</p> Source code in <code>pypsse\\profile_manager\\profile.py</code> <pre><code>class Profile:\n    \"Class defination fora single profile\"\n\n    DEFAULT_SETTINGS = {\"multiplier\": 1, \"normalize\": False, \"interpolate\": False}\n\n    def __init__(self, profile_obj, solver, mapping_dict, buffer_size=10, neglect_year=True):\n        self.value_settings = {f\"{x['bus']}__{x['id']}\": {**self.DEFAULT_SETTINGS, **x} for x in mapping_dict}\n        self.mapping_dict = mapping_dict\n        self.buffer_size = buffer_size\n        self.buffer = np.zeros(buffer_size)\n        self.profile = profile_obj\n        self.neglect_year = neglect_year\n        self.solver = solver\n        self.attrs = self.profile.attrs\n        s = self.attrs[\"sTime\"].decode()\n        stime = s if \".\" in s else s + \".00\"\n        e = self.attrs[\"eTime\"].decode()\n        etime = e if \".\" in e else e + \".00\"\n        self.stime = datetime.datetime.strptime(stime, \"%Y-%m-%d %H:%M:%S.%f\").astimezone(None)\n        self.etime = datetime.datetime.strptime(etime, \"%Y-%m-%d %H:%M:%S.%f\").astimezone(None)\n        self.sim_res = self.solver.get_step_size_cec()\n        self.time = copy.deepcopy(self.solver.get_time())\n        self.columns = self.attrs[\"units\"]\n        self.dtype = self.attrs[\"type\"].decode()\n\n    def update(self, update_object_properties=True):\n        \"Returns value at the current timestep in the given profile\"\n        self.time = copy.deepcopy(self.solver.get_time()).astimezone(None)\n        if self.time &lt; self.stime or self.time &gt; self.etime:\n            value = np.array([0] * len(self.profile[0]))\n            value1 = np.array([0] * len(self.profile[0]))\n        else:\n            dt = (self.time - self.stime).total_seconds()\n            n = int(dt / self.attrs[\"resTime\"])\n            value = np.array(list(self.profile[n]))\n            try:\n                valuen1 = np.array(list(self.profile[n + 1]))\n            except Exception as _:\n                valuen1 = value\n\n            dt2 = (\n                self.time - (self.stime + datetime.timedelta(seconds=int(n * self.attrs[\"resTime\"])))\n            ).total_seconds()\n            value1 = value + (valuen1 - value) * dt2 / self.attrs[\"resTime\"]\n\n        if update_object_properties:\n            for obj_name in self.value_settings:\n                bus, object_id = obj_name.split(\"__\")\n                if self.value_settings[obj_name][\"interpolate\"]:\n                    value = value1\n                mult = self.value_settings[obj_name][\"multiplier\"]\n                if isinstance(mult, list):\n                    mult = np.array(mult)\n                if self.value_settings[obj_name][\"normalize\"]:\n                    value_f = value / self.attrs[\"max\"] * mult\n                else:\n                    value_f = value * mult\n                value_f = self.fill_missing_values(value_f)\n                self.solver.update_object(self.dtype, bus, object_id, value_f)\n        return value\n\n    def fill_missing_values(self, value):\n        \"Fixes issues in profile data\"\n        idx = [f\"realar{PROFILE_VALIDATION[self.dtype].index(c) + 1}\" for c in self.columns]\n        x = dict(zip(idx, list(value)))\n        return x\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile.Profile.fill_missing_values","title":"<code>fill_missing_values(value)</code>","text":"<p>Fixes issues in profile data</p> Source code in <code>pypsse\\profile_manager\\profile.py</code> <pre><code>def fill_missing_values(self, value):\n    \"Fixes issues in profile data\"\n    idx = [f\"realar{PROFILE_VALIDATION[self.dtype].index(c) + 1}\" for c in self.columns]\n    x = dict(zip(idx, list(value)))\n    return x\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile.Profile.update","title":"<code>update(update_object_properties=True)</code>","text":"<p>Returns value at the current timestep in the given profile</p> Source code in <code>pypsse\\profile_manager\\profile.py</code> <pre><code>def update(self, update_object_properties=True):\n    \"Returns value at the current timestep in the given profile\"\n    self.time = copy.deepcopy(self.solver.get_time()).astimezone(None)\n    if self.time &lt; self.stime or self.time &gt; self.etime:\n        value = np.array([0] * len(self.profile[0]))\n        value1 = np.array([0] * len(self.profile[0]))\n    else:\n        dt = (self.time - self.stime).total_seconds()\n        n = int(dt / self.attrs[\"resTime\"])\n        value = np.array(list(self.profile[n]))\n        try:\n            valuen1 = np.array(list(self.profile[n + 1]))\n        except Exception as _:\n            valuen1 = value\n\n        dt2 = (\n            self.time - (self.stime + datetime.timedelta(seconds=int(n * self.attrs[\"resTime\"])))\n        ).total_seconds()\n        value1 = value + (valuen1 - value) * dt2 / self.attrs[\"resTime\"]\n\n    if update_object_properties:\n        for obj_name in self.value_settings:\n            bus, object_id = obj_name.split(\"__\")\n            if self.value_settings[obj_name][\"interpolate\"]:\n                value = value1\n            mult = self.value_settings[obj_name][\"multiplier\"]\n            if isinstance(mult, list):\n                mult = np.array(mult)\n            if self.value_settings[obj_name][\"normalize\"]:\n                value_f = value / self.attrs[\"max\"] * mult\n            else:\n                value_f = value * mult\n            value_f = self.fill_missing_values(value_f)\n            self.solver.update_object(self.dtype, bus, object_id, value_f)\n    return value\n</code></pre>"},{"location":"code/reference/#simulation-modes","title":"Simulation modes","text":""},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic","title":"<code>Dynamic</code>","text":"<p>             Bases: <code>AbstractMode</code>, <code>DynamicUtils</code></p> <p>Class defination for dynamic simulation mode (uses dyr and raw files)</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>class Dynamic(AbstractMode, DynamicUtils):\n    \"Class defination for dynamic simulation mode (uses dyr and raw files)\"\n\n    def __init__(\n        self,\n        psse,\n        dyntools,\n        settings: SimulationSettings,\n        export_settings: ExportSettings,\n        logger,\n        subsystem_buses,\n        raw_data,\n    ):\n        super().__init__(psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data)\n        self.time = settings.simulation.start_time\n        self._StartTime = settings.simulation.start_time\n        self.incTime = settings.simulation.simulation_step_resolution\n\n        self.init({})\n\n    def init(self, bus_subsystems):\n        \"Initializes the simulation\"\n        super().init(bus_subsystems)\n        self.iter_const = 100.0\n\n        if self.settings.simulation.rwm_file:\n            self.psse.mcre([1, 0], self.rwn_file)\n\n        self.psse.fnsl([0, 0, 0, 1, 0, 0, 0, self._i])\n\n        self.load_setup_files()\n        self.convert_load()\n\n        self.psse.gnet(1, 0)\n        self.psse.fdns([1, 1, 0, 1, 1, 0, 0, 0])\n        self.psse.fnsl([1, 1, 0, 1, 1, 0, 0, 0])\n        self.psse.cong(0)\n        # Solve for dynamics\n        self.psse.ordr(0)\n        self.psse.fact()\n        self.psse.tysl(0)\n        self.psse.tysl(0)\n        # self.psse.save(self.study_case_path.split('.')[0] + \".sav\")\n        dyr_path = self.settings.simulation.dyr_file\n        assert dyr_path and dyr_path.exists\n        self.logger.debug(f\"Loading dynamic model....{dyr_path}\")\n        self.psse.dynamicsmode(1)\n        ierr = self.psse.dyre_new([1, 1, 1, 1], str(dyr_path), r\"\"\"conec\"\"\", r\"\"\"conet\"\"\", r\"\"\"compile\"\"\")\n\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            if self.settings.helics.iterative_mode:\n                sim_step = self.settings.simulation.psse_solver_timestep.total_seconds() / self.iter_const\n            else:\n                sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n        else:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n\n        ierr = self.psse.dynamics_solution_param_2(\n            [60, self._i, self._i, self._i, self._i, self._i, self._i, self._i],\n            [0.4, self._f, sim_step, self._f, self._f, self._f, self._f, self._f],\n        )\n\n        if ierr:\n            msg = f'Error loading dynamic model file \"{dyr_path}\". Error code - {ierr}'\n            raise Exception(msg)\n        else:\n            self.logger.debug(f\"Dynamic file {dyr_path} sucessfully loaded\")\n\n        self.disable_load_models_for_coupled_buses()\n\n        if self.export_settings.export_results_using_channels:\n            self.setup_channels()\n\n        self.psse.delete_all_plot_channels()\n\n        self.setup_all_channels()\n\n        # Load user defined models\n        self.load_user_defined_models()\n\n        # Load flow settings\n        self.psse.fdns([0, 0, 0, 1, 1, 0, 99, 0])\n        # initialize\n        ierr = self.psse.strt_2(\n            [\n                1,\n                self.settings.generators.missing_machine_model,\n            ],\n            str(self.settings.export.outx_file),\n        )\n        if ierr:\n            self.initialization_complete = False\n            msg = f\"Dynamic simulation failed to successfully initialize. Error code - {ierr}\"\n            raise Exception(msg)\n        else:\n            self.initialization_complete = True\n            self.logger.debug(\"Dynamic simulation initialization sucess!\")\n        # get load info for the sub system\n        self.load_info = self.get_load_indices(bus_subsystems)\n\n        self.logger.debug(\"pyPSSE initialization complete!\")\n\n        self.xTime = 0\n\n        return self.initialization_complete\n\n    def step(self, t):\n        \"Increments the simulation\"\n\n        self.time = self.time + self.incTime\n        self.xTime = 0\n        return self.psse.run(0, t, 1, 1, 1)\n\n    def get_load_indices(self, bus_subsystems):\n        \"Returns load indices\"\n\n        all_bus_ids = {}\n        for bus_subsystem_id in bus_subsystems.keys():\n            load_info = {}\n            ierr, load_data = self.psse.aloadchar(bus_subsystem_id, 1, [\"ID\", \"NAME\", \"EXNAME\"])\n\n            load_data = np.array(load_data)\n            ierr, bus_data = self.psse.aloadint(bus_subsystem_id, 1, [\"NUMBER\"])\n\n            bus_data = bus_data[0]\n            for i, bus_id in enumerate(bus_data):\n                load_info[bus_id] = {\n                    \"Load ID\": load_data[0, i],\n                    \"Bus name\": load_data[1, i],\n                    \"Bus name (ext)\": load_data[2, i],\n                }\n            all_bus_ids[bus_subsystem_id] = load_info\n        return all_bus_ids\n\n    def resolve_step(self, t):\n        \"Resolves the current time step\"\n\n        err = self.psse.run(0, t + self.xTime * self.incTime / self.iter_const, 1, 1, 1)\n        self.xTime += 1\n        return err\n\n    def get_time(self):\n        \"Returns current simulator time\"\n\n        return self.time\n\n    def get_total_seconds(self):\n        \"Returns total simulation time\"\n\n        return (self.time - self._StartTime).total_seconds()\n\n    def get_step_size_cec(self):\n        \"Returns simulation timestep resolution\"\n        return self.settings.simulation.simulation_step_resolution.total_seconds()\n\n    @converter\n    def read_subsystems(self, quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None):\n        \"Queries the result container for current results\"\n\n        if ext_string2_info is None:\n            ext_string2_info = {}\n        if mapping_dict is None:\n            mapping_dict = {}\n        results = super().read_subsystems(\n            quantities, subsystem_buses, mapping_dict=mapping_dict, ext_string2_info=ext_string2_info\n        )\n\n        poll_results = self.poll_channels()\n        results.update(poll_results)\n        for class_name, var_list in quantities.items():\n            if class_name in dyn_only_options:\n                for v in var_list:\n                    if v in DYNAMIC_ONLY_PPTY[class_name]:\n                        for func_name in dyn_only_options[class_name]:\n                            if v in dyn_only_options[class_name][func_name]:\n                                con_ind = dyn_only_options[class_name][func_name][v]\n                                for bus in subsystem_buses:\n                                    if class_name == \"Loads\":\n                                        ierr = self.psse.inilod(int(bus))\n\n                                        ierr, ld_id = self.psse.nxtlod(int(bus))\n\n                                        if ld_id is not None:\n                                            ierr, con_index = getattr(self.psse, func_name)(\n                                                int(bus), ld_id, \"CHARAC\", \"CON\"\n                                            )\n\n                                            if con_index is not None:\n                                                act_con_index = con_index + con_ind\n                                                ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n\n                                                res_base = f\"{class_name}_{v}\"\n                                                if res_base not in results:\n                                                    results[res_base] = {}\n                                                obj_name = f\"{bus}_{ld_id}\"\n                                                results[res_base][obj_name] = value\n            else:\n                self.logger.warning(\"Extend function 'read_subsystems' in the Dynamic class (Dynamic.py)\")\n        return results\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.get_load_indices","title":"<code>get_load_indices(bus_subsystems)</code>","text":"<p>Returns load indices</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def get_load_indices(self, bus_subsystems):\n    \"Returns load indices\"\n\n    all_bus_ids = {}\n    for bus_subsystem_id in bus_subsystems.keys():\n        load_info = {}\n        ierr, load_data = self.psse.aloadchar(bus_subsystem_id, 1, [\"ID\", \"NAME\", \"EXNAME\"])\n\n        load_data = np.array(load_data)\n        ierr, bus_data = self.psse.aloadint(bus_subsystem_id, 1, [\"NUMBER\"])\n\n        bus_data = bus_data[0]\n        for i, bus_id in enumerate(bus_data):\n            load_info[bus_id] = {\n                \"Load ID\": load_data[0, i],\n                \"Bus name\": load_data[1, i],\n                \"Bus name (ext)\": load_data[2, i],\n            }\n        all_bus_ids[bus_subsystem_id] = load_info\n    return all_bus_ids\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.get_step_size_cec","title":"<code>get_step_size_cec()</code>","text":"<p>Returns simulation timestep resolution</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def get_step_size_cec(self):\n    \"Returns simulation timestep resolution\"\n    return self.settings.simulation.simulation_step_resolution.total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.get_time","title":"<code>get_time()</code>","text":"<p>Returns current simulator time</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def get_time(self):\n    \"Returns current simulator time\"\n\n    return self.time\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.get_total_seconds","title":"<code>get_total_seconds()</code>","text":"<p>Returns total simulation time</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def get_total_seconds(self):\n    \"Returns total simulation time\"\n\n    return (self.time - self._StartTime).total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.init","title":"<code>init(bus_subsystems)</code>","text":"<p>Initializes the simulation</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def init(self, bus_subsystems):\n    \"Initializes the simulation\"\n    super().init(bus_subsystems)\n    self.iter_const = 100.0\n\n    if self.settings.simulation.rwm_file:\n        self.psse.mcre([1, 0], self.rwn_file)\n\n    self.psse.fnsl([0, 0, 0, 1, 0, 0, 0, self._i])\n\n    self.load_setup_files()\n    self.convert_load()\n\n    self.psse.gnet(1, 0)\n    self.psse.fdns([1, 1, 0, 1, 1, 0, 0, 0])\n    self.psse.fnsl([1, 1, 0, 1, 1, 0, 0, 0])\n    self.psse.cong(0)\n    # Solve for dynamics\n    self.psse.ordr(0)\n    self.psse.fact()\n    self.psse.tysl(0)\n    self.psse.tysl(0)\n    # self.psse.save(self.study_case_path.split('.')[0] + \".sav\")\n    dyr_path = self.settings.simulation.dyr_file\n    assert dyr_path and dyr_path.exists\n    self.logger.debug(f\"Loading dynamic model....{dyr_path}\")\n    self.psse.dynamicsmode(1)\n    ierr = self.psse.dyre_new([1, 1, 1, 1], str(dyr_path), r\"\"\"conec\"\"\", r\"\"\"conet\"\"\", r\"\"\"compile\"\"\")\n\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        if self.settings.helics.iterative_mode:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds() / self.iter_const\n        else:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n    else:\n        sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n\n    ierr = self.psse.dynamics_solution_param_2(\n        [60, self._i, self._i, self._i, self._i, self._i, self._i, self._i],\n        [0.4, self._f, sim_step, self._f, self._f, self._f, self._f, self._f],\n    )\n\n    if ierr:\n        msg = f'Error loading dynamic model file \"{dyr_path}\". Error code - {ierr}'\n        raise Exception(msg)\n    else:\n        self.logger.debug(f\"Dynamic file {dyr_path} sucessfully loaded\")\n\n    self.disable_load_models_for_coupled_buses()\n\n    if self.export_settings.export_results_using_channels:\n        self.setup_channels()\n\n    self.psse.delete_all_plot_channels()\n\n    self.setup_all_channels()\n\n    # Load user defined models\n    self.load_user_defined_models()\n\n    # Load flow settings\n    self.psse.fdns([0, 0, 0, 1, 1, 0, 99, 0])\n    # initialize\n    ierr = self.psse.strt_2(\n        [\n            1,\n            self.settings.generators.missing_machine_model,\n        ],\n        str(self.settings.export.outx_file),\n    )\n    if ierr:\n        self.initialization_complete = False\n        msg = f\"Dynamic simulation failed to successfully initialize. Error code - {ierr}\"\n        raise Exception(msg)\n    else:\n        self.initialization_complete = True\n        self.logger.debug(\"Dynamic simulation initialization sucess!\")\n    # get load info for the sub system\n    self.load_info = self.get_load_indices(bus_subsystems)\n\n    self.logger.debug(\"pyPSSE initialization complete!\")\n\n    self.xTime = 0\n\n    return self.initialization_complete\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.read_subsystems","title":"<code>read_subsystems(quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None)</code>","text":"<p>Queries the result container for current results</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>@converter\ndef read_subsystems(self, quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None):\n    \"Queries the result container for current results\"\n\n    if ext_string2_info is None:\n        ext_string2_info = {}\n    if mapping_dict is None:\n        mapping_dict = {}\n    results = super().read_subsystems(\n        quantities, subsystem_buses, mapping_dict=mapping_dict, ext_string2_info=ext_string2_info\n    )\n\n    poll_results = self.poll_channels()\n    results.update(poll_results)\n    for class_name, var_list in quantities.items():\n        if class_name in dyn_only_options:\n            for v in var_list:\n                if v in DYNAMIC_ONLY_PPTY[class_name]:\n                    for func_name in dyn_only_options[class_name]:\n                        if v in dyn_only_options[class_name][func_name]:\n                            con_ind = dyn_only_options[class_name][func_name][v]\n                            for bus in subsystem_buses:\n                                if class_name == \"Loads\":\n                                    ierr = self.psse.inilod(int(bus))\n\n                                    ierr, ld_id = self.psse.nxtlod(int(bus))\n\n                                    if ld_id is not None:\n                                        ierr, con_index = getattr(self.psse, func_name)(\n                                            int(bus), ld_id, \"CHARAC\", \"CON\"\n                                        )\n\n                                        if con_index is not None:\n                                            act_con_index = con_index + con_ind\n                                            ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n\n                                            res_base = f\"{class_name}_{v}\"\n                                            if res_base not in results:\n                                                results[res_base] = {}\n                                            obj_name = f\"{bus}_{ld_id}\"\n                                            results[res_base][obj_name] = value\n        else:\n            self.logger.warning(\"Extend function 'read_subsystems' in the Dynamic class (Dynamic.py)\")\n    return results\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.resolve_step","title":"<code>resolve_step(t)</code>","text":"<p>Resolves the current time step</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def resolve_step(self, t):\n    \"Resolves the current time step\"\n\n    err = self.psse.run(0, t + self.xTime * self.incTime / self.iter_const, 1, 1, 1)\n    self.xTime += 1\n    return err\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.step","title":"<code>step(t)</code>","text":"<p>Increments the simulation</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def step(self, t):\n    \"Increments the simulation\"\n\n    self.time = self.time + self.incTime\n    self.xTime = 0\n    return self.psse.run(0, t, 1, 1, 1)\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap","title":"<code>Snap</code>","text":"<p>             Bases: <code>AbstractMode</code>, <code>DynamicUtils</code></p> <p>Class defination for snapshat simulation mode (uses snp and sav files)</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>class Snap(AbstractMode, DynamicUtils):\n    \"Class defination for snapshat simulation mode (uses snp and sav files)\"\n\n    def __init__(\n        self,\n        psse,\n        dyntools,\n        settings: SimulationSettings,\n        export_settings: ExportSettings,\n        logger,\n        subsystem_buses,\n        raw_data,\n    ):\n        super().__init__(psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data)\n        self.time = settings.simulation.start_time\n        self._StartTime = settings.simulation.start_time\n        self.incTime = settings.simulation.simulation_step_resolution\n        self.init(subsystem_buses)\n\n    def init(self, bus_subsystems):\n        \"Initializes the simulation\"\n        super().init(bus_subsystems)\n\n        self.iter_const = 100.0\n        self.xTime = 0\n\n        ierr = self.psse.case(str(self.settings.simulation.case_study))\n\n        self.load_setup_files()\n        self.convert_load()\n\n        self.logger.info(f\"Load snap file: {self.settings.simulation.snp_file}\")\n        ierr = self.psse.rstr(str(self.settings.simulation.snp_file))\n        #\n\n        # The following logic only runs when the helics interface is enabled\n        self.disable_load_models_for_coupled_buses()\n        self.disable_generation_for_coupled_buses()\n        # self.save_model()\n        ############# ------------------------------------- ###############\n\n        ierr = self.psse.strt_2([0, 1], str(self.settings.export.outx_file))\n\n        if ierr == 1:\n            self.psse.cong(0)\n            ierr = self.psse.strt_2([0, 1], str(self.settings.export.outx_file))\n\n        elif ierr &gt; 1:\n            msg = \"Error starting simulation\"\n            raise Exception(msg)\n\n        self.load_user_defined_models()\n\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            if self.settings.helics.iterative_mode:\n                sim_step = self.settings.simulation.psse_solver_timestep.total_seconds() / self.iter_const\n            else:\n                sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n        else:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n\n        self.psse.dynamics_solution_param_2(\n            [60, self._i, self._i, self._i, self._i, self._i, self._i, self._i],\n            [0.4, self._f, sim_step, self._f, self._f, self._f, self._f, self._f],\n        )\n\n        self.psse.delete_all_plot_channels()\n\n        self.setup_all_channels()\n\n        self.logger.debug(\"pyPSSE initialization complete!\")\n        self.initialization_complete = True\n        return self.initialization_complete\n\n    def step(self, t):\n        \"Increments the simulation\"\n        self.time = self.time + self.incTime\n        self.xTime = 0\n        return self.psse.run(0, t, 1, 1, 1)\n\n    def resolve_step(self, t):\n        \"Resolves the current time step\"\n        self.xTime += 1\n        return self.psse.run(0, t + self.xTime * self.incTime / self.iter_const, 1, 1, 1)\n\n    def get_load_indices(self, bus_subsystems):\n        \"Returns load indices\"\n        all_bus_ids = {}\n        for bus_subsystem_id in bus_subsystems.keys():\n            load_info = {}\n            ierr, load_data = self.psse.aloadchar(bus_subsystem_id, 1, [\"ID\", \"NAME\", \"EXNAME\"])\n\n            load_data = np.array(load_data)\n            ierr, bus_data = self.psse.aloadint(bus_subsystem_id, 1, [\"NUMBER\"])\n\n            bus_data = bus_data[0]\n            for i, bus_id in enumerate(bus_data):\n                load_info[bus_id] = {\n                    \"Load ID\": load_data[0, i],\n                    \"Bus name\": load_data[1, i],\n                    \"Bus name (ext)\": load_data[2, i],\n                }\n            all_bus_ids[bus_subsystem_id] = load_info\n        return all_bus_ids\n\n    def get_time(self):\n        \"Returns current simulator time\"\n        return self.time\n\n    def get_total_seconds(self):\n        \"Returns total simulation time\"\n        return (self.time - self._StartTime).total_seconds()\n\n    def get_step_size_cec(self):\n        \"Returns simulation timestep resolution\"\n        return self.settings.simulation.simulation_step_resolution.total_seconds()\n\n    @converter\n    def read_subsystems(self, quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None):\n        \"Queries the result container for current results\"\n        if ext_string2_info is None:\n            ext_string2_info = {}\n        if mapping_dict is None:\n            mapping_dict = {}\n        results = super().read_subsystems(\n            quantities, subsystem_buses, mapping_dict=mapping_dict, ext_string2_info=ext_string2_info\n        )\n\n        poll_results = self.poll_channels()\n        results.update(poll_results)\n        \"\"\" Add \"\"\"\n        for class_name, var_list in quantities.items():\n            if class_name in dyn_only_options:\n                for v in var_list:\n                    if v in DYNAMIC_ONLY_PPTY[class_name]:\n                        for func_name in dyn_only_options[class_name]:\n                            if v in dyn_only_options[class_name][func_name]:\n                                con_ind = dyn_only_options[class_name][func_name][v]\n                                for bus in subsystem_buses:\n                                    if class_name == \"Loads\":\n                                        ierr = self.psse.inilod(int(bus))\n\n                                        ierr, ld_id = self.psse.nxtlod(int(bus))\n\n                                        if ld_id is not None:\n                                            ierr, con_index = getattr(self.psse, func_name)(\n                                                int(bus), ld_id, \"CHARAC\", \"CON\"\n                                            )\n\n                                            if con_index is not None:\n                                                act_con_index = con_index + con_ind\n                                                ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n\n                                                res_base = f\"{class_name}_{v}\"\n                                                if res_base not in results:\n                                                    results[res_base] = {}\n                                                obj_name = f\"{bus}_{ld_id}\"\n                                                results[res_base][obj_name] = value\n            else:\n                self.logger.warning(\"Extend function 'read_subsystems' in the Snap class (Snap.py)\")\n\n        return results\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.get_load_indices","title":"<code>get_load_indices(bus_subsystems)</code>","text":"<p>Returns load indices</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def get_load_indices(self, bus_subsystems):\n    \"Returns load indices\"\n    all_bus_ids = {}\n    for bus_subsystem_id in bus_subsystems.keys():\n        load_info = {}\n        ierr, load_data = self.psse.aloadchar(bus_subsystem_id, 1, [\"ID\", \"NAME\", \"EXNAME\"])\n\n        load_data = np.array(load_data)\n        ierr, bus_data = self.psse.aloadint(bus_subsystem_id, 1, [\"NUMBER\"])\n\n        bus_data = bus_data[0]\n        for i, bus_id in enumerate(bus_data):\n            load_info[bus_id] = {\n                \"Load ID\": load_data[0, i],\n                \"Bus name\": load_data[1, i],\n                \"Bus name (ext)\": load_data[2, i],\n            }\n        all_bus_ids[bus_subsystem_id] = load_info\n    return all_bus_ids\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.get_step_size_cec","title":"<code>get_step_size_cec()</code>","text":"<p>Returns simulation timestep resolution</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def get_step_size_cec(self):\n    \"Returns simulation timestep resolution\"\n    return self.settings.simulation.simulation_step_resolution.total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.get_time","title":"<code>get_time()</code>","text":"<p>Returns current simulator time</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def get_time(self):\n    \"Returns current simulator time\"\n    return self.time\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.get_total_seconds","title":"<code>get_total_seconds()</code>","text":"<p>Returns total simulation time</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def get_total_seconds(self):\n    \"Returns total simulation time\"\n    return (self.time - self._StartTime).total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.init","title":"<code>init(bus_subsystems)</code>","text":"<p>Initializes the simulation</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def init(self, bus_subsystems):\n    \"Initializes the simulation\"\n    super().init(bus_subsystems)\n\n    self.iter_const = 100.0\n    self.xTime = 0\n\n    ierr = self.psse.case(str(self.settings.simulation.case_study))\n\n    self.load_setup_files()\n    self.convert_load()\n\n    self.logger.info(f\"Load snap file: {self.settings.simulation.snp_file}\")\n    ierr = self.psse.rstr(str(self.settings.simulation.snp_file))\n    #\n\n    # The following logic only runs when the helics interface is enabled\n    self.disable_load_models_for_coupled_buses()\n    self.disable_generation_for_coupled_buses()\n    # self.save_model()\n    ############# ------------------------------------- ###############\n\n    ierr = self.psse.strt_2([0, 1], str(self.settings.export.outx_file))\n\n    if ierr == 1:\n        self.psse.cong(0)\n        ierr = self.psse.strt_2([0, 1], str(self.settings.export.outx_file))\n\n    elif ierr &gt; 1:\n        msg = \"Error starting simulation\"\n        raise Exception(msg)\n\n    self.load_user_defined_models()\n\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        if self.settings.helics.iterative_mode:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds() / self.iter_const\n        else:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n    else:\n        sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n\n    self.psse.dynamics_solution_param_2(\n        [60, self._i, self._i, self._i, self._i, self._i, self._i, self._i],\n        [0.4, self._f, sim_step, self._f, self._f, self._f, self._f, self._f],\n    )\n\n    self.psse.delete_all_plot_channels()\n\n    self.setup_all_channels()\n\n    self.logger.debug(\"pyPSSE initialization complete!\")\n    self.initialization_complete = True\n    return self.initialization_complete\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.read_subsystems","title":"<code>read_subsystems(quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None)</code>","text":"<p>Queries the result container for current results</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>@converter\ndef read_subsystems(self, quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None):\n    \"Queries the result container for current results\"\n    if ext_string2_info is None:\n        ext_string2_info = {}\n    if mapping_dict is None:\n        mapping_dict = {}\n    results = super().read_subsystems(\n        quantities, subsystem_buses, mapping_dict=mapping_dict, ext_string2_info=ext_string2_info\n    )\n\n    poll_results = self.poll_channels()\n    results.update(poll_results)\n    \"\"\" Add \"\"\"\n    for class_name, var_list in quantities.items():\n        if class_name in dyn_only_options:\n            for v in var_list:\n                if v in DYNAMIC_ONLY_PPTY[class_name]:\n                    for func_name in dyn_only_options[class_name]:\n                        if v in dyn_only_options[class_name][func_name]:\n                            con_ind = dyn_only_options[class_name][func_name][v]\n                            for bus in subsystem_buses:\n                                if class_name == \"Loads\":\n                                    ierr = self.psse.inilod(int(bus))\n\n                                    ierr, ld_id = self.psse.nxtlod(int(bus))\n\n                                    if ld_id is not None:\n                                        ierr, con_index = getattr(self.psse, func_name)(\n                                            int(bus), ld_id, \"CHARAC\", \"CON\"\n                                        )\n\n                                        if con_index is not None:\n                                            act_con_index = con_index + con_ind\n                                            ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n\n                                            res_base = f\"{class_name}_{v}\"\n                                            if res_base not in results:\n                                                results[res_base] = {}\n                                            obj_name = f\"{bus}_{ld_id}\"\n                                            results[res_base][obj_name] = value\n        else:\n            self.logger.warning(\"Extend function 'read_subsystems' in the Snap class (Snap.py)\")\n\n    return results\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.resolve_step","title":"<code>resolve_step(t)</code>","text":"<p>Resolves the current time step</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def resolve_step(self, t):\n    \"Resolves the current time step\"\n    self.xTime += 1\n    return self.psse.run(0, t + self.xTime * self.incTime / self.iter_const, 1, 1, 1)\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.step","title":"<code>step(t)</code>","text":"<p>Increments the simulation</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def step(self, t):\n    \"Increments the simulation\"\n    self.time = self.time + self.incTime\n    self.xTime = 0\n    return self.psse.run(0, t, 1, 1, 1)\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static","title":"<code>Static</code>","text":"<p>             Bases: <code>AbstractMode</code></p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>class Static(AbstractMode):\n    def __init__(self, psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data):\n        \"Class defination for steady-state simulation mode\"\n\n        super().__init__(psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data)\n        self.time = settings.simulation.start_time\n        self._StartTime = settings.simulation.start_time\n        self.incTime = settings.simulation.simulation_step_resolution\n\n    def init(self, bussubsystems):\n        super().init(bussubsystems)\n        self.initialization_complete = True\n\n    def step(self, _):\n        \"Increments the simulation\"\n        ierr = self.psse.fnsl()\n        # check if powerflow completed successfully\n        if ierr == 0:\n            self.time = self.time + self.incTime\n        else:\n            msg = f\"Error code {ierr} returned from PSSE while running powerflow, please follow \\\n                            PSSE doumentation to know more about error\"\n            raise Exception(msg)\n\n    def resolve_step(self):\n        \"Resolves the current time step\"\n        ierr = self.psse.fnsl()\n        if ierr &gt; 0:\n            msg = f\"Error code {ierr} returned from PSSE while running powerflow, please follow \\\n                                        PSSE doumentation to know more about error\"\n            raise Exception(msg)\n\n    def get_time(self):\n        \"Returns current simulator time\"\n        return self.time\n\n    def get_total_seconds(self):\n        \"Returns total simulation time\"\n        return (self.time - self._StartTime).total_seconds()\n\n    def get_step_size_cec(self):\n        \"Returns simulation timestep resolution\"\n        return self.settings.simulation.simulation_step_resolution.total_seconds()\n\n    def export(self):\n        \"Exports simulation results\"\n        self.logger.debug(\"Starting export process. Can take a few minutes for large files\")\n        excelpath = os.path.join(self.export_path, self.settings[\"Excel file\"])\n        achnf = self.dyntools.CHNF(self.outx_path)\n        achnf.xlsout(channels=\"\", show=False, xlsfile=excelpath, outfile=\"\", sheet=\"Sheet1\", overwritesheet=True)\n        self.logger.debug(f\"{self.settings.export.excel_file} exported\")\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.__init__","title":"<code>__init__(psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data)</code>","text":"<p>Class defination for steady-state simulation mode</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def __init__(self, psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data):\n    \"Class defination for steady-state simulation mode\"\n\n    super().__init__(psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data)\n    self.time = settings.simulation.start_time\n    self._StartTime = settings.simulation.start_time\n    self.incTime = settings.simulation.simulation_step_resolution\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.export","title":"<code>export()</code>","text":"<p>Exports simulation results</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def export(self):\n    \"Exports simulation results\"\n    self.logger.debug(\"Starting export process. Can take a few minutes for large files\")\n    excelpath = os.path.join(self.export_path, self.settings[\"Excel file\"])\n    achnf = self.dyntools.CHNF(self.outx_path)\n    achnf.xlsout(channels=\"\", show=False, xlsfile=excelpath, outfile=\"\", sheet=\"Sheet1\", overwritesheet=True)\n    self.logger.debug(f\"{self.settings.export.excel_file} exported\")\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.get_step_size_cec","title":"<code>get_step_size_cec()</code>","text":"<p>Returns simulation timestep resolution</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def get_step_size_cec(self):\n    \"Returns simulation timestep resolution\"\n    return self.settings.simulation.simulation_step_resolution.total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.get_time","title":"<code>get_time()</code>","text":"<p>Returns current simulator time</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def get_time(self):\n    \"Returns current simulator time\"\n    return self.time\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.get_total_seconds","title":"<code>get_total_seconds()</code>","text":"<p>Returns total simulation time</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def get_total_seconds(self):\n    \"Returns total simulation time\"\n    return (self.time - self._StartTime).total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.resolve_step","title":"<code>resolve_step()</code>","text":"<p>Resolves the current time step</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def resolve_step(self):\n    \"Resolves the current time step\"\n    ierr = self.psse.fnsl()\n    if ierr &gt; 0:\n        msg = f\"Error code {ierr} returned from PSSE while running powerflow, please follow \\\n                                    PSSE doumentation to know more about error\"\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.step","title":"<code>step(_)</code>","text":"<p>Increments the simulation</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def step(self, _):\n    \"Increments the simulation\"\n    ierr = self.psse.fnsl()\n    # check if powerflow completed successfully\n    if ierr == 0:\n        self.time = self.time + self.incTime\n    else:\n        msg = f\"Error code {ierr} returned from PSSE while running powerflow, please follow \\\n                        PSSE doumentation to know more about error\"\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.simulation_controller.sim_controller","title":"<code>sim_controller(psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data)</code>","text":"<p>Sets up an appropriate simualtion controller based on user input</p> Source code in <code>pypsse\\simulation_controller.py</code> <pre><code>def sim_controller(psse, dyntools, settings: SimulationSettings, export_settings, logger, subsystem_buses, raw_data):\n    \"Sets up an appropriate simualtion controller based on user input\"\n    sim_modes = {\"Dynamic\": Dynamic, \"Steady-state\": Static, \"Snap\": Snap, \"ProductionCostModel\": ProductionCostModel}\n\n    sim = sim_modes[settings.simulation.simulation_mode.value](\n        psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data\n    )\n    return sim\n</code></pre>"},{"location":"code/reference/#model-parsers","title":"Model parsers","text":""},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser","title":"<code>GICParser</code>","text":"Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>class GICParser:\n    valid_verions = [\"3\"]\n\n    def __init__(self, settings: SimulationSettings, logger=None):\n        self.logger = logger\n        self.logger.debug(\"Starting RAW parser\")\n\n        self.settings = settings\n        self.filepath = str(settings.simulation.gic_file)\n\n        self.filehandle = open(self.filepath)\n        verion = self.filehandle.readline()\n        if \"GICFILEVRSN=\" in verion:\n            verion = verion.replace(\"GICFILEVRSN=\", \"\").replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n            if verion in self.valid_verions:\n                self.logger.debug(f\"Reading GIC file verion {verion}\")\n            else:\n                vers = \",\".join(self.valid_verions)\n                self.logger.debug(\n                    f\"Version {verion} is not supported.\\nFollowing version are currently supported: {vers}\"\n                )\n        else:\n            self.logger.debug(\"GIC file structue does not seem to be valid\")\n\n        self.get_bus_coordinates()\n        self.psse_graph = nx.Graph()\n        self.create_graph()\n        pos = {}\n        for node in self.psse_graph.nodes:\n            pos[node] = [\n                float(self.psse_graph.nodes[node][\"latitude\"]),\n                float(self.psse_graph.nodes[node][\"longitude\"]),\n            ]\n        export_path = os.path.join(\n            self.settings[\"Simulation\"][\"Project Path\"],\n            \"Exports\",\n            self.settings[\"Export_settings\"][\"NetworkX graph file\"],\n        )\n        nx.write_gpickle(self.psse_graph, export_path)\n        # nx.draw(self.psse_graph ,pos)\n        # plt.show()\n\n    def create_graph(self):\n        \"Creates graph representation\"\n\n        self.parse_substation_data()\n        self.parse_transformer_data()\n        self.parse_branch_data()\n        nx.set_node_attributes(self.psse_graph, self.bus_data)\n\n    def parse_substation_data(self):\n        \"Parses substation data\"\n\n        self.logger.debug(\"Parsing substation data...\")\n        linedata = \"\"\n        while True:\n            linedata = self.filehandle.readline()\n            if \"End of Bus Substation Data\" in linedata:\n                break\n            if self.settings[\"GIC_export_settings\"][\"include substation connections\"]:\n                buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n                buses = buses.split(\" \")\n                if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                    self.psse_graph.add_edge(buses[0], buses[1])\n                else:\n                    self.logger.debug(\n                        f\"Error parsing substation data egde: {buses}.\\nOne of the bus id does not exist in bus data\"\n                    )\n\n    def parse_transformer_data(self):\n        \"Parses transformer data\"\n\n        self.logger.debug(\"Parsing transformer data...\")\n        linedata = \"\"\n        while True:\n            linedata = self.filehandle.readline()\n            if \"End of Transformer Data\" in linedata:\n                break\n\n            if self.settings[\"GIC_export_settings\"][\"include transfomer connections\"]:\n                buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n                buses = buses.split(\" \")[:3]\n                if buses[2] == \"\":\n                    if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                        self.psse_graph.add_edge(buses[0], buses[1])\n                    else:\n                        self.logger.debug(\n                            f\"Error parsing transformer data egde: {buses}.\"\n                            f\"\\nOne of the bus id does not exist in bus data\"\n                        )\n                else:\n                    if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                        self.psse_graph.add_edge(buses[0], buses[1])\n                    if buses[2] in self.bus_data and buses[1] in self.bus_data:\n                        self.psse_graph.add_edge(buses[1], buses[2])\n                    if buses[2] in self.bus_data and buses[0] in self.bus_data:\n                        self.psse_graph.add_edge(buses[2], buses[0])\n                    pass\n\n    def parse_branch_data(self):\n        \"Parses branch data\"\n\n        self.logger.debug(\"Parsing branch data...\")\n        linedata = \"\"\n        while True:\n            linedata = self.filehandle.readline()\n            if \"End of Branch Data\" in linedata:\n                break\n            if self.settings[\"GIC_export_settings\"][\"include branch connections\"]:\n                buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n                buses = buses.split(\" \")[:2]\n                if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                    self.psse_graph.add_edge(buses[0], buses[1])\n                else:\n                    self.logger.debug(\n                        f\"Error parsing branch data egde: {buses}.\\nOne of the bus id does not exist in bus data\"\n                    )\n\n    def get_bus_coordinates(self):\n        \"Parses bus coordinates\"\n\n        self.logger.debug(\"Parsing bus coordinates...\")\n        bus_data_headers = [\"subsystem/bustype?\", \"latitude\", \"longitude\", \"angle?\"]\n        self.bus_data = {}\n        linedata = \"\"\n        start = \"'\"\n        end = \"'\"\n        while True:\n            linedata = self.filehandle.readline()\n            if \"End of Substation data\" in linedata:\n                break\n\n            bus_name = linedata[linedata.find(start) + len(start) : linedata.rfind(end)]\n            data = linedata.replace(f\" {start}{bus_name}{end}\", \"\")\n            data = data.replace(\"  \", \" \")\n            data = data.replace(\"  \", \" \")\n            data = data.split(\" \")\n            bus_id = data[0]\n\n            if bus_id not in self.bus_data:\n                self.bus_data[bus_id] = {}\n\n            self.bus_data[bus_id][\"bus_name\"] = bus_name\n            for val, label in zip(data[1:], bus_data_headers):\n                self.bus_data[bus_id][label] = val\n\n        bus_data = pd.DataFrame(self.bus_data).T\n        export_path = os.path.join(\n            self.settings[\"Simulation\"][\"Project Path\"], \"Exports\", self.settings[\"Export_settings\"][\"Coordinate file\"]\n        )\n        bus_data.to_csv(export_path)\n        self.logger.debug(f\"Bus coordinate file exported to: {export_path}\")\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser.create_graph","title":"<code>create_graph()</code>","text":"<p>Creates graph representation</p> Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>def create_graph(self):\n    \"Creates graph representation\"\n\n    self.parse_substation_data()\n    self.parse_transformer_data()\n    self.parse_branch_data()\n    nx.set_node_attributes(self.psse_graph, self.bus_data)\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser.get_bus_coordinates","title":"<code>get_bus_coordinates()</code>","text":"<p>Parses bus coordinates</p> Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>def get_bus_coordinates(self):\n    \"Parses bus coordinates\"\n\n    self.logger.debug(\"Parsing bus coordinates...\")\n    bus_data_headers = [\"subsystem/bustype?\", \"latitude\", \"longitude\", \"angle?\"]\n    self.bus_data = {}\n    linedata = \"\"\n    start = \"'\"\n    end = \"'\"\n    while True:\n        linedata = self.filehandle.readline()\n        if \"End of Substation data\" in linedata:\n            break\n\n        bus_name = linedata[linedata.find(start) + len(start) : linedata.rfind(end)]\n        data = linedata.replace(f\" {start}{bus_name}{end}\", \"\")\n        data = data.replace(\"  \", \" \")\n        data = data.replace(\"  \", \" \")\n        data = data.split(\" \")\n        bus_id = data[0]\n\n        if bus_id not in self.bus_data:\n            self.bus_data[bus_id] = {}\n\n        self.bus_data[bus_id][\"bus_name\"] = bus_name\n        for val, label in zip(data[1:], bus_data_headers):\n            self.bus_data[bus_id][label] = val\n\n    bus_data = pd.DataFrame(self.bus_data).T\n    export_path = os.path.join(\n        self.settings[\"Simulation\"][\"Project Path\"], \"Exports\", self.settings[\"Export_settings\"][\"Coordinate file\"]\n    )\n    bus_data.to_csv(export_path)\n    self.logger.debug(f\"Bus coordinate file exported to: {export_path}\")\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser.parse_branch_data","title":"<code>parse_branch_data()</code>","text":"<p>Parses branch data</p> Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>def parse_branch_data(self):\n    \"Parses branch data\"\n\n    self.logger.debug(\"Parsing branch data...\")\n    linedata = \"\"\n    while True:\n        linedata = self.filehandle.readline()\n        if \"End of Branch Data\" in linedata:\n            break\n        if self.settings[\"GIC_export_settings\"][\"include branch connections\"]:\n            buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n            buses = buses.split(\" \")[:2]\n            if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                self.psse_graph.add_edge(buses[0], buses[1])\n            else:\n                self.logger.debug(\n                    f\"Error parsing branch data egde: {buses}.\\nOne of the bus id does not exist in bus data\"\n                )\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser.parse_substation_data","title":"<code>parse_substation_data()</code>","text":"<p>Parses substation data</p> Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>def parse_substation_data(self):\n    \"Parses substation data\"\n\n    self.logger.debug(\"Parsing substation data...\")\n    linedata = \"\"\n    while True:\n        linedata = self.filehandle.readline()\n        if \"End of Bus Substation Data\" in linedata:\n            break\n        if self.settings[\"GIC_export_settings\"][\"include substation connections\"]:\n            buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n            buses = buses.split(\" \")\n            if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                self.psse_graph.add_edge(buses[0], buses[1])\n            else:\n                self.logger.debug(\n                    f\"Error parsing substation data egde: {buses}.\\nOne of the bus id does not exist in bus data\"\n                )\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser.parse_transformer_data","title":"<code>parse_transformer_data()</code>","text":"<p>Parses transformer data</p> Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>def parse_transformer_data(self):\n    \"Parses transformer data\"\n\n    self.logger.debug(\"Parsing transformer data...\")\n    linedata = \"\"\n    while True:\n        linedata = self.filehandle.readline()\n        if \"End of Transformer Data\" in linedata:\n            break\n\n        if self.settings[\"GIC_export_settings\"][\"include transfomer connections\"]:\n            buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n            buses = buses.split(\" \")[:3]\n            if buses[2] == \"\":\n                if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                    self.psse_graph.add_edge(buses[0], buses[1])\n                else:\n                    self.logger.debug(\n                        f\"Error parsing transformer data egde: {buses}.\"\n                        f\"\\nOne of the bus id does not exist in bus data\"\n                    )\n            else:\n                if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                    self.psse_graph.add_edge(buses[0], buses[1])\n                if buses[2] in self.bus_data and buses[1] in self.bus_data:\n                    self.psse_graph.add_edge(buses[1], buses[2])\n                if buses[2] in self.bus_data and buses[0] in self.bus_data:\n                    self.psse_graph.add_edge(buses[2], buses[0])\n                pass\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.reader.Reader","title":"<code>Reader</code>","text":"<p>Parser for indexing all PSSE model assets</p> Source code in <code>pypsse\\parsers\\reader.py</code> <pre><code>class Reader:\n    \"Parser for indexing all PSSE model assets\"\n\n    def __init__(self, psse_instance, logger):\n        self.psse = psse_instance\n        self.logger = logger\n        self.buses = self.get_data(\"abus\", tails=[\"int\"], strings=[\"NUMBER\"], flags=[2])\n        self.loads = self.get_data(\"aload\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ID\"], flags=[4, 4])\n        self.loads = self.get_data(\"aload\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ID\"], flags=[4, 4])\n        self.fixed_stunts = self.get_data(\"afxshunt\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ID\"], flags=[4, 4])\n        self.generators = self.get_data(\"amach\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ID\"], flags=[4, 4])\n        self.branches = self.get_data(\n            \"abrn\", tails=[\"int\", \"int\", \"char\"], strings=[\"FROMNUMBER\", \"TONUMBER\", \"ID\"], flags=[2, 2, 2]\n        )\n        self.transformers = self.get_data(\n            \"atr3\", tails=[\"int\", \"int\", \"int\"], strings=[\"WIND1NUMBER\", \"WIND2NUMBER\", \"WIND3NUMBER\"], flags=[2, 2, 2]\n        )\n        self.area = self.get_data(\n            \"aarea\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"AREANAME\"], flags=[2, 2]\n        )  # Talk to Aadil\n        self.dc_branch = self.get_data(\n            \"a2trmdc\", tails=[\"int\", \"int\"], strings=[\"FROMNUMBER\", \"TONUMBER\"], flags=[2, 2]\n        )  # three terminal dc lines not implemented\n        self.multi_term_dc = self.get_data(\n            \"amultitrmdc\", tails=[\"int\", \"int\"], strings=[\"VCNPOSNUMBER\", \"VCNNEGNUMBER\"], flags=[2, 2]\n        )\n        self.switched_shunt = self.get_data(\n            \"aswsh\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"DEVICENAME\"], flags=[4, 4]\n        )\n        self.zones = self.get_data(\"azone\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ZONENAME\"], flags=[2, 2])\n        self.owners = self.get_data(\"aowner\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"OWNERNAME\"], flags=[2, 2])\n\n    def get_data(self, func_name, tails=[], strings=[], flags=[]):\n        array_list = []\n        for tail, string, flag in zip(tails, strings, flags):\n            func = getattr(self.psse, func_name.lower() + tail)\n            ierr, array_1 = func(sid=-1, flag=flag, string=string)\n            assert ierr == 0, f\"Error code {ierr}, while running function '{func_name.lower() + tail}'\"\n            array_list.append([x for array in array_1 for x in array])\n\n        self.logger.info(f\"{func_name} count - {len(array_1)}\")\n        if len(array_list) == 1:\n            return array_list[0]\n\n        return list(zip(*array_list))\n</code></pre>"},{"location":"code/reference/#command-line-interface","title":"Command line interface","text":"<p>CLI to run a PyDSS project</p> <p>CLI to create a new PyPSSE project</p> <p>CLI to run a PyDSS project</p> <p>CLI to run the PyDSS server</p>"},{"location":"code/reference/#pypsse.cli.create_profiles.create_profiles","title":"<code>create_profiles(project_path, csv_file_path, profile_folder, profile_name, profile_type, start_time, profile_res, profile_info)</code>","text":"<p>Creates profiles for PyPSSE project.</p> Source code in <code>pypsse\\cli\\create_profiles.py</code> <pre><code>@click.argument(\n    \"project-path\",\n)\n@click.option(\n    \"-f\",\n    \"--csv-file-path\",\n    help=\"Path to a csv valid file\",\n    required=False,\n    default=\"\",\n)\n@click.option(\n    \"-p\",\n    \"--profile-folder\",\n    help=\"\"\"Path to folder containing csv profiles.\n    CSV file names should follow the following format: {profile-type}_{profile-name}\"\"\",\n    required=False,\n    default=\"\",\n)\n@click.option(\n    \"-n\",\n    \"--profile-name\",\n    required=False,\n    default=DEFAULT_PROFILE_NAME,\n    show_default=True,\n    help=\"Profile name\",\n)\n@click.option(\n    \"-t\",\n    \"--profile-type\",\n    required=False,\n    default=DEFAULT_PROFILE_TYPE,\n    show_default=True,\n    help=f\"Profile type; Possible values: {list(PROFILE_VALIDATION.keys())}\",\n)\n@click.option(\n    \"-T\",\n    \"--start-time\",\n    required=False,\n    default=DEFAULT_START_TIME,\n    show_default=True,\n    help=\"Time index for the first time step, format = Y-m-d H:M:S.f\",\n)\n@click.option(\n    \"-r\",\n    \"--profile-res\",\n    required=False,\n    default=DEFAULT_PROFILE_RESOLUTION,\n    show_default=True,\n    help=\"Profile time resolution in seconds\",\n)\n@click.option(\n    \"-i\",\n    \"--profile-info\",\n    required=False,\n    default=\"\",\n    show_default=True,\n    help=\"Profile time resolution in seconds\",\n)\n@click.command()\ndef create_profiles(\n    project_path, csv_file_path, profile_folder, profile_name, profile_type, start_time, profile_res, profile_info\n):\n    \"\"\"Creates profiles for PyPSSE project.\"\"\"\n    logging.root.setLevel(\"DEBUG\")\n    settings_file = os.path.join(project_path, \"Settings\", SIMULATION_SETTINGS_FILENAME)\n    if os.path.exists(settings_file):\n        if csv_file_path and os.path.exists(csv_file_path):\n            settings = toml.load(settings_file)\n            a = ProfileManager(None, None, settings, logging)\n            a.add_profiles_from_csv(\n                csv_file=csv_file_path,\n                name=profile_name,\n                pType=profile_type,\n                startTime=dt.datetime.strptime(start_time, \"%Y-%m-%d %H:%M:%S.%f\").astimezone(None),\n                resolution_sec=profile_res,\n                info=profile_info,\n            )\n            logging.info(f\"Profile '{profile_name}' added to group '{profile_type}'\")\n        elif os.path.exists(profile_folder):\n            settings = toml.load(settings_file)\n            a = ProfileManager(None, None, settings, logging)\n            for _, _, files in os.walk(profile_folder):\n                for file in files:\n                    if file.endswith(\".csv\"):\n                        filename = file.replace(\".csv\", \"\")\n                        if \"__\" in filename:\n                            dtype, p_name = filename.split(\"__\")\n                            a.add_profiles_from_csv(\n                                csv_file=os.path.join(profile_folder, file),\n                                name=p_name,\n                                pType=dtype,\n                                startTime=dt.datetime.strptime(start_time, \"%Y-%m-%d %H:%M:%S.%f\").astimezone(None),\n                                resolution_sec=profile_res,\n                                info=profile_info,\n                            )\n                            msg = f\"Profile '{p_name}'' added to group '{dtype}'\"\n                            logging.info(msg)\n        else:\n            msg = \"Value for either -f or -p flag has to be passed\"\n            raise Exception(msg)\n    else:\n        msg = f\"{project_path} is not a valid pypsse project\"\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.cli.create_project.create_project","title":"<code>create_project(path=None, project=None, psse_project_folder=None, simulation_file=None, export_settings_file=None, profile_store=None, profile_mapping=None, overwrite=None, autofill=None)</code>","text":"<p>Create a new PyPSSE project.</p> Source code in <code>pypsse\\cli\\create_project.py</code> <pre><code>@click.argument(\n    \"path\",\n)\n@click.option(\n    \"-p\",\n    \"--project\",\n    required=True,\n    help=\"project name\",\n)\n@click.option(\n    \"-F\",\n    \"--psse-project-folder\",\n    default=None,\n    required=False,\n    type=click.Path(exists=True),\n    help=\"PSS/E project folder path\",\n)\n@click.option(\n    \"-f\",\n    \"--simulation-file\",\n    required=False,\n    show_default=True,\n    default=\"\",\n    help=\"Simulation settings toml file path\",\n)\n@click.option(\n    \"-e\",\n    \"--export-settings-file\",\n    default=\"\",\n    help=\"Export settings toml file path\",\n)\n@click.option(\n    \"-s\",\n    \"--profile-store\",\n    default=\"\",\n    help=\"Path to a valid Profiles.hdf5 file (Contains profiles for time series simulations)\",\n)\n@click.option(\n    \"-m\",\n    \"--profile-mapping\",\n    default=\"\",\n    help=\"Path to a valid Profile_mapping.toml file (used to map profile to PSSE elements)\",\n)\n@click.option(\n    \"-a\",\n    \"--autofill\",\n    help=\"Attempt to auto fill settings. (Verify manually settings file is correct)\",\n    is_flag=True,\n    default=True,\n    show_default=True,\n)\n@click.option(\n    \"-o\",\n    \"--overwrite\",\n    help=\"Overwrite project is it already exists\",\n    is_flag=True,\n    default=True,\n    show_default=True,\n)\n@click.command()\ndef create_project(\n    path=None,\n    project=None,\n    psse_project_folder=None,\n    simulation_file=None,\n    export_settings_file=None,\n    profile_store=None,\n    profile_mapping=None,\n    overwrite=None,\n    autofill=None,\n):\n    \"\"\"Create a new PyPSSE project.\"\"\"\n    if os.path.exists(path):\n        s_settings = toml.load(simulation_file) if simulation_file else {}\n        e_settings = toml.load(export_settings_file) if export_settings_file else {}\n        # TODO: Validate settings\n        a = Project()\n        a.create(\n            path,\n            project,\n            psse_project_folder,\n            s_settings,\n            e_settings,\n            profile_store,\n            profile_mapping,\n            overwrite,\n            autofill,\n        )\n</code></pre>"},{"location":"code/reference/#pypsse.cli.run.run","title":"<code>run(project_path, simulations_file=None)</code>","text":"<p>Runs a valid PyPSSE simulation.</p> Source code in <code>pypsse\\cli\\run.py</code> <pre><code>@click.argument(\n    \"project-path\",\n)\n@click.option(\n    \"-s\",\n    \"--simulations-file\",\n    required=False,\n    default=SIMULATION_SETTINGS_FILENAME,\n    show_default=True,\n    help=\"scenario toml file to run (over rides default)\",\n)\n@click.command()\ndef run(project_path, simulations_file=None):\n    \"\"\"Runs a valid PyPSSE simulation.\"\"\"\n    path = os.path.join(project_path, simulations_file)\n    if os.path.exists(path):\n        x = Simulator(path)\n        # x.init()\n        x.run()\n    else:\n        msg = f\"'{path}' is not a valid path.\"\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.cli.serve.serve","title":"<code>serve(host_ip='127.0.0.1', port=9090)</code>","text":"<p>Run a PyPSSE RESTful API server.</p> Source code in <code>pypsse\\cli\\serve.py</code> <pre><code>@click.option(\n    \"-p\",\n    \"--port\",\n    default=9090,\n    show_default=True,\n    help=\"Socket port for the server\",\n)\n@click.option(\n    \"-h\",\n    \"--host-ip\",\n    default=\"127.0.0.1\",\n    show_default=True,\n    help=\"IP for the server\",\n)\n@click.command()\ndef serve(host_ip=\"127.0.0.1\", port=9090):\n    \"\"\"Run a PyPSSE RESTful API server.\"\"\"\n    timestamp_format = \"%(asctime)s - %(levelname)s - %(message)s\"\n    logging.basicConfig(level=logging.INFO, format=timestamp_format)\n    run_server(host_ip, port)\n</code></pre>"},{"location":"code/reference/#data-interfaces","title":"Data interfaces","text":""},{"location":"code/reference/#pypsse.data_writers.data_writer.DataWriter","title":"<code>DataWriter</code>","text":"<p>Data writer class defination</p> Source code in <code>pypsse\\data_writers\\data_writer.py</code> <pre><code>class DataWriter:\n    \"Data writer class defination\"\n    modes = {\n        \"h5\": HDF5Writer,\n        \"csv\": CSVWriter,\n        \"json\": JSONWriter,\n        \"none\": DummyWriter,\n    }\n\n    def __init__(self, log_dir, formatnm, column_length):\n        \"Sets up a data writer as per user input\"\n        self.writer = self.modes[formatnm](log_dir, column_length)\n\n    def write(self, currenttime, powerflow_output, convergence):\n        \"Enables incremental write to the data writer object\"\n        self.writer.write(currenttime, powerflow_output, convergence)\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.data_writer.DataWriter.__init__","title":"<code>__init__(log_dir, formatnm, column_length)</code>","text":"<p>Sets up a data writer as per user input</p> Source code in <code>pypsse\\data_writers\\data_writer.py</code> <pre><code>def __init__(self, log_dir, formatnm, column_length):\n    \"Sets up a data writer as per user input\"\n    self.writer = self.modes[formatnm](log_dir, column_length)\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.data_writer.DataWriter.write","title":"<code>write(currenttime, powerflow_output, convergence)</code>","text":"<p>Enables incremental write to the data writer object</p> Source code in <code>pypsse\\data_writers\\data_writer.py</code> <pre><code>def write(self, currenttime, powerflow_output, convergence):\n    \"Enables incremental write to the data writer object\"\n    self.writer.write(currenttime, powerflow_output, convergence)\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.csv.CSVWriter","title":"<code>CSVWriter</code>","text":"<p>Class that handles writing simulation results to arrow files.</p> Source code in <code>pypsse\\data_writers\\csv.py</code> <pre><code>class CSVWriter:\n    \"\"\"Class that handles writing simulation results to arrow\n    files.\n    \"\"\"\n\n    def __init__(self, log_dir, column_length):\n        \"\"\"Constructor\"\"\"\n        self.column_length = column_length\n        self.log_dir = log_dir\n        self.timestamps = []\n        self.chunkRows = 1\n        self.dfs = {}\n        self.step = 0\n        # Create arrow writer for each object type\n\n    def write(self, currenttime, powerflow_output):\n        \"\"\"\n        Writes the status of BES assets at a particular timestep to an\n            arrow file.\n\n        :param fed_name: name of BES federate\n        :param log_fields: list of objects to log\n        :param currenttime: simulation timestep\n        :param powerflow_output: Powerflow solver timestep output as a dict\n        \"\"\"\n        # Iterate through each object type\n        self.timestamps.append(currenttime)\n        for obj_type in powerflow_output:\n            data = powerflow_output[obj_type]\n            if obj_type not in self.dfs:\n                self.dfs[obj_type] = [data]\n            else:\n                if self.dfs[obj_type] is None:\n                    self.dfs[obj_type] = [data]\n                else:\n                    self.dfs[obj_type].append(data)\n\n            if self.step % self.chunkRows == self.chunkRows - 1:\n                fpath = os.path.join(self.log_dir, f\"{obj_type}.csv\")\n                self.dfs[obj_type] = pd.DataFrame(self.dfs[obj_type], index=self.timestamps)\n                self.dfs[obj_type].to_csv(fpath, mode=\"a\")\n\n                self.dfs[obj_type] = None\n            self.Timestamp[self.step - 1] = np.string_(str(currenttime))\n        self.step += 1\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.csv.CSVWriter.__init__","title":"<code>__init__(log_dir, column_length)</code>","text":"<p>Constructor</p> Source code in <code>pypsse\\data_writers\\csv.py</code> <pre><code>def __init__(self, log_dir, column_length):\n    \"\"\"Constructor\"\"\"\n    self.column_length = column_length\n    self.log_dir = log_dir\n    self.timestamps = []\n    self.chunkRows = 1\n    self.dfs = {}\n    self.step = 0\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.csv.CSVWriter.write","title":"<code>write(currenttime, powerflow_output)</code>","text":"<p>Writes the status of BES assets at a particular timestep to an     arrow file.</p> <p>:param fed_name: name of BES federate :param log_fields: list of objects to log :param currenttime: simulation timestep :param powerflow_output: Powerflow solver timestep output as a dict</p> Source code in <code>pypsse\\data_writers\\csv.py</code> <pre><code>def write(self, currenttime, powerflow_output):\n    \"\"\"\n    Writes the status of BES assets at a particular timestep to an\n        arrow file.\n\n    :param fed_name: name of BES federate\n    :param log_fields: list of objects to log\n    :param currenttime: simulation timestep\n    :param powerflow_output: Powerflow solver timestep output as a dict\n    \"\"\"\n    # Iterate through each object type\n    self.timestamps.append(currenttime)\n    for obj_type in powerflow_output:\n        data = powerflow_output[obj_type]\n        if obj_type not in self.dfs:\n            self.dfs[obj_type] = [data]\n        else:\n            if self.dfs[obj_type] is None:\n                self.dfs[obj_type] = [data]\n            else:\n                self.dfs[obj_type].append(data)\n\n        if self.step % self.chunkRows == self.chunkRows - 1:\n            fpath = os.path.join(self.log_dir, f\"{obj_type}.csv\")\n            self.dfs[obj_type] = pd.DataFrame(self.dfs[obj_type], index=self.timestamps)\n            self.dfs[obj_type].to_csv(fpath, mode=\"a\")\n\n            self.dfs[obj_type] = None\n        self.Timestamp[self.step - 1] = np.string_(str(currenttime))\n    self.step += 1\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.json.JSONWriter","title":"<code>JSONWriter</code>","text":"<p>Class that handles writing simulation results to arrow files.</p> Source code in <code>pypsse\\data_writers\\json.py</code> <pre><code>class JSONWriter:\n    \"\"\"Class that handles writing simulation results to arrow\n    files.\n    \"\"\"\n\n    def __init__(self, log_dir, column_length):\n        \"\"\"Constructor\"\"\"\n        self.column_length = column_length\n        self.log_dir = log_dir\n        self.chunk_rows = 1\n        self.handles = {}\n        self.dfs = {}\n        self.step = 0\n        # Create arrow writer for each object type\n\n    def write(self, currenttime, powerflow_output):\n        \"\"\"\n        Writes the status of BES assets at a particular timestep to an\n            arrow file.\n\n        :param fed_name: name of BES federate\n        :param log_fields: list of objects to log\n        :param currenttime: simulation timestep\n        :param powerflow_output: Powerflow solver timestep output as a dict\n        \"\"\"\n        # Iterate through each object type\n\n        for obj_type in powerflow_output:\n            fpath = os.path.join(self.log_dir, f\"{obj_type}.json\")\n            if self.step == 0:\n                f = open(fpath, \"w\")\n                f.close()\n                self.handles[obj_type] = open(fpath, \"a\")\n            data = powerflow_output[obj_type]\n            if obj_type not in self.dfs:\n                self.dfs[obj_type] = {str(currenttime): data}\n            else:\n                if self.dfs[obj_type] is None:\n                    self.dfs[obj_type] = {str(currenttime): data}\n                else:\n                    self.dfs[obj_type][currenttime] = data\n            if self.step % self.chunk_rows == self.chunk_rows - 1:\n                try:\n                    json.dump(self.dfs[obj_type], self.handles[obj_type], indent=4)\n                    self.handles[obj_type].flush()\n                    self.dfs[obj_type] = None\n                except Exception as E:\n                    logger.warning(f\"Unable to write property {obj_type} to file: {E!s}\")\n\n        self.step += 1\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.json.JSONWriter.__init__","title":"<code>__init__(log_dir, column_length)</code>","text":"<p>Constructor</p> Source code in <code>pypsse\\data_writers\\json.py</code> <pre><code>def __init__(self, log_dir, column_length):\n    \"\"\"Constructor\"\"\"\n    self.column_length = column_length\n    self.log_dir = log_dir\n    self.chunk_rows = 1\n    self.handles = {}\n    self.dfs = {}\n    self.step = 0\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.json.JSONWriter.write","title":"<code>write(currenttime, powerflow_output)</code>","text":"<p>Writes the status of BES assets at a particular timestep to an     arrow file.</p> <p>:param fed_name: name of BES federate :param log_fields: list of objects to log :param currenttime: simulation timestep :param powerflow_output: Powerflow solver timestep output as a dict</p> Source code in <code>pypsse\\data_writers\\json.py</code> <pre><code>def write(self, currenttime, powerflow_output):\n    \"\"\"\n    Writes the status of BES assets at a particular timestep to an\n        arrow file.\n\n    :param fed_name: name of BES federate\n    :param log_fields: list of objects to log\n    :param currenttime: simulation timestep\n    :param powerflow_output: Powerflow solver timestep output as a dict\n    \"\"\"\n    # Iterate through each object type\n\n    for obj_type in powerflow_output:\n        fpath = os.path.join(self.log_dir, f\"{obj_type}.json\")\n        if self.step == 0:\n            f = open(fpath, \"w\")\n            f.close()\n            self.handles[obj_type] = open(fpath, \"a\")\n        data = powerflow_output[obj_type]\n        if obj_type not in self.dfs:\n            self.dfs[obj_type] = {str(currenttime): data}\n        else:\n            if self.dfs[obj_type] is None:\n                self.dfs[obj_type] = {str(currenttime): data}\n            else:\n                self.dfs[obj_type][currenttime] = data\n        if self.step % self.chunk_rows == self.chunk_rows - 1:\n            try:\n                json.dump(self.dfs[obj_type], self.handles[obj_type], indent=4)\n                self.handles[obj_type].flush()\n                self.dfs[obj_type] = None\n            except Exception as E:\n                logger.warning(f\"Unable to write property {obj_type} to file: {E!s}\")\n\n    self.step += 1\n</code></pre>"},{"location":"code/reference/#utility-functions","title":"Utility functions","text":""},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils","title":"<code>DynamicUtils</code>","text":"<p>Utility functions for dynamic simulations</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>class DynamicUtils:\n    \"Utility functions for dynamic simulations\"\n\n    dynamic_params: ClassVar[List[str]] = [\"FmA\", \"FmB\", \"FmC\", \"FmD\", \"Fel\"]\n\n    def disable_generation_for_coupled_buses(self):\n        \"Disables generation of coupled buses (co-simulation mode only)\"\n        if (\n            self.settings.helics\n            and self.settings.helics.cosimulation_mode\n            and self.settings.helics.disable_generation_on_coupled_buses\n        ):\n            sub_data = pd.read_csv(self.settings.simulation.subscriptions_file)\n            sub_data = sub_data[sub_data[\"element_type\"] == \"Load\"]\n            generators = {}\n            generator_list = {}\n\n            for gen_bus, gen_id in self.raw_data.generators:\n                if gen_bus not in generator_list:\n                    generator_list[gen_bus] = []\n                generator_list[gen_bus].append(gen_id)\n\n            for _, row in sub_data.iterrows():\n                bus = row[\"bus\"]\n                generators[bus] = generator_list[bus]\n\n            for bus_id, machines in generators.items():\n                for machine in machines:\n                    intgar = [0, self._i, self._i, self._i, self._i, self._i]\n                    realar = [\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                    ]\n                    self.psse.machine_chng_2(bus_id, machine, intgar, realar)\n                    self.logger.info(f\"Machine disabled: {bus_id}_{machine}\")\n\n    def disable_load_models_for_coupled_buses(self):\n        \"Disables loads of coupled buses (co-simulation mode only)\"\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            sub_data = pd.read_csv(self.settings.simulation.subscriptions_file)\n            sub_data = sub_data[sub_data[\"element_type\"] == \"Load\"]\n\n            self.psse_dict = {}\n            for _, row in sub_data.iterrows():\n                bus = row[\"bus\"]\n                load = row[\"element_id\"]\n                ierr = self.psse.ldmod_status(0, int(bus), str(load), 1, 0)\n                assert ierr == 0, f\"error={ierr}\"\n                self.logger.error(f\"Dynamic model for load {load} connected to bus {bus} has been disabled\")\n\n    def break_loads(self, loads=None, components_to_replace: List[str] = []):\n        \"Implements the load split logic\"\n        components_to_stay = [x for x in self.dynamic_params if x not in components_to_replace]\n        if loads is None:\n            loads = self._get_coupled_loads()\n        loads = self._get_load_static_data(loads)\n        loads = self._get_load_dynamic_data(loads)\n        loads = self._replicate_coupled_load(loads, components_to_replace)\n        self._update_dynamic_parameters(loads, components_to_stay, components_to_replace)\n\n    def _update_dynamic_parameters(self, loads, components_to_stay, components_to_replace):\n        \"Updates dynamic parameters of composite load models\"\n        new_percentages = {}\n        for load in loads:\n            count = 0\n            for comp in components_to_stay:\n                count += load[comp]\n            for comp in components_to_stay:\n                new_percentages[comp] = load[comp] / count\n            for comp in components_to_replace:\n                new_percentages[comp] = 0.0\n\n            settings = self._get_load_dynamic_properties(load)\n            #\n            for k, v in new_percentages.items():\n                idx = dyn_only_options[\"Loads\"][\"lmodind\"][k]\n                settings[idx] = v\n                # self.psse.change_ldmod_con(load['bus'], 'XX' ,r\"\"\"CMLDBLU2\"\"\" ,idx ,v)\n            values = list(settings.values())\n            self.psse.add_load_model(load[\"bus\"], \"XX\", 0, 1, r\"\"\"CMLDBLU2\"\"\", 2, [0, 0], [\"\", \"\"], 133, values)\n            self.logger.info(f\"Dynamic model parameters for load {load['id']} at bus 'XX' changed.\")\n\n    def _get_load_dynamic_properties(self, load):\n        \"Returns dynamic parameters of composite load models\"\n        settings = {}\n        for i in range(133):\n            ierr, con_index = self.psse.lmodind(load[\"bus\"], str(load[\"id\"]), \"CHARAC\", \"CON\")\n            if con_index is not None:\n                act_con_index = con_index + i\n                ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n                assert ierr == 0, f\"error={ierr}\"\n                settings[i] = value\n        return settings\n\n    def _replicate_coupled_load(self, loads, components_to_replace):\n        \"Create a replica of composite load model\"\n        for load in loads:\n            dynamic_percentage = load[\"FmA\"] + load[\"FmB\"] + load[\"FmC\"] + load[\"FmD\"] + load[\"Fel\"]\n            static_percentage = 1.0 - dynamic_percentage\n            for comp in components_to_replace:\n                static_percentage += load[comp]\n            remaining_load = 1 - static_percentage\n            total_load = load[\"MVA\"]\n            total_distribution_load = total_load * static_percentage\n            total_transmission_load = total_load * remaining_load\n            # ceate new load\n            self.psse.load_data_5(\n                load[\"bus\"],\n                \"XX\",\n                realar=[total_transmission_load.real, total_transmission_load.imag, 0.0, 0.0, 0.0, 0.0],\n                lodtyp=\"replica\",\n            )\n            # ierr, cmpval = self.psse.loddt2(load[\"bus\"], \"XX\" ,\"MVA\" , \"ACT\")\n            # modify old load\n            self.psse.load_data_5(\n                load[\"bus\"],\n                str(load[\"id\"]),\n                realar=[total_distribution_load.real, total_distribution_load.imag, 0.0, 0.0, 0.0, 0.0],\n                lodtyp=\"original\",\n            )\n            # ierr, cmpval = self.psse.loddt2(load[\"bus\"], load[\"id\"] ,\"MVA\" , \"ACT\")\n            self.logger.info(f\"Original load {load['id']} @ bus {load['bus']}: {total_load}\")\n            self.logger.info(f\"New load 'XX' @ bus {load['bus']} created successfully: {total_transmission_load}\")\n            self.logger.info(f\"Load {load['id']} @ bus {load['bus']} updated : {total_distribution_load}\")\n            load[\"distribution\"] = total_distribution_load\n            load[\"transmission\"] = total_transmission_load\n        return loads\n\n    def _get_coupled_loads(self):\n        \"Returns a list of all coupled loads ina give simualtion\"\n\n        sub_data = pd.read_csv(\n            os.path.join(\n                self.settings[\"Simulation\"][\"Project Path\"], \"Settings\", self.settings[\"HELICS\"][\"Subscriptions file\"]\n            )\n        )\n        load = []\n        for _, row in sub_data.iterrows():\n            if row[\"element_type\"] == \"Load\":\n                load.append(\n                    {\n                        \"type\": row[\"element_type\"],\n                        \"id\": row[\"element_id\"],\n                        \"bus\": row[\"bus\"],\n                    }\n                )\n        return load\n\n    def _get_load_static_data(self, loads):\n        \"Returns static data for load models\"\n\n        values = [\"MVA\", \"IL\", \"YL\", \"TOTAL\"]\n        for load in loads:\n            for v in values:\n                ierr, cmpval = self.psse.loddt2(load[\"bus\"], str(load[\"id\"]), v, \"ACT\")\n                load[v] = cmpval\n        return loads\n\n    def _get_load_dynamic_data(self, loads):\n        \"Returns dynamic data for load models\"\n        values = dyn_only_options[\"Loads\"][\"lmodind\"]\n        for load in loads:\n            for v, con_ind in values.items():\n                ierr = self.psse.inilod(load[\"bus\"])\n                assert ierr == 0, f\"error={ierr}\"\n                ierr, ld_id = self.psse.nxtlod(load[\"bus\"])\n                assert ierr == 0, f\"error={ierr}\"\n                if ld_id is not None:\n                    ierr, con_index = self.psse.lmodind(load[\"bus\"], ld_id, \"CHARAC\", \"CON\")\n                    assert ierr == 0, f\"error={ierr}\"\n                    if con_index is not None:\n                        act_con_index = con_index + con_ind\n                        ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n                        assert ierr == 0, f\"error={ierr}\"\n                        load[v] = value\n        return loads\n\n    def setup_machine_channels(self, machines, properties):\n        \"Sets up machine channels\"\n        for _, qty in enumerate(properties):\n            if qty not in self.channel_map:\n                nqty = f\"MACHINE_{qty}\"\n                self.channel_map[nqty] = {}\n            for mch, b in machines:\n                if qty in MACHINE_CHANNELS:\n                    self.channel_map[nqty][f\"{b}_{mch}\"] = [self.chnl_idx]\n                    chnl_id = MACHINE_CHANNELS[qty]\n                    self.logger.info(f\"{qty} for machine {b}_{mch} added to channel {self.chnl_idx}\")\n                    self.psse.machine_array_channel([self.chnl_idx, chnl_id, int(b)], mch, \"\")\n                    self.chnl_idx += 1\n\n    def setup_load_channels(self, loads):\n        \"Sets up load channels\"\n\n        if \"LOAD_P\" not in self.channel_map:\n            self.channel_map[\"LOAD_P\"] = {}\n            self.channel_map[\"LOAD_Q\"] = {}\n\n        for ld, b in loads:\n            self.channel_map[\"LOAD_P\"][f\"{b}_{ld}\"] = [self.chnl_idx]\n            self.channel_map[\"LOAD_Q\"][f\"{b}_{ld}\"] = [self.chnl_idx + 1]\n            self.psse.load_array_channel([self.chnl_idx, 1, int(b)], ld, \"\")\n            self.psse.load_array_channel([self.chnl_idx + 1, 2, int(b)], ld, \"\")\n            self.logger.info(f\"P and Q for load {b}_{ld} added to channel {self.chnl_idx} and {self.chnl_idx + 1}\")\n            self.chnl_idx += 2\n\n    def setup_bus_channels(self, buses, properties):\n        \"Sets up bus channels\"\n\n        for _, qty in enumerate(properties):\n            if qty not in self.channel_map:\n                self.channel_map[qty] = {}\n            for _, b in enumerate(buses):\n                if qty == \"frequency\":\n                    self.channel_map[qty][b] = [self.chnl_idx]\n                    self.psse.bus_frequency_channel([self.chnl_idx, int(b)], \"\")\n                    self.logger.info(f\"Frequency for bus {b} added to channel { self.chnl_idx}\")\n                    self.chnl_idx += 1\n                elif qty == \"voltage_and_angle\":\n                    self.channel_map[qty][b] = [self.chnl_idx, self.chnl_idx + 1]\n                    self.psse.voltage_and_angle_channel([self.chnl_idx, -1, -1, int(b)], \"\")\n                    self.logger.info(\n                        f\"Voltage and angle for bus {b} added to channel {self.chnl_idx} and {self.chnl_idx+1}\"\n                    )\n                    self.chnl_idx += 2\n\n    def poll_channels(self):\n        \"Polls all channels adde during the setup process\"\n\n        results = {}\n        for ppty, b_dict in self.channel_map.items():\n            ppty_new = ppty.split(\"_and_\")\n            for b, indices in b_dict.items():\n                for n, idx in zip(ppty_new, indices):\n                    if \"_\" not in n:\n                        n_name = f\"BUS_{n}\"\n                    else:\n                        n_name = n\n                    if n_name not in results:\n                        results[n_name] = {}\n                    ierr, value = self.psse.chnval(idx)\n                    assert ierr == 0, f\"error={ierr}\"\n                    if value is None:\n                        value = -1\n                    results[n_name][b] = value\n        return results\n\n    def setup_all_channels(self):\n        \"Sets up all user-defined channels for a project\"\n\n        self.channel_map = {}\n        self.chnl_idx = 1\n        if not self.export_settings.channel_setup:\n            return\n\n        for channel in self.export_settings.channel_setup:\n            method_type = channel.asset_type\n            if method_type == \"buses\":\n                self.setup_bus_channels(channel.asset_list, channel.asset_properties)\n            elif method_type == \"loads\":\n                load_list = [[x, int(y)] for x, y in channel.asset_list]\n                self.setup_load_channels(load_list)\n            elif method_type == \"machines\":\n                machine_list = [[x, int(y)] for x, y in channel.asset_list]\n                self.setup_machine_channels(machine_list, channel.asset_properties)\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.break_loads","title":"<code>break_loads(loads=None, components_to_replace=[])</code>","text":"<p>Implements the load split logic</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def break_loads(self, loads=None, components_to_replace: List[str] = []):\n    \"Implements the load split logic\"\n    components_to_stay = [x for x in self.dynamic_params if x not in components_to_replace]\n    if loads is None:\n        loads = self._get_coupled_loads()\n    loads = self._get_load_static_data(loads)\n    loads = self._get_load_dynamic_data(loads)\n    loads = self._replicate_coupled_load(loads, components_to_replace)\n    self._update_dynamic_parameters(loads, components_to_stay, components_to_replace)\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.disable_generation_for_coupled_buses","title":"<code>disable_generation_for_coupled_buses()</code>","text":"<p>Disables generation of coupled buses (co-simulation mode only)</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def disable_generation_for_coupled_buses(self):\n    \"Disables generation of coupled buses (co-simulation mode only)\"\n    if (\n        self.settings.helics\n        and self.settings.helics.cosimulation_mode\n        and self.settings.helics.disable_generation_on_coupled_buses\n    ):\n        sub_data = pd.read_csv(self.settings.simulation.subscriptions_file)\n        sub_data = sub_data[sub_data[\"element_type\"] == \"Load\"]\n        generators = {}\n        generator_list = {}\n\n        for gen_bus, gen_id in self.raw_data.generators:\n            if gen_bus not in generator_list:\n                generator_list[gen_bus] = []\n            generator_list[gen_bus].append(gen_id)\n\n        for _, row in sub_data.iterrows():\n            bus = row[\"bus\"]\n            generators[bus] = generator_list[bus]\n\n        for bus_id, machines in generators.items():\n            for machine in machines:\n                intgar = [0, self._i, self._i, self._i, self._i, self._i]\n                realar = [\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                ]\n                self.psse.machine_chng_2(bus_id, machine, intgar, realar)\n                self.logger.info(f\"Machine disabled: {bus_id}_{machine}\")\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.disable_load_models_for_coupled_buses","title":"<code>disable_load_models_for_coupled_buses()</code>","text":"<p>Disables loads of coupled buses (co-simulation mode only)</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def disable_load_models_for_coupled_buses(self):\n    \"Disables loads of coupled buses (co-simulation mode only)\"\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        sub_data = pd.read_csv(self.settings.simulation.subscriptions_file)\n        sub_data = sub_data[sub_data[\"element_type\"] == \"Load\"]\n\n        self.psse_dict = {}\n        for _, row in sub_data.iterrows():\n            bus = row[\"bus\"]\n            load = row[\"element_id\"]\n            ierr = self.psse.ldmod_status(0, int(bus), str(load), 1, 0)\n            assert ierr == 0, f\"error={ierr}\"\n            self.logger.error(f\"Dynamic model for load {load} connected to bus {bus} has been disabled\")\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.poll_channels","title":"<code>poll_channels()</code>","text":"<p>Polls all channels adde during the setup process</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def poll_channels(self):\n    \"Polls all channels adde during the setup process\"\n\n    results = {}\n    for ppty, b_dict in self.channel_map.items():\n        ppty_new = ppty.split(\"_and_\")\n        for b, indices in b_dict.items():\n            for n, idx in zip(ppty_new, indices):\n                if \"_\" not in n:\n                    n_name = f\"BUS_{n}\"\n                else:\n                    n_name = n\n                if n_name not in results:\n                    results[n_name] = {}\n                ierr, value = self.psse.chnval(idx)\n                assert ierr == 0, f\"error={ierr}\"\n                if value is None:\n                    value = -1\n                results[n_name][b] = value\n    return results\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.setup_all_channels","title":"<code>setup_all_channels()</code>","text":"<p>Sets up all user-defined channels for a project</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def setup_all_channels(self):\n    \"Sets up all user-defined channels for a project\"\n\n    self.channel_map = {}\n    self.chnl_idx = 1\n    if not self.export_settings.channel_setup:\n        return\n\n    for channel in self.export_settings.channel_setup:\n        method_type = channel.asset_type\n        if method_type == \"buses\":\n            self.setup_bus_channels(channel.asset_list, channel.asset_properties)\n        elif method_type == \"loads\":\n            load_list = [[x, int(y)] for x, y in channel.asset_list]\n            self.setup_load_channels(load_list)\n        elif method_type == \"machines\":\n            machine_list = [[x, int(y)] for x, y in channel.asset_list]\n            self.setup_machine_channels(machine_list, channel.asset_properties)\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.setup_bus_channels","title":"<code>setup_bus_channels(buses, properties)</code>","text":"<p>Sets up bus channels</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def setup_bus_channels(self, buses, properties):\n    \"Sets up bus channels\"\n\n    for _, qty in enumerate(properties):\n        if qty not in self.channel_map:\n            self.channel_map[qty] = {}\n        for _, b in enumerate(buses):\n            if qty == \"frequency\":\n                self.channel_map[qty][b] = [self.chnl_idx]\n                self.psse.bus_frequency_channel([self.chnl_idx, int(b)], \"\")\n                self.logger.info(f\"Frequency for bus {b} added to channel { self.chnl_idx}\")\n                self.chnl_idx += 1\n            elif qty == \"voltage_and_angle\":\n                self.channel_map[qty][b] = [self.chnl_idx, self.chnl_idx + 1]\n                self.psse.voltage_and_angle_channel([self.chnl_idx, -1, -1, int(b)], \"\")\n                self.logger.info(\n                    f\"Voltage and angle for bus {b} added to channel {self.chnl_idx} and {self.chnl_idx+1}\"\n                )\n                self.chnl_idx += 2\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.setup_load_channels","title":"<code>setup_load_channels(loads)</code>","text":"<p>Sets up load channels</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def setup_load_channels(self, loads):\n    \"Sets up load channels\"\n\n    if \"LOAD_P\" not in self.channel_map:\n        self.channel_map[\"LOAD_P\"] = {}\n        self.channel_map[\"LOAD_Q\"] = {}\n\n    for ld, b in loads:\n        self.channel_map[\"LOAD_P\"][f\"{b}_{ld}\"] = [self.chnl_idx]\n        self.channel_map[\"LOAD_Q\"][f\"{b}_{ld}\"] = [self.chnl_idx + 1]\n        self.psse.load_array_channel([self.chnl_idx, 1, int(b)], ld, \"\")\n        self.psse.load_array_channel([self.chnl_idx + 1, 2, int(b)], ld, \"\")\n        self.logger.info(f\"P and Q for load {b}_{ld} added to channel {self.chnl_idx} and {self.chnl_idx + 1}\")\n        self.chnl_idx += 2\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.setup_machine_channels","title":"<code>setup_machine_channels(machines, properties)</code>","text":"<p>Sets up machine channels</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def setup_machine_channels(self, machines, properties):\n    \"Sets up machine channels\"\n    for _, qty in enumerate(properties):\n        if qty not in self.channel_map:\n            nqty = f\"MACHINE_{qty}\"\n            self.channel_map[nqty] = {}\n        for mch, b in machines:\n            if qty in MACHINE_CHANNELS:\n                self.channel_map[nqty][f\"{b}_{mch}\"] = [self.chnl_idx]\n                chnl_id = MACHINE_CHANNELS[qty]\n                self.logger.info(f\"{qty} for machine {b}_{mch} added to channel {self.chnl_idx}\")\n                self.psse.machine_array_channel([self.chnl_idx, chnl_id, int(b)], mch, \"\")\n                self.chnl_idx += 1\n</code></pre>"},{"location":"code/reference/#contincency-interface","title":"Contincency interface","text":"<p>This module manages contingency modeling in PyPSSE</p>"},{"location":"code/reference/#pypsse.contingencies.BaseFault","title":"<code>BaseFault</code>","text":"<p>Base class defination for all fault types</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class BaseFault:\n    \"Base class defination for all fault types\"\n    __metaclass__ = ABCMeta\n\n    requirements = []\n    fault_settings = {}\n    fault_method = \"\"\n    element = None\n\n    def __init__(self, psse, settings, logger, contingency_type):\n        self.contingency_type = contingency_type\n        self.settings = settings\n        self.logger = logger\n        self.psse = psse\n        self.enabled = False\n        self.tripped = False\n\n    def update(self, t):\n        \"updates a fault event\"\n        self.t = t\n        if hasattr(self.settings, \"duration\"):\n            if self.settings.time + self.settings.duration &gt; t &gt;= self.settings.time and not self.enabled:\n                self.enabled = True\n                self.enable_fault()\n            if t &gt;= self.settings.time + self.settings.duration and self.enabled:\n                self.enabled = False\n                self.disable_fault()\n        elif not hasattr(self.settings, \"duration\") and t &gt;= self.settings.time and not self.tripped:\n            self.enable_fault()\n            self.tripped = True\n\n    def enable_fault(self):\n        \"Enables a fault event\"\n        err = getattr(self.psse, self.fault_method)(**self.fault_settings)\n        if err:\n            self.logger.warning(f\"Unable to enable {self.fault_method} at element {self.element}\")\n        else:\n            self.logger.debug(f\"{self.fault_method} applied to {self.element} at time {self.t} seconds\")\n\n    def disable_fault(self):\n        \"Disables a fault event\"\n        err = self.psse.dist_clear_fault()\n        if err:\n            self.logger.warning(f\"Unable to clear {self.fault_method} at element {self.element}\")\n        else:\n            self.logger.debug(f\"{self.fault_method} cleared at element {self.element} at time {self.t} seconds\")\n\n    def is_enabled(self):\n        \"Returns true if the fault object is enabled else false\"\n        return self.enabled\n\n    def is_tripped(self):\n        \"Returns true if the fault object is tripped else false\"\n        return self.tripped\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BaseFault.disable_fault","title":"<code>disable_fault()</code>","text":"<p>Disables a fault event</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def disable_fault(self):\n    \"Disables a fault event\"\n    err = self.psse.dist_clear_fault()\n    if err:\n        self.logger.warning(f\"Unable to clear {self.fault_method} at element {self.element}\")\n    else:\n        self.logger.debug(f\"{self.fault_method} cleared at element {self.element} at time {self.t} seconds\")\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BaseFault.enable_fault","title":"<code>enable_fault()</code>","text":"<p>Enables a fault event</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def enable_fault(self):\n    \"Enables a fault event\"\n    err = getattr(self.psse, self.fault_method)(**self.fault_settings)\n    if err:\n        self.logger.warning(f\"Unable to enable {self.fault_method} at element {self.element}\")\n    else:\n        self.logger.debug(f\"{self.fault_method} applied to {self.element} at time {self.t} seconds\")\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BaseFault.is_enabled","title":"<code>is_enabled()</code>","text":"<p>Returns true if the fault object is enabled else false</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def is_enabled(self):\n    \"Returns true if the fault object is enabled else false\"\n    return self.enabled\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BaseFault.is_tripped","title":"<code>is_tripped()</code>","text":"<p>Returns true if the fault object is tripped else false</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def is_tripped(self):\n    \"Returns true if the fault object is tripped else false\"\n    return self.tripped\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BaseFault.update","title":"<code>update(t)</code>","text":"<p>updates a fault event</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def update(self, t):\n    \"updates a fault event\"\n    self.t = t\n    if hasattr(self.settings, \"duration\"):\n        if self.settings.time + self.settings.duration &gt; t &gt;= self.settings.time and not self.enabled:\n            self.enabled = True\n            self.enable_fault()\n        if t &gt;= self.settings.time + self.settings.duration and self.enabled:\n            self.enabled = False\n            self.disable_fault()\n    elif not hasattr(self.settings, \"duration\") and t &gt;= self.settings.time and not self.tripped:\n        self.enable_fault()\n        self.tripped = True\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BusFault","title":"<code>BusFault</code>","text":"<p>             Bases: <code>BaseFault</code></p> <p>Class defination for a bus fault</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class BusFault(BaseFault):\n    \"Class defination for a bus fault\"\n    fault_method = \"dist_bus_fault\"\n    fault_settings = {}\n\n    def __init__(self, psse, settings: BusFault, logger, contingency_type):\n        super().__init__(psse, settings, logger, contingency_type)\n        self.fault_settings[\"ibus\"] = settings.bus_id\n        self.fault_settings[\"units\"] = 3\n        self.fault_settings[\"values\"] = settings.fault_impedance\n        self.fault_settings[\"basekv\"] = 0.0\n        self.element = settings.bus_id\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BusTrip","title":"<code>BusTrip</code>","text":"<p>             Bases: <code>BaseFault</code></p> <p>Class defination for a bus trip</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class BusTrip(BaseFault):\n    \"Class defination for a bus trip\"\n    fault_method = \"dist_bus_trip\"\n    fault_settings = {}\n\n    def __init__(self, psse, settings: BusTrip, logger, contingency_type):\n        super().__init__(psse, settings, logger, contingency_type)\n        self.fault_settings[\"ibus\"] = settings.bus_id\n        self.element = settings.bus_id\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.LineFault","title":"<code>LineFault</code>","text":"<p>             Bases: <code>BaseFault</code></p> <p>Class defination for a line fault</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class LineFault(BaseFault):\n    \"Class defination for a line fault\"\n    fault_method = \"dist_branch_fault\"\n    fault_settings = {}\n\n    def __init__(self, psse, settings: LineFault, logger, contingency_type):\n        super().__init__(psse, settings, logger, contingency_type)\n        self.fault_settings[\"ibus\"] = settings.bus_ids[0]\n        self.fault_settings[\"jbus\"] = settings.bus_ids[1]\n        self.fault_settings[\"id\"] = settings.bus_ids[2]\n        self.fault_settings[\"units\"] = 3\n        self.fault_settings[\"values\"] = settings.fault_impedance\n        self.fault_settings[\"basekv\"] = 0.0\n        self.element = settings.bus_ids\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.LineTrip","title":"<code>LineTrip</code>","text":"<p>             Bases: <code>BaseFault</code></p> <p>Class defination for a line trip</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class LineTrip(BaseFault):\n    \"Class defination for a line trip\"\n    fault_method = \"dist_branch_trip\"\n    fault_settings = {}\n\n    def __init__(self, psse, settings: LineTrip, logger, contingency_type):\n        super().__init__(psse, settings, logger, contingency_type)\n        self.fault_settings[\"ibus\"] = settings.bus_ids[0]\n        self.fault_settings[\"jbus\"] = settings.bus_ids[1]\n        self.element = settings.bus_ids\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.MachineTrip","title":"<code>MachineTrip</code>","text":"<p>             Bases: <code>BaseFault</code></p> <p>Class defination for a machine fault</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class MachineTrip(BaseFault):\n    \"Class defination for a machine fault\"\n    fault_method = \"dist_machine_trip\"\n    fault_settings = {}\n\n    def __init__(self, psse, settings: MachineTrip, logger, contingency_type):\n        super().__init__(psse, settings, logger, contingency_type)\n        self.fault_settings[\"ibus\"] = settings.bus_id\n        self.fault_settings[\"id\"] = settings.machine_id\n        self.element = settings.bus_id\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.add_contingency","title":"<code>add_contingency(contingency, cont_dict, dt, system_contingencies)</code>","text":"<p>Adds a new contingency</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def add_contingency(contingency, cont_dict, dt, system_contingencies):\n    \"Adds a new contingency\"\n    ontingency_type = contingency.__class__.__name__\n    if ontingency_type in contingencies:\n        system_contingencies.append(contingencies[ontingency_type](**cont_dict))\n    else:\n        msg = \"Invalid contingency type. Valid values are: {}\".format(\",\".join(contingencies.keys()))\n        raise Exception(msg)\n    return system_contingencies, dt\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.build_contingencies","title":"<code>build_contingencies(psse, settings, logger)</code>","text":"<p>Builds all contingencies defined in the settings file</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def build_contingencies(psse, settings: SimulationSettings, logger):\n    \"Builds all contingencies defined in the settings file\"\n    system_contingencies = []\n    if settings.contingencies:\n        for contingency in settings.contingencies:\n            contingency_type = contingency.__class__.__name__\n            if contingency_type in contingencies:\n                system_contingencies.append(\n                    contingencies[contingency_type](psse, contingency, logger, contingency_type)\n                )\n                logger.debug(f'Contingency of type \"{contingency_type}\" added')\n            else:\n                logger.warning(\"Invalid contingency type. Valid values are: {}\".format(\",\".join(contingencies.keys())))\n    else:\n        logger.debug(\"No contingencies to build\")\n    return system_contingencies\n</code></pre>"}]}