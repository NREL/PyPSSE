{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyPSSE","text":"<p>PyPSSE is a Python wrapper around psspy\u2014a Python application programming interface (API) for the Power System Simulator for Engineering (PSS/E)\u2014to perform time series power flow and dynamic simulation for power systems.</p> <p>The PSS/E Python API psspy follows functional programming methodology. The API exposes thousands of methods and can be difficult for new users to work with. PyPSSE wraps around hundreds of function calls in a few methods. This functionality allows users to set up cosimulations with minimal effort.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install using pip:</p> <pre><code>pip install pssepy\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Running an existing PyPSSE project from CLI</p> <pre><code>pypsse run &lt;project path&gt;\n</code></pre> <p>Building a new PyPSSE project from CLI</p> <pre><code>pypsse create-project &lt;args&gt;\n</code></pre> <p>Running a PyPSSE server</p> <pre><code>pypsse serve\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Supports time-series steady-state simulations, which are not inherently supported by PSS/E</li> <li>Fully supports dynamic simulations</li> <li>Built in HELICS interface (for both steady-state and dynamic simulations) enables quick cosimulation setup without a without writing a single line of code</li> <li>Command line interface allows users to create new projects, run simulations, and view reports</li> <li>Offers RESTful API interface</li> <li>Profile and result management modules allow users to interface with external profiles and mange results</li> <li>Results manger can be configured to work with PSS/E channels and psspy API calls</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the BSD 3-Clause License - see the LICENSE file for details.</p>"},{"location":"#support","title":"Support","text":"<p>If you have questions or need help, please contact [aadil.latif@nrel.gov].</p>"},{"location":"license/","title":"License","text":"<p>Copyright (c) 2018, Alliance for Sustainable Energy LLC, All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ul> <li> <p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p> </li> </ul> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"code/api/","title":"API interfaces","text":"<p>The PyPSSE REST API interface enables users to run PyPSSE on a server machine. The interface enables orchestration of multiple simualtion runs in parallel. Future extenions will support</p> <ul> <li>User management</li> <li>Result retrival during simulation runs using web socket implementation</li> <li>Ability to upload existing PyPSSE project to the server machine</li> </ul>"},{"location":"code/api/#psse_service-restful-api-documentation-100","title":"psse_service RESTful API documentation 1.0.0","text":"<p>Create PyPSSE instance, run simulation, get status of running instance, delete running instance etc.</p>"},{"location":"code/api/#simulation","title":"simulation","text":""},{"location":"code/api/#post-simulatorspsse","title":"POST /simulators/psse","text":"<p>Creates a PyPSSE instance</p> <p>Request body</p> <p>application/json</p> <pre><code>{\n    \"parameters\": {\n        \"filename\": \"C:/Users/alatif/Desktop/pypsse-code/examples/static_example/Settings/simulation_settings.toml\"\n    }\n}\n</code></pre> <p>Schema of the request body</p> <pre><code>{\n    \"properties\": {\n        \"parameters\": {\n            \"type\": \"object\"\n        }\n    },\n    \"type\": \"object\"\n}\n</code></pre>"},{"location":"code/api/#response-200-ok","title":"Response 200 OK","text":"<p>application/json</p> <pre><code>{\n    \"Message\": \"Starting PSSE\",\n    \"Status\": \"Success,\",\n    \"UUID\": \"96c21e00-cd3c-4943-a914-14451f5f7ab6\"\n}\n</code></pre> <p>Schema of the response body</p> <pre><code>{\n    \"type\": \"object\"\n}\n</code></pre>"},{"location":"code/api/#response-500-internal-server-error","title":"Response 500 Internal Server Error","text":"<p>application/json</p> <pre><code>{\n    \"Message\": \"Failed creating an instance\",\n    \"Status\": \"Failed,\",\n    \"UUID\": \"96c21e00-cd3c-4943-a914-14451f5f7ab6\"\n}\n</code></pre> <p>Schema of the response body</p> <pre><code>{\n    \"type\": \"object\"\n}\n</code></pre>"},{"location":"code/api/#put-simulatorspsse","title":"PUT /simulators/psse","text":"<p>Run a command on an instance of PyPSSE.</p> <p>Request body</p> <p>application/json</p> <pre><code>{\n    \"UUID\": \"96c21e00-cd3c-4943-a914-14451f5f7ab6\",\n    \"command\": \"init\",\n    \"parameters\": {}\n}\n</code></pre> <pre><code>{\n    \"UUID\": \"96c21e00-cd3c-4943-a914-14451f5f7ab6\",\n    \"command\": \"solve_step\",\n    \"parameters\": {}\n}\n</code></pre> <pre><code>{\n    \"UUID\": \"96c21e00-cd3c-4943-a914-14451f5f7ab6\",\n    \"command\": \"get_results\",\n    \"parameters\": {\n        \"params\": {\n            \"Buses\": {\n                \"id_fields\": [\n                    \"PU\",\n                    \"ANGLE\"\n                ]\n            },\n            \"Loads\": {\n                \"id_fields\": [\n                    \"MVA\"\n                ]\n            }\n        }\n    }\n}\n</code></pre> <p>Schema of the request body</p> <pre><code>{\n    \"properties\": {\n        \"UUID\": {\n            \"example\": \"96c21e00-cd3c-4943-a914-14451f5f7ab6\",\n            \"format\": \"UUID\",\n            \"type\": \"string\"\n        },\n        \"command\": {\n            \"example\": \"open_case\",\n            \"type\": \"string\"\n        },\n        \"parameters\": {\n            \"type\": \"object\"\n        }\n    },\n    \"type\": \"object\"\n}\n</code></pre>"},{"location":"code/api/#response-200-ok_1","title":"Response 200 OK","text":"<p>application/json</p> <pre><code>{\n    \"Message\": \"init command submitted, awaiting response\",\n    \"Status\": \"Success\",\n    \"UUID\": \"96c21e00-cd3c-4943-a914-14451f5f7ab6\"\n}\n</code></pre> <p>Schema of the response body</p> <pre><code>{\n    \"type\": \"object\"\n}\n</code></pre>"},{"location":"code/api/#response-500-internal-server-error_1","title":"Response 500 Internal Server Error","text":"<p>application/json</p> <pre><code>{\n    \"code\": 500,\n    \"message\": \"Error placing command\"\n}\n</code></pre> <p>Schema of the response body</p> <pre><code>{\n    \"type\": \"object\"\n}\n</code></pre>"},{"location":"code/api/#delete-simulatorspsseuuiduuid","title":"DELETE /simulators/psse/uuid/{uuid}","text":"<p>Deletes an active instance of PyPSSE.</p> <p>Input parameters</p> Parameter In Type Default Nullable Description uuid path string No"},{"location":"code/api/#response-200-ok_2","title":"Response 200 OK","text":"<p>application/json</p> <pre><code>{\n    \"Message\": \"Attempting to close psse instance\",\n    \"Status\": \"Success\",\n    \"UUID\": \"96c21e00-cd3c-4943-a914-14451f5f7ab6\"\n}\n</code></pre> <p>Schema of the response body</p> <pre><code>{\n    \"type\": \"object\"\n}\n</code></pre>"},{"location":"code/api/#response-500-internal-server-error_2","title":"Response 500 Internal Server Error","text":"<p>application/json</p> <pre><code>{\n    \"code\": 500,\n    \"message\": \"Error closing in PSSE instance 96c21e00-cd3c-4943-a914-14451f5f7ab6\"\n}\n</code></pre> <p>Schema of the response body</p> <pre><code>{\n    \"type\": \"object\"\n}\n</code></pre>"},{"location":"code/api/#simulation-status","title":"simulation status","text":""},{"location":"code/api/#get-simulatorspsseinstances","title":"GET /simulators/psse/instances","text":"<p>Returns UUIDs of all instances running on the server</p>"},{"location":"code/api/#response-200-ok_3","title":"Response 200 OK","text":"<p>application/json</p> <pre><code>{\n    \"Instances\": [],\n    \"Status\": \"Success\"\n}\n</code></pre> <p>Schema of the response body</p> <pre><code>{\n    \"type\": \"object\"\n}\n</code></pre>"},{"location":"code/api/#head-simulatorspsseinstances","title":"HEAD /simulators/psse/instances","text":"<p>Returns UUIDs of all instances running on the server</p>"},{"location":"code/api/#response-200-ok_4","title":"Response 200 OK","text":"<p>application/json</p> <pre><code>{\n    \"Instances\": [],\n    \"Status\": \"Success\"\n}\n</code></pre> <p>Schema of the response body</p> <pre><code>{\n    \"type\": \"object\"\n}\n</code></pre>"},{"location":"code/api/#get-simulatorspssestatusuuiduuid","title":"GET /simulators/psse/status/uuid/{uuid}","text":"<p>This end-point gives the status of PyPSSE instance.</p> <p>Input parameters</p> Parameter In Type Default Nullable Description uuid path string No"},{"location":"code/api/#response-200-ok_5","title":"Response 200 OK","text":"<p>application/json</p> <pre><code>{\n    \"Message\": \"None\",\n    \"Status\": \"Success\",\n    \"UUID\": \"96c21e00-cd3c-4943-a914-14451f5f7ab6\"\n}\n</code></pre> <p>Schema of the response body</p> <pre><code>{\n    \"type\": \"object\"\n}\n</code></pre>"},{"location":"code/api/#response-500-internal-server-error_3","title":"Response 500 Internal Server Error","text":"<p>application/json</p> <pre><code>{\n    \"Message\": \"Does not exists\",\n    \"Status\": \"Failed\",\n    \"UUID\": \"96c21e00-cd3c-4943-a914-14451f5f7ab6\"\n}\n</code></pre> <p>Schema of the response body</p> <pre><code>{\n    \"type\": \"object\"\n}\n</code></pre>"},{"location":"code/api/#head-simulatorspssestatusuuiduuid","title":"HEAD /simulators/psse/status/uuid/{uuid}","text":"<p>This end-point gives the status of PyPSSE instance.</p> <p>Input parameters</p> Parameter In Type Default Nullable Description uuid path string No"},{"location":"code/api/#response-200-ok_6","title":"Response 200 OK","text":"<p>application/json</p> <pre><code>{\n    \"Message\": \"None\",\n    \"Status\": \"Success\",\n    \"UUID\": \"96c21e00-cd3c-4943-a914-14451f5f7ab6\"\n}\n</code></pre> <p>Schema of the response body</p> <pre><code>{\n    \"type\": \"object\"\n}\n</code></pre>"},{"location":"code/api/#response-500-internal-server-error_4","title":"Response 500 Internal Server Error","text":"<p>application/json</p> <pre><code>{\n    \"Message\": \"Does not exists\",\n    \"Status\": \"Failed\",\n    \"UUID\": \"96c21e00-cd3c-4943-a914-14451f5f7ab6\"\n}\n</code></pre> <p>Schema of the response body</p> <pre><code>{\n    \"type\": \"object\"\n}\n</code></pre>"},{"location":"code/cli/","title":"API interfaces","text":""},{"location":"code/cli/#create-project","title":"create-project","text":"<p>Create a new PyPSSE project.</p> <p>Usage:</p> <pre><code>create-project [OPTIONS] PATH\n</code></pre> <p>Options:</p> <pre><code>  -o, --overwrite                 Overwrite project is it already exists\n                                  [default: True]\n  -a, --autofill                  Attempt to auto fill settings. (Verify\n                                  manually settings file is correct)\n                                  [default: True]\n  -m, --profile-mapping TEXT      Path to a valid Profile_mapping.toml\n                                  file (used to map profile to PSSE\n                                  elements)\n  -s, --profile-store TEXT        Path to a valid Profiles.hdf5 file\n                                  (Contains profiles for time series\n                                  simulations)\n  -e, --export-settings-file TEXT\n                                  Export settings toml file path\n  -f, --simulation-file TEXT      Simulation settings toml file path\n  -F, --psse-project-folder PATH  PSS/E project folder path\n  -p, --project TEXT              project name  [required]\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"code/cli/#run","title":"run","text":"<p>Runs a valid PyPSSE simulation.</p> <p>Usage:</p> <pre><code>run [OPTIONS] PROJECT_PATH\n</code></pre> <p>Options:</p> <pre><code>  -s, --simulations-file TEXT  scenario toml file to run (over rides\n                               default)  [default:\n                               simulation_settings.toml]\n  --help                       Show this message and exit.\n</code></pre>"},{"location":"code/cli/#create-profiles","title":"create-profiles","text":"<p>Creates profiles for PyPSSE project.</p> <p>Usage:</p> <pre><code>create-profiles [OPTIONS] PROJECT_PATH\n</code></pre> <p>Options:</p> <pre><code>  -i, --profile-info TEXT    Profile time resolution in seconds\n  -r, --profile-res FLOAT    Profile time resolution in seconds  [default:\n                             1.0]\n  -T, --start-time TEXT      Time index for the first time step, format =\n                             Y-m-d H:M:S.f  [default: 2020-01-01\n                             00:00:00.00]\n  -t, --profile-type TEXT    Profile type; Possible values: ['Load',\n                             'Induction_machine', 'Machine', 'Plant']\n                             [default: Load]\n  -n, --profile-name TEXT    Profile name  [default: Default]\n  -p, --profile-folder TEXT  Path to folder containing csv profiles. CSV\n                             file names should follow the following\n                             format: {profile-type}_{profile-name}\n  -f, --csv-file-path TEXT   Path to a csv valid file\n  --help                     Show this message and exit.\n</code></pre>"},{"location":"code/cli/#serve","title":"serve","text":"<p>Run a PyPSSE RESTful API server.</p> <p>Usage:</p> <pre><code>serve [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -h, --host-ip TEXT  IP for the server  [default: 127.0.0.1]\n  -p, --port INTEGER  Socket port for the server  [default: 9090]\n  --help              Show this message and exit.\n</code></pre>"},{"location":"code/helics_interface/","title":"Reference manual","text":"<p>PyPSSE enables out of the box integration for co-simulation and co-optimization / co-design frameworks.</p>"},{"location":"code/helics_interface/#the-helics-co-simulation-framework","title":"The HELICS co-simulation framework","text":"<p>HELICS is a scalable open-source co-simulation framework is designed to integrate simulators designed for separate TDC domains to simulate regional and interconnection-scale power system behaviors at unprecedented levels of detail and speed. </p>"},{"location":"code/helics_interface/#setting-up-the-helics-co-simulation-interface","title":"Setting up the HELICS co-simulation interface","text":"<p>To enabled the HELICS interface, set <code>cosimulation_mode = true</code> in the <code>`simulation_settings.toml</code> file.</p> <p>The helics interface requires an existing HELCIS broker running either locally or remotely that the federate can connect to. Broker settings ca also be defined in the same file.</p> <p>Valid HELICS interface settings are:</p> <p> </p>"},{"location":"code/helics_interface/#setting-up-subscriptions","title":"Setting up subscriptions","text":"<p>Federate subscriptions can be set up by creatting a <code>Subscription.csv</code>. The table below presents an example implementation.  </p> bus_subsystem_id bus element_type element_id element_property sub_tag scaler 0 153 Load 1 ['PL'] test.load1.P [1.0] 0 153 Load 1 ['QL'] test.load1.Q [1.0] 0 154 Load 2 ['PL'] test.load2.P [1.0] 0 154 Load 2 ['QL'] test.load2.Q [1.0]"},{"location":"code/helics_interface/#setting-up-publications","title":"Setting up publications","text":"<p>Valid publiations can be defined in PyPSSE in two ways.</p>"},{"location":"code/helics_interface/#pulishing-results-from-the-result-container","title":"Pulishing results from the result container","text":"<p>PyPSSE allows publication of results stored in the simulation store. Publications are set up directly in  <code>simulation_settings.toml</code> file in the PyPSSE project structure.</p> <pre><code>[[helics.publications]]\nbus_subsystems = [ 0,]\nmodel_type = \"Buses\"\nmodel_properties = [ \"FREQ\", \"PU\",]\n</code></pre> <p>All fields are validated against availble datasets in the simulation store. Valid model types and properties are documented here</p> <p></p>"},{"location":"code/helics_interface/#publishing-results-collected-from-channels","title":"Publishing results collected from channels","text":"<p>Results from channels in PSSE can also be published via the HELICS (dynamic simulation only). The setup mechanism is different.</p> <p>Channels can be set up in the <code>export_settings.toml</code> file in a PyPSSE project structure.</p> <p>The following data models can be refered to ensure valid implementation. Results from all channels are published to the simulation store and the HLEICS interface. </p> <p> </p> <p>Both interfaces can be used simultaneously as well</p>"},{"location":"code/helics_interface/#additional-co-simulation-options","title":"Additional co-simulation options","text":""},{"location":"code/helics_interface/#pypsse.helics_interface.HelicsInterface","title":"<code>HelicsInterface</code>","text":"<p>Implements the HEILCS interface for PyPSSE</p> Source code in <code>pypsse\\helics_interface.py</code> <pre><code>class HelicsInterface:\n    \"Implements the HEILCS interface for PyPSSE\"\n    all_sub_results = {}\n    all_pub_results = {}\n\n    dynamic_iter_const = 1000.0\n    n_states = 5\n    init_state = 1\n    dynamic_params = (\"FmA\", \"FmB\", \"FmC\", \"FmD\", \"Fel\")\n\n    def __init__(\n        self, psse, sim, settings: SimulationSettings, export_settings: ExportFileOptions, bus_subsystems, logger\n    ):\n        \"Sets up the co-simulation federate\"\n        self.bus_pubs = [\"bus_id\", \"bus_Vmag\", \"bus_Vang\", \"bus_dev\"]\n        self.psse = psse\n        self.logger = logger\n        self.settings = settings\n        self.export_settings = export_settings\n        self.bus_subsystems = bus_subsystems\n        self.sim = sim\n        self.c_seconds = 0\n        self.c_seconds_old = -1\n\n        self._co_convergance_error_tolerance = settings.helics.error_tolerance\n        self._co_convergance_max_iterations = settings.helics.max_coiterations\n        self.create_federate()\n        self.subsystem_info = []\n        self.publications = {}\n        self.subscriptions = {}\n\n    def enter_execution_mode(self):\n        \"Enables federate to enter execution mode\"\n        itr = 0\n        itr_flag = h.helics_iteration_request_iterate_if_needed\n        while True:\n            itr_status = h.helicsFederateEnterExecutingModeIterative(self.psse_federate, itr_flag)\n            self.logger.debug(\n                f\"--- Iter {itr}: Iteration Status = {itr_status}, Passed Iteration Requestion = {itr_flag}\"\n            )\n            if itr_status == h.helics_iteration_result_next_step:\n                break\n\n    def create_federate(self):\n        \"Creates a HELICS co-simulation federate\"\n        self.fedinfo = h.helicsCreateFederateInfo()\n        h.helicsFederateInfoSetCoreName(self.fedinfo, self.settings.helics.federate_name)\n        h.helicsFederateInfoSetCoreTypeFromString(self.fedinfo, self.settings.helics.core_type.value)\n        h.helicsFederateInfoSetCoreInitString(self.fedinfo, \"--federates=1\")\n        h.helicsFederateInfoSetBroker(self.fedinfo, str(self.settings.helics.broker_ip))\n        h.helicsFederateInfoSetBrokerPort(self.fedinfo, self.settings.helics.broker_port)\n\n        if self.settings.helics.iterative_mode:\n            h.helicsFederateInfoSetTimeProperty(\n                self.fedinfo,\n                h.helics_property_time_delta,\n                self.settings.simulation.simulation_step_resolution.total_seconds() / self.dynamic_iter_const,\n            )\n        else:\n            h.helicsFederateInfoSetTimeProperty(\n                self.fedinfo,\n                h.helics_property_time_delta,\n                self.settings.simulation.simulation_step_resolution.total_seconds(),\n            )\n        self.psse_federate = h.helicsCreateValueFederate(self.settings.helics.federate_name, self.fedinfo)\n\n    def register_publications(self, bus_subsystems):\n        \"Creates a HELICS publications\"\n        self.publications = {}\n        self.pub_struc = []\n        for publication_dict in self.settings.helics.publications:\n            bus_subsystem_ids = publication_dict.bus_subsystems\n            if not set(bus_subsystem_ids).issubset(self.bus_subsystems):\n                msg = f\"One or more invalid bus subsystem ID pass in {bus_subsystem_ids}.\"\n                f\"Valid subsystem IDs are  '{list(self.bus_subsystems.keys())}'.\"\n                raise Exception(msg)\n\n            elm_class = publication_dict.model_type.value\n\n            if not hasattr(self.export_settings, elm_class.lower()):\n                msg = f\"'{elm_class.lower()}' is not a valid class of elements. \"\n                f\"Valid fields are: {list(self.export_settings.dict().keys())}\"\n                raise Exception(msg)\n\n            managed_properties = [ptpy.value for ptpy in getattr(self.export_settings, elm_class.lower())]\n            properties = [p.value for p in publication_dict.model_properties]\n\n            if not set(properties).issubset(managed_properties):\n                msg = f\"One or more publication property defined for class '{elm_class}' is invalid. Properties defined {properties}\"\n                f\"Valid properties for class '{elm_class.lower()}' are '{managed_properties}'\"\n\n                raise Exception(msg)\n\n            bus_cluster = []\n            for bus_subsystem_id in bus_subsystem_ids:\n                bus_cluster.extend([str(x) for x in bus_subsystems[bus_subsystem_id]])\n\n            if elm_class.lower() in MAPPED_CLASS_NAMES:\n                elm_class = MAPPED_CLASS_NAMES[elm_class.lower()]\n\n            self.pub_struc.append([{elm_class: properties}, bus_cluster])\n            temp_res = self.sim.read_subsystems({elm_class: properties}, bus_cluster)\n            temp_res = self.get_restructured_results(temp_res)\n            for c_name, elm_info in temp_res.items():\n                for name, v_info in elm_info.items():\n                    for p_name, val in v_info.items():\n                        pub_tag = f\"{self.settings.helics.federate_name}.{c_name}.{name}.{p_name}\"\n                        dtype_matched = True\n                        if isinstance(val, float):\n                            self.publications[pub_tag] = h.helicsFederateRegisterGlobalTypePublication(\n                                self.psse_federate, pub_tag, \"double\", \"\"\n                            )\n                        elif isinstance(val, complex):\n                            self.publications[pub_tag] = h.helicsFederateRegisterGlobalTypePublication(\n                                self.psse_federate, pub_tag, \"complex\", \"\"\n                            )\n                        elif isinstance(val, int):\n                            self.publications[pub_tag] = h.helicsFederateRegisterGlobalTypePublication(\n                                self.psse_federate, pub_tag, \"integer\", \"\"\n                            )\n                        elif isinstance(val, list):\n                            self.publications[pub_tag] = h.helicsFederateRegisterGlobalTypePublication(\n                                self.psse_federate, pub_tag, \"vector\", \"\"\n                            )\n                        elif isinstance(val, str):\n                            self.publications[pub_tag] = h.helicsFederateRegisterGlobalTypePublication(\n                                self.psse_federate, pub_tag, \"string\", \"\"\n                            )\n                        else:\n                            dtype_matched = False\n                            self.logger.warning(f\"Publication {pub_tag} could not be registered. Data type not found\")\n                        if dtype_matched:\n                            self.logger.debug(f\"Publication registered: {pub_tag}\")\n\n    def register_subscriptions(self):\n        \"Creates a HELICS subscriptions\"\n        self.subscriptions = {}\n        assert (\n            self.settings.simulation.subscriptions_file\n        ), \"HELICS co-simulations requires a subscriptions_file property populated\"\n        sub_data = pd.read_csv(self.settings.simulation.subscriptions_file)\n        self.psse_dict = {}\n        for _, row in sub_data.iterrows():\n            try:\n                row[\"element_property\"] = ast.literal_eval(row[\"element_property\"])\n            except:\n                pass\n            try:\n                row[\"scaler\"] = ast.literal_eval(row[\"scaler\"])\n            except:\n                pass\n\n            if row[\"element_type\"] not in PROFILE_VALIDATION:\n                msg = f\"Subscription file error: {row['element_type']} not a valid element_type.\"\n                f\"Valid element_type are: {list(PROFILE_VALIDATION.keys())}\"\n                raise Exception(msg)\n\n            if (\n                isinstance(row[\"element_property\"], str)\n                and row[\"element_property\"] not in PROFILE_VALIDATION[row[\"element_type\"]]\n            ):\n                msg = f\"Subscription file error: {row['property']} is not valid. \"\n                f\"Valid subtypes for '{row['element_type']}' are: {PROFILE_VALIDATION[row['element_type']]}\"\n                raise Exception(msg)\n\n            valid_set = set(PROFILE_VALIDATION[row[\"element_type\"]])\n            s_set = set(row[\"element_property\"])\n            if isinstance(row[\"element_property\"], list) and valid_set.issubset(s_set):\n                msg = f\"Subscription file error: {row['element_property']} is not a valid subset. \"\n                f\"Valid subtypes for '{row['element_type']}' are: {PROFILE_VALIDATION[row['element_type']]}\"\n                raise Exception(msg)\n\n            element_id = str(row[\"element_id\"])\n\n            self.subscriptions[row[\"sub_tag\"]] = {\n                \"bus\": row[\"bus\"],\n                \"element_id\": element_id,\n                \"element_type\": row[\"element_type\"],\n                \"property\": row[\"element_property\"],\n                \"scaler\": row[\"scaler\"],\n                \"dStates\": [self.init_state] * self.n_states,\n                \"subscription\": h.helicsFederateRegisterSubscription(self.psse_federate, row[\"sub_tag\"], \"\"),\n            }\n\n            self.logger.info(\n                \"{} property of element {}.{} at bus {} has subscribed to {}\".format(\n                    row[\"element_property\"], row[\"element_type\"], row[\"element_id\"], row[\"bus\"], row[\"sub_tag\"]\n                )\n            )\n\n            if row[\"bus\"] not in self.psse_dict:\n                self.psse_dict[row[\"bus\"]] = {}\n            if row[\"element_type\"] not in self.psse_dict[row[\"bus\"]]:\n                self.psse_dict[row[\"bus\"]][row[\"element_type\"]] = {}\n            if element_id not in self.psse_dict[row[\"bus\"]][row[\"element_type\"]]:\n                self.psse_dict[row[\"bus\"]][row[\"element_type\"]][element_id] = {}\n            if isinstance(row[\"element_property\"], str):\n                if row[\"element_property\"] not in self.psse_dict[row[\"bus\"]][row[\"element_type\"]][element_id]:\n                    self.psse_dict[row[\"bus\"]][row[\"element_type\"]][element_id][row[\"element_property\"]] = 0\n            elif isinstance(row[\"element_property\"], list):\n                for r in row[\"element_property\"]:\n                    if r not in self.psse_dict[row[\"bus\"]][row[\"element_type\"]][element_id]:\n                        self.psse_dict[row[\"bus\"]][row[\"element_type\"]][element_id][r] = 0\n\n    def request_time(self, _):\n        \"Enables time increment of the federate ina  co-simulation. Works for both loosely ans tightly coupled co-simulations\"\n        r_seconds = self.sim.get_total_seconds()  # - self._dss_solver.GetStepResolutionSeconds()\n        if self.sim.get_time() not in self.all_sub_results:\n            self.all_sub_results[self.sim.get_time()] = {}\n            self.all_pub_results[self.sim.get_time()] = {}\n\n        if not self.settings.helics.iterative_mode:\n            while self.c_seconds &lt; r_seconds:\n                self.c_seconds = h.helicsFederateRequestTime(self.psse_federate, r_seconds)\n            self.logger.info(f\"Time requested: {r_seconds} - time granted: {self.c_seconds} \")\n            return True, self.c_seconds\n        else:\n            itr = 0\n            epsilon = 1e-6\n            while True:\n                self.c_seconds, itr_state = h.helicsFederateRequestTimeIterative(\n                    self.psse_federate, r_seconds, h.helics_iteration_request_iterate_if_needed\n                )\n                if itr_state == h.helics_iteration_result_next_step:\n                    self.logger.debug(\"\\tIteration complete!\")\n                    break\n\n                error = max([abs(x[\"dStates\"][0] - x[\"dStates\"][1]) for k, x in self.subscriptions.items()])\n\n                subscriptions = self.subscribe()\n                for sub_name, sub_value in subscriptions.items():\n                    if sub_name not in self.all_sub_results[self.sim.get_time()]:\n                        self.all_sub_results[self.sim.get_time()][sub_name] = []\n                    self.all_sub_results[self.sim.get_time()][sub_name].append(sub_value)\n\n                self.sim.resolveStep(r_seconds)\n\n                publications = self.publish()\n                for pub_name, pub_value in publications.items():\n                    if pub_name not in self.all_pub_results[self.sim.get_time()]:\n                        self.all_pub_results[self.sim.get_time()][pub_name] = []\n                    self.all_pub_results[self.sim.get_time()][pub_name].append(pub_value)\n\n                itr += 1\n                self.logger.debug(f\"\\titr = {itr}\")\n\n                if itr &gt; self.settings.helics.max_coiterations or error &lt; epsilon:\n                    self.c_seconds, itr_state = h.helicsFederateRequestTimeIterative(\n                        self.psse_federate, r_seconds, h.helics_iteration_request_no_iteration\n                    )\n                else:\n                    pass\n\n            return True, self.c_seconds\n\n    def get_restructured_results(self, results):\n        \"Quries PSSE results that are to be published each iteration.\"\n        results_dict = {}\n        for k, d in results.items():\n            c, p = k.split(\"_\")\n            if c not in results_dict:\n                results_dict[c] = {}\n            for n_raw, v in d.items():\n                if isinstance(n_raw, str):\n                    n = n_raw.replace(\" \", \"\")\n                else:\n                    n = str(n_raw)\n                if n not in results_dict[c]:\n                    results_dict[c][n] = {}\n                results_dict[c][n].update({p: v})\n        return results_dict\n\n    def publish(self):\n        \"Publishes updated reslts each iteration\"\n        pub_results = {}\n        for quantities, subsystem_buses in self.pub_struc:\n            temp_res = self.sim.read_subsystems(quantities, subsystem_buses)\n            temp_res = self.get_restructured_results(temp_res)\n            for c_name, elm_info in temp_res.items():\n                for name, v_info in elm_info.items():\n                    for p_name, val in v_info.items():\n                        pub_tag = f\"{self.settings.helics.federate_name}.{c_name}.{name}.{p_name}\"\n                        pub_tag_reduced = f\"{c_name}.{name}.{p_name}\"\n                        pub = self.publications[pub_tag]\n                        dtype_matched = True\n                        pub_results[pub_tag_reduced] = val\n                        if isinstance(val, float):\n                            h.helicsPublicationPublishDouble(pub, val)\n                        elif isinstance(val, complex):\n                            h.helicsPublicationPublishComplex(pub, val.real, val.imag)\n                        elif isinstance(val, int):\n                            h.helicsPublicationPublishInteger(pub, val)\n                        elif isinstance(val, list):\n                            h.helicsPublicationPublishVector(pub, val)\n                        elif isinstance(val, str):\n                            h.helicsPublicationPublishString(pub, val)\n                        else:\n                            dtype_matched = False\n                            self.logger.warning(f\"Publication {pub_tag} not updated\")\n                        if dtype_matched:\n                            self.logger.debug(f\"Publication {pub_tag} published: {val}\")\n        return pub_results\n\n    def subscribe(self):\n        \"Subscribes results each iteration and updates PSSE objects accordingly\"\n        for sub_tag, sub_data in self.subscriptions.items():\n            if isinstance(sub_data[\"property\"], str):\n                sub_data[\"value\"] = h.helicsInputGetDouble(sub_data[\"subscription\"])\n                self.psse_dict[sub_data[\"bus\"]][sub_data[\"element_type\"]][sub_data[\"element_id\"]][\n                    sub_data[\"property\"]\n                ] = (sub_data[\"value\"], sub_data[\"scaler\"])\n            elif isinstance(sub_data[\"property\"], list):\n                sub_data[\"value\"] = h.helicsInputGetVector(sub_data[\"subscription\"])\n                if isinstance(sub_data[\"value\"], list) and len(sub_data[\"value\"]) == len(sub_data[\"property\"]):\n                    for i, p in enumerate(sub_data[\"property\"]):\n                        self.psse_dict[sub_data[\"bus\"]][sub_data[\"element_type\"]][sub_data[\"element_id\"]][p] = (\n                            sub_data[\"value\"][i],\n                            sub_data[\"scaler\"][i],\n                        )\n\n            self.logger.debug(\"Data received {} for tag {}\".format(sub_data[\"value\"], sub_tag))\n            if self.settings.helics.iterative_mode:\n                if self.c_seconds != self.c_seconds_old:\n                    sub_data[\"dStates\"] = [self.init_state] * self.n_states\n                else:\n                    sub_data[\"dStates\"].insert(0, sub_data[\"dStates\"].pop())\n        all_values = {}\n        for b, b_info in self.psse_dict.items():\n            for t, t_info in b_info.items():\n                for i, v_dict in t_info.items():\n                    values = {}\n                    j = 0\n                    for p, v_raw in v_dict.items():\n                        if isinstance(v_raw, tuple):\n                            v, scale = v_raw\n                            all_values[f\"{t}.{b}.{i}.{p}\"] = v\n                            if isinstance(p, str):\n                                ppty = f\"realar{PROFILE_VALIDATION[t].index(p) + 1}\"\n                                values[ppty] = v * scale\n                            elif isinstance(p, list):\n                                for _, ppt in enumerate(p):\n                                    ppty = f\"realar{PROFILE_VALIDATION[t].index(ppt) + 1}\"\n                                    values[ppty] = v * scale\n                        j += 1\n\n                    is_empty = [0 if not vx else 1 for vx in values.values()]\n                    if sum(is_empty) != 0 and sum(values.values()) &lt; 1e6 and sum(values.values()) &gt; -1e6:\n                        self.sim.update_object(t, b, i, values)\n                        self.logger.debug(f\"{t}.{b}.{i} = {values}\")\n\n                    else:\n                        self.logger.debug(\"write failed\")\n\n        self.c_seconds_old = self.c_seconds\n        return all_values\n\n    def fill_missing_values(self, value):\n        \"Fix values before model dispatch\"\n        idx = [f\"realar{PROFILE_VALIDATION[self.d_type].index(c) + 1}\" for c in self.Columns]\n        x = dict(zip(idx, list(value)))\n        return x\n\n    def __del__(self):\n        h.helicsFederateFinalize(self.psse_federate)\n        h.helicsFederateGetState(self.psse_federate)\n        h.helicsFederateInfoFree(self.fedinfo)\n        h.helicsFederateFree(self.psse_federate)\n        self.logger.info(\"HELICS federate for PyDSS destroyed\")\n</code></pre>"},{"location":"code/helics_interface/#pypsse.helics_interface.HelicsInterface.__init__","title":"<code>__init__(psse, sim, settings, export_settings, bus_subsystems, logger)</code>","text":"<p>Sets up the co-simulation federate</p> Source code in <code>pypsse\\helics_interface.py</code> <pre><code>def __init__(\n    self, psse, sim, settings: SimulationSettings, export_settings: ExportFileOptions, bus_subsystems, logger\n):\n    \"Sets up the co-simulation federate\"\n    self.bus_pubs = [\"bus_id\", \"bus_Vmag\", \"bus_Vang\", \"bus_dev\"]\n    self.psse = psse\n    self.logger = logger\n    self.settings = settings\n    self.export_settings = export_settings\n    self.bus_subsystems = bus_subsystems\n    self.sim = sim\n    self.c_seconds = 0\n    self.c_seconds_old = -1\n\n    self._co_convergance_error_tolerance = settings.helics.error_tolerance\n    self._co_convergance_max_iterations = settings.helics.max_coiterations\n    self.create_federate()\n    self.subsystem_info = []\n    self.publications = {}\n    self.subscriptions = {}\n</code></pre>"},{"location":"code/helics_interface/#pypsse.helics_interface.HelicsInterface.create_federate","title":"<code>create_federate()</code>","text":"<p>Creates a HELICS co-simulation federate</p> Source code in <code>pypsse\\helics_interface.py</code> <pre><code>def create_federate(self):\n    \"Creates a HELICS co-simulation federate\"\n    self.fedinfo = h.helicsCreateFederateInfo()\n    h.helicsFederateInfoSetCoreName(self.fedinfo, self.settings.helics.federate_name)\n    h.helicsFederateInfoSetCoreTypeFromString(self.fedinfo, self.settings.helics.core_type.value)\n    h.helicsFederateInfoSetCoreInitString(self.fedinfo, \"--federates=1\")\n    h.helicsFederateInfoSetBroker(self.fedinfo, str(self.settings.helics.broker_ip))\n    h.helicsFederateInfoSetBrokerPort(self.fedinfo, self.settings.helics.broker_port)\n\n    if self.settings.helics.iterative_mode:\n        h.helicsFederateInfoSetTimeProperty(\n            self.fedinfo,\n            h.helics_property_time_delta,\n            self.settings.simulation.simulation_step_resolution.total_seconds() / self.dynamic_iter_const,\n        )\n    else:\n        h.helicsFederateInfoSetTimeProperty(\n            self.fedinfo,\n            h.helics_property_time_delta,\n            self.settings.simulation.simulation_step_resolution.total_seconds(),\n        )\n    self.psse_federate = h.helicsCreateValueFederate(self.settings.helics.federate_name, self.fedinfo)\n</code></pre>"},{"location":"code/helics_interface/#pypsse.helics_interface.HelicsInterface.enter_execution_mode","title":"<code>enter_execution_mode()</code>","text":"<p>Enables federate to enter execution mode</p> Source code in <code>pypsse\\helics_interface.py</code> <pre><code>def enter_execution_mode(self):\n    \"Enables federate to enter execution mode\"\n    itr = 0\n    itr_flag = h.helics_iteration_request_iterate_if_needed\n    while True:\n        itr_status = h.helicsFederateEnterExecutingModeIterative(self.psse_federate, itr_flag)\n        self.logger.debug(\n            f\"--- Iter {itr}: Iteration Status = {itr_status}, Passed Iteration Requestion = {itr_flag}\"\n        )\n        if itr_status == h.helics_iteration_result_next_step:\n            break\n</code></pre>"},{"location":"code/helics_interface/#pypsse.helics_interface.HelicsInterface.fill_missing_values","title":"<code>fill_missing_values(value)</code>","text":"<p>Fix values before model dispatch</p> Source code in <code>pypsse\\helics_interface.py</code> <pre><code>def fill_missing_values(self, value):\n    \"Fix values before model dispatch\"\n    idx = [f\"realar{PROFILE_VALIDATION[self.d_type].index(c) + 1}\" for c in self.Columns]\n    x = dict(zip(idx, list(value)))\n    return x\n</code></pre>"},{"location":"code/helics_interface/#pypsse.helics_interface.HelicsInterface.get_restructured_results","title":"<code>get_restructured_results(results)</code>","text":"<p>Quries PSSE results that are to be published each iteration.</p> Source code in <code>pypsse\\helics_interface.py</code> <pre><code>def get_restructured_results(self, results):\n    \"Quries PSSE results that are to be published each iteration.\"\n    results_dict = {}\n    for k, d in results.items():\n        c, p = k.split(\"_\")\n        if c not in results_dict:\n            results_dict[c] = {}\n        for n_raw, v in d.items():\n            if isinstance(n_raw, str):\n                n = n_raw.replace(\" \", \"\")\n            else:\n                n = str(n_raw)\n            if n not in results_dict[c]:\n                results_dict[c][n] = {}\n            results_dict[c][n].update({p: v})\n    return results_dict\n</code></pre>"},{"location":"code/helics_interface/#pypsse.helics_interface.HelicsInterface.publish","title":"<code>publish()</code>","text":"<p>Publishes updated reslts each iteration</p> Source code in <code>pypsse\\helics_interface.py</code> <pre><code>def publish(self):\n    \"Publishes updated reslts each iteration\"\n    pub_results = {}\n    for quantities, subsystem_buses in self.pub_struc:\n        temp_res = self.sim.read_subsystems(quantities, subsystem_buses)\n        temp_res = self.get_restructured_results(temp_res)\n        for c_name, elm_info in temp_res.items():\n            for name, v_info in elm_info.items():\n                for p_name, val in v_info.items():\n                    pub_tag = f\"{self.settings.helics.federate_name}.{c_name}.{name}.{p_name}\"\n                    pub_tag_reduced = f\"{c_name}.{name}.{p_name}\"\n                    pub = self.publications[pub_tag]\n                    dtype_matched = True\n                    pub_results[pub_tag_reduced] = val\n                    if isinstance(val, float):\n                        h.helicsPublicationPublishDouble(pub, val)\n                    elif isinstance(val, complex):\n                        h.helicsPublicationPublishComplex(pub, val.real, val.imag)\n                    elif isinstance(val, int):\n                        h.helicsPublicationPublishInteger(pub, val)\n                    elif isinstance(val, list):\n                        h.helicsPublicationPublishVector(pub, val)\n                    elif isinstance(val, str):\n                        h.helicsPublicationPublishString(pub, val)\n                    else:\n                        dtype_matched = False\n                        self.logger.warning(f\"Publication {pub_tag} not updated\")\n                    if dtype_matched:\n                        self.logger.debug(f\"Publication {pub_tag} published: {val}\")\n    return pub_results\n</code></pre>"},{"location":"code/helics_interface/#pypsse.helics_interface.HelicsInterface.register_publications","title":"<code>register_publications(bus_subsystems)</code>","text":"<p>Creates a HELICS publications</p> Source code in <code>pypsse\\helics_interface.py</code> <pre><code>def register_publications(self, bus_subsystems):\n    \"Creates a HELICS publications\"\n    self.publications = {}\n    self.pub_struc = []\n    for publication_dict in self.settings.helics.publications:\n        bus_subsystem_ids = publication_dict.bus_subsystems\n        if not set(bus_subsystem_ids).issubset(self.bus_subsystems):\n            msg = f\"One or more invalid bus subsystem ID pass in {bus_subsystem_ids}.\"\n            f\"Valid subsystem IDs are  '{list(self.bus_subsystems.keys())}'.\"\n            raise Exception(msg)\n\n        elm_class = publication_dict.model_type.value\n\n        if not hasattr(self.export_settings, elm_class.lower()):\n            msg = f\"'{elm_class.lower()}' is not a valid class of elements. \"\n            f\"Valid fields are: {list(self.export_settings.dict().keys())}\"\n            raise Exception(msg)\n\n        managed_properties = [ptpy.value for ptpy in getattr(self.export_settings, elm_class.lower())]\n        properties = [p.value for p in publication_dict.model_properties]\n\n        if not set(properties).issubset(managed_properties):\n            msg = f\"One or more publication property defined for class '{elm_class}' is invalid. Properties defined {properties}\"\n            f\"Valid properties for class '{elm_class.lower()}' are '{managed_properties}'\"\n\n            raise Exception(msg)\n\n        bus_cluster = []\n        for bus_subsystem_id in bus_subsystem_ids:\n            bus_cluster.extend([str(x) for x in bus_subsystems[bus_subsystem_id]])\n\n        if elm_class.lower() in MAPPED_CLASS_NAMES:\n            elm_class = MAPPED_CLASS_NAMES[elm_class.lower()]\n\n        self.pub_struc.append([{elm_class: properties}, bus_cluster])\n        temp_res = self.sim.read_subsystems({elm_class: properties}, bus_cluster)\n        temp_res = self.get_restructured_results(temp_res)\n        for c_name, elm_info in temp_res.items():\n            for name, v_info in elm_info.items():\n                for p_name, val in v_info.items():\n                    pub_tag = f\"{self.settings.helics.federate_name}.{c_name}.{name}.{p_name}\"\n                    dtype_matched = True\n                    if isinstance(val, float):\n                        self.publications[pub_tag] = h.helicsFederateRegisterGlobalTypePublication(\n                            self.psse_federate, pub_tag, \"double\", \"\"\n                        )\n                    elif isinstance(val, complex):\n                        self.publications[pub_tag] = h.helicsFederateRegisterGlobalTypePublication(\n                            self.psse_federate, pub_tag, \"complex\", \"\"\n                        )\n                    elif isinstance(val, int):\n                        self.publications[pub_tag] = h.helicsFederateRegisterGlobalTypePublication(\n                            self.psse_federate, pub_tag, \"integer\", \"\"\n                        )\n                    elif isinstance(val, list):\n                        self.publications[pub_tag] = h.helicsFederateRegisterGlobalTypePublication(\n                            self.psse_federate, pub_tag, \"vector\", \"\"\n                        )\n                    elif isinstance(val, str):\n                        self.publications[pub_tag] = h.helicsFederateRegisterGlobalTypePublication(\n                            self.psse_federate, pub_tag, \"string\", \"\"\n                        )\n                    else:\n                        dtype_matched = False\n                        self.logger.warning(f\"Publication {pub_tag} could not be registered. Data type not found\")\n                    if dtype_matched:\n                        self.logger.debug(f\"Publication registered: {pub_tag}\")\n</code></pre>"},{"location":"code/helics_interface/#pypsse.helics_interface.HelicsInterface.register_subscriptions","title":"<code>register_subscriptions()</code>","text":"<p>Creates a HELICS subscriptions</p> Source code in <code>pypsse\\helics_interface.py</code> <pre><code>def register_subscriptions(self):\n    \"Creates a HELICS subscriptions\"\n    self.subscriptions = {}\n    assert (\n        self.settings.simulation.subscriptions_file\n    ), \"HELICS co-simulations requires a subscriptions_file property populated\"\n    sub_data = pd.read_csv(self.settings.simulation.subscriptions_file)\n    self.psse_dict = {}\n    for _, row in sub_data.iterrows():\n        try:\n            row[\"element_property\"] = ast.literal_eval(row[\"element_property\"])\n        except:\n            pass\n        try:\n            row[\"scaler\"] = ast.literal_eval(row[\"scaler\"])\n        except:\n            pass\n\n        if row[\"element_type\"] not in PROFILE_VALIDATION:\n            msg = f\"Subscription file error: {row['element_type']} not a valid element_type.\"\n            f\"Valid element_type are: {list(PROFILE_VALIDATION.keys())}\"\n            raise Exception(msg)\n\n        if (\n            isinstance(row[\"element_property\"], str)\n            and row[\"element_property\"] not in PROFILE_VALIDATION[row[\"element_type\"]]\n        ):\n            msg = f\"Subscription file error: {row['property']} is not valid. \"\n            f\"Valid subtypes for '{row['element_type']}' are: {PROFILE_VALIDATION[row['element_type']]}\"\n            raise Exception(msg)\n\n        valid_set = set(PROFILE_VALIDATION[row[\"element_type\"]])\n        s_set = set(row[\"element_property\"])\n        if isinstance(row[\"element_property\"], list) and valid_set.issubset(s_set):\n            msg = f\"Subscription file error: {row['element_property']} is not a valid subset. \"\n            f\"Valid subtypes for '{row['element_type']}' are: {PROFILE_VALIDATION[row['element_type']]}\"\n            raise Exception(msg)\n\n        element_id = str(row[\"element_id\"])\n\n        self.subscriptions[row[\"sub_tag\"]] = {\n            \"bus\": row[\"bus\"],\n            \"element_id\": element_id,\n            \"element_type\": row[\"element_type\"],\n            \"property\": row[\"element_property\"],\n            \"scaler\": row[\"scaler\"],\n            \"dStates\": [self.init_state] * self.n_states,\n            \"subscription\": h.helicsFederateRegisterSubscription(self.psse_federate, row[\"sub_tag\"], \"\"),\n        }\n\n        self.logger.info(\n            \"{} property of element {}.{} at bus {} has subscribed to {}\".format(\n                row[\"element_property\"], row[\"element_type\"], row[\"element_id\"], row[\"bus\"], row[\"sub_tag\"]\n            )\n        )\n\n        if row[\"bus\"] not in self.psse_dict:\n            self.psse_dict[row[\"bus\"]] = {}\n        if row[\"element_type\"] not in self.psse_dict[row[\"bus\"]]:\n            self.psse_dict[row[\"bus\"]][row[\"element_type\"]] = {}\n        if element_id not in self.psse_dict[row[\"bus\"]][row[\"element_type\"]]:\n            self.psse_dict[row[\"bus\"]][row[\"element_type\"]][element_id] = {}\n        if isinstance(row[\"element_property\"], str):\n            if row[\"element_property\"] not in self.psse_dict[row[\"bus\"]][row[\"element_type\"]][element_id]:\n                self.psse_dict[row[\"bus\"]][row[\"element_type\"]][element_id][row[\"element_property\"]] = 0\n        elif isinstance(row[\"element_property\"], list):\n            for r in row[\"element_property\"]:\n                if r not in self.psse_dict[row[\"bus\"]][row[\"element_type\"]][element_id]:\n                    self.psse_dict[row[\"bus\"]][row[\"element_type\"]][element_id][r] = 0\n</code></pre>"},{"location":"code/helics_interface/#pypsse.helics_interface.HelicsInterface.request_time","title":"<code>request_time(_)</code>","text":"<p>Enables time increment of the federate ina  co-simulation. Works for both loosely ans tightly coupled co-simulations</p> Source code in <code>pypsse\\helics_interface.py</code> <pre><code>def request_time(self, _):\n    \"Enables time increment of the federate ina  co-simulation. Works for both loosely ans tightly coupled co-simulations\"\n    r_seconds = self.sim.get_total_seconds()  # - self._dss_solver.GetStepResolutionSeconds()\n    if self.sim.get_time() not in self.all_sub_results:\n        self.all_sub_results[self.sim.get_time()] = {}\n        self.all_pub_results[self.sim.get_time()] = {}\n\n    if not self.settings.helics.iterative_mode:\n        while self.c_seconds &lt; r_seconds:\n            self.c_seconds = h.helicsFederateRequestTime(self.psse_federate, r_seconds)\n        self.logger.info(f\"Time requested: {r_seconds} - time granted: {self.c_seconds} \")\n        return True, self.c_seconds\n    else:\n        itr = 0\n        epsilon = 1e-6\n        while True:\n            self.c_seconds, itr_state = h.helicsFederateRequestTimeIterative(\n                self.psse_federate, r_seconds, h.helics_iteration_request_iterate_if_needed\n            )\n            if itr_state == h.helics_iteration_result_next_step:\n                self.logger.debug(\"\\tIteration complete!\")\n                break\n\n            error = max([abs(x[\"dStates\"][0] - x[\"dStates\"][1]) for k, x in self.subscriptions.items()])\n\n            subscriptions = self.subscribe()\n            for sub_name, sub_value in subscriptions.items():\n                if sub_name not in self.all_sub_results[self.sim.get_time()]:\n                    self.all_sub_results[self.sim.get_time()][sub_name] = []\n                self.all_sub_results[self.sim.get_time()][sub_name].append(sub_value)\n\n            self.sim.resolveStep(r_seconds)\n\n            publications = self.publish()\n            for pub_name, pub_value in publications.items():\n                if pub_name not in self.all_pub_results[self.sim.get_time()]:\n                    self.all_pub_results[self.sim.get_time()][pub_name] = []\n                self.all_pub_results[self.sim.get_time()][pub_name].append(pub_value)\n\n            itr += 1\n            self.logger.debug(f\"\\titr = {itr}\")\n\n            if itr &gt; self.settings.helics.max_coiterations or error &lt; epsilon:\n                self.c_seconds, itr_state = h.helicsFederateRequestTimeIterative(\n                    self.psse_federate, r_seconds, h.helics_iteration_request_no_iteration\n                )\n            else:\n                pass\n\n        return True, self.c_seconds\n</code></pre>"},{"location":"code/helics_interface/#pypsse.helics_interface.HelicsInterface.subscribe","title":"<code>subscribe()</code>","text":"<p>Subscribes results each iteration and updates PSSE objects accordingly</p> Source code in <code>pypsse\\helics_interface.py</code> <pre><code>def subscribe(self):\n    \"Subscribes results each iteration and updates PSSE objects accordingly\"\n    for sub_tag, sub_data in self.subscriptions.items():\n        if isinstance(sub_data[\"property\"], str):\n            sub_data[\"value\"] = h.helicsInputGetDouble(sub_data[\"subscription\"])\n            self.psse_dict[sub_data[\"bus\"]][sub_data[\"element_type\"]][sub_data[\"element_id\"]][\n                sub_data[\"property\"]\n            ] = (sub_data[\"value\"], sub_data[\"scaler\"])\n        elif isinstance(sub_data[\"property\"], list):\n            sub_data[\"value\"] = h.helicsInputGetVector(sub_data[\"subscription\"])\n            if isinstance(sub_data[\"value\"], list) and len(sub_data[\"value\"]) == len(sub_data[\"property\"]):\n                for i, p in enumerate(sub_data[\"property\"]):\n                    self.psse_dict[sub_data[\"bus\"]][sub_data[\"element_type\"]][sub_data[\"element_id\"]][p] = (\n                        sub_data[\"value\"][i],\n                        sub_data[\"scaler\"][i],\n                    )\n\n        self.logger.debug(\"Data received {} for tag {}\".format(sub_data[\"value\"], sub_tag))\n        if self.settings.helics.iterative_mode:\n            if self.c_seconds != self.c_seconds_old:\n                sub_data[\"dStates\"] = [self.init_state] * self.n_states\n            else:\n                sub_data[\"dStates\"].insert(0, sub_data[\"dStates\"].pop())\n    all_values = {}\n    for b, b_info in self.psse_dict.items():\n        for t, t_info in b_info.items():\n            for i, v_dict in t_info.items():\n                values = {}\n                j = 0\n                for p, v_raw in v_dict.items():\n                    if isinstance(v_raw, tuple):\n                        v, scale = v_raw\n                        all_values[f\"{t}.{b}.{i}.{p}\"] = v\n                        if isinstance(p, str):\n                            ppty = f\"realar{PROFILE_VALIDATION[t].index(p) + 1}\"\n                            values[ppty] = v * scale\n                        elif isinstance(p, list):\n                            for _, ppt in enumerate(p):\n                                ppty = f\"realar{PROFILE_VALIDATION[t].index(ppt) + 1}\"\n                                values[ppty] = v * scale\n                    j += 1\n\n                is_empty = [0 if not vx else 1 for vx in values.values()]\n                if sum(is_empty) != 0 and sum(values.values()) &lt; 1e6 and sum(values.values()) &gt; -1e6:\n                    self.sim.update_object(t, b, i, values)\n                    self.logger.debug(f\"{t}.{b}.{i} = {values}\")\n\n                else:\n                    self.logger.debug(\"write failed\")\n\n    self.c_seconds_old = self.c_seconds\n    return all_values\n</code></pre>"},{"location":"code/mdao/","title":"Reference manual","text":"<p>PyPSSE enables out of the box integration for co-simulation and co-optimization / co-design frameworks.</p>"},{"location":"code/mdao/#co-optimization-co-design-with-openmdao","title":"Co-optimization / co-design with OpenMDAO","text":"<p>The OpenMDAO framework enables multi-domain co-optimization by structuring the problem as a group of sub problems. (Ssee OpenMDAO documentation). The OpenMDAO interface implemented in PyPSSE enables it to a subproblem in a larger co-optimization or co-design problem. </p>"},{"location":"code/mdao/#pypsse.mdao.PSSE","title":"<code>PSSE</code>","text":"<p>The class defines the PSSE interface to OpenMDAO</p> Source code in <code>pypsse\\mdao.py</code> <pre><code>class PSSE:\n    \"The class defines the PSSE interface to OpenMDAO\"\n    model_loaded = False\n\n    def load_model(self, settings_file_path, psse_path):\n        \"Load the PyPSSE model\"\n        self.psse_obj = Simulator(settings_file_path, psse_path)\n        self.time_counter = 0\n        self.psse_obj.init()\n        self.model_loaded = True\n\n    def solve_step(self):\n        \"Solves for the current time set and incremetn in time\"\n        self.current_result = self.psse_obj.step(self.time_counter)\n        self.time_counter += self.psse_obj.settings[\"Simulation\"][\"Step resolution (sec)\"]\n        return self.current_result\n\n    def export_result(self):\n        \"Updates results in the result container\"\n        if not self.psse_obj.export_settings[\"Export results using channels\"]:\n            self.psse_obj.results.export_results()\n        else:\n            self.psse_obj.sim.export()\n\n    def close_case(self):\n        \"Closes the loaded model in PyPSSE\"\n        self.psse_obj.PSSE.pssehalt_2()\n        del self.psse_obj\n        logger.info(f\"PSSE case {self.uuid} closed.\")\n\n    def get_results(self, params):\n        \"Queries results from PyPSSE\"\n        settings = {}\n        for k, _ in params.items():\n            settings[k] = {}\n            ppties = params[k][\"id_fields\"]\n            for p in ppties:\n                settings[k][p] = True\n        results = self.psse_obj.get_results(settings)\n        return results\n</code></pre>"},{"location":"code/mdao/#pypsse.mdao.PSSE.close_case","title":"<code>close_case()</code>","text":"<p>Closes the loaded model in PyPSSE</p> Source code in <code>pypsse\\mdao.py</code> <pre><code>def close_case(self):\n    \"Closes the loaded model in PyPSSE\"\n    self.psse_obj.PSSE.pssehalt_2()\n    del self.psse_obj\n    logger.info(f\"PSSE case {self.uuid} closed.\")\n</code></pre>"},{"location":"code/mdao/#pypsse.mdao.PSSE.export_result","title":"<code>export_result()</code>","text":"<p>Updates results in the result container</p> Source code in <code>pypsse\\mdao.py</code> <pre><code>def export_result(self):\n    \"Updates results in the result container\"\n    if not self.psse_obj.export_settings[\"Export results using channels\"]:\n        self.psse_obj.results.export_results()\n    else:\n        self.psse_obj.sim.export()\n</code></pre>"},{"location":"code/mdao/#pypsse.mdao.PSSE.get_results","title":"<code>get_results(params)</code>","text":"<p>Queries results from PyPSSE</p> Source code in <code>pypsse\\mdao.py</code> <pre><code>def get_results(self, params):\n    \"Queries results from PyPSSE\"\n    settings = {}\n    for k, _ in params.items():\n        settings[k] = {}\n        ppties = params[k][\"id_fields\"]\n        for p in ppties:\n            settings[k][p] = True\n    results = self.psse_obj.get_results(settings)\n    return results\n</code></pre>"},{"location":"code/mdao/#pypsse.mdao.PSSE.load_model","title":"<code>load_model(settings_file_path, psse_path)</code>","text":"<p>Load the PyPSSE model</p> Source code in <code>pypsse\\mdao.py</code> <pre><code>def load_model(self, settings_file_path, psse_path):\n    \"Load the PyPSSE model\"\n    self.psse_obj = Simulator(settings_file_path, psse_path)\n    self.time_counter = 0\n    self.psse_obj.init()\n    self.model_loaded = True\n</code></pre>"},{"location":"code/mdao/#pypsse.mdao.PSSE.solve_step","title":"<code>solve_step()</code>","text":"<p>Solves for the current time set and incremetn in time</p> Source code in <code>pypsse\\mdao.py</code> <pre><code>def solve_step(self):\n    \"Solves for the current time set and incremetn in time\"\n    self.current_result = self.psse_obj.step(self.time_counter)\n    self.time_counter += self.psse_obj.settings[\"Simulation\"][\"Step resolution (sec)\"]\n    return self.current_result\n</code></pre>"},{"location":"code/mdao/#pypsse.mdao.PSSEModel","title":"<code>PSSEModel</code>","text":"<p>             Bases: <code>ExplicitComponent</code>, <code>PSSE</code></p> <p>Expicit OpenMDAO component</p> Source code in <code>pypsse\\mdao.py</code> <pre><code>class PSSEModel(om.ExplicitComponent, PSSE):\n    \"Expicit OpenMDAO component\"\n\n    def __init__(self, problem_file, settings_file_path, psse_path):\n        \"Initializes the optimization problem\"\n        super().read_problem_data(problem_file)\n        self.case = self.load_model(settings_file_path, psse_path)\n        super().__init__()\n\n    def setup(self, *_, **__):\n        \"Sets up the optimization problem\"\n        ...\n\n    def setup_partials(self):\n        \"Sets up the partial derivatives\"\n        self.declare_partials(\"*\", \"*\", method=\"fd\")\n</code></pre>"},{"location":"code/mdao/#pypsse.mdao.PSSEModel.__init__","title":"<code>__init__(problem_file, settings_file_path, psse_path)</code>","text":"<p>Initializes the optimization problem</p> Source code in <code>pypsse\\mdao.py</code> <pre><code>def __init__(self, problem_file, settings_file_path, psse_path):\n    \"Initializes the optimization problem\"\n    super().read_problem_data(problem_file)\n    self.case = self.load_model(settings_file_path, psse_path)\n    super().__init__()\n</code></pre>"},{"location":"code/mdao/#pypsse.mdao.PSSEModel.setup","title":"<code>setup(*_, **__)</code>","text":"<p>Sets up the optimization problem</p> Source code in <code>pypsse\\mdao.py</code> <pre><code>def setup(self, *_, **__):\n    \"Sets up the optimization problem\"\n    ...\n</code></pre>"},{"location":"code/mdao/#pypsse.mdao.PSSEModel.setup_partials","title":"<code>setup_partials()</code>","text":"<p>Sets up the partial derivatives</p> Source code in <code>pypsse\\mdao.py</code> <pre><code>def setup_partials(self):\n    \"Sets up the partial derivatives\"\n    self.declare_partials(\"*\", \"*\", method=\"fd\")\n</code></pre>"},{"location":"code/models/","title":"Data models","text":"<p>This page provides details on the data models part of the PyPSSE library.</p> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Bus channel model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class BusChannel(BaseModel):\n    \"Bus channel model defination\"\n\n    type: ChannelTypes = ChannelTypes.BUSES\n    use: UseModes = UseModes.LIST\n    regex: str = \"\"\n    list: List[int] = []\n    properties: List[str] = [\"voltage_and_angle\", \"frequency\"]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Bus fault model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class BusFault(BaseModel):\n    \"Bus fault model defination\"\n    time: float = 0.2\n    bus_id: int = 38205\n    duration: float = 0.3\n    bus_trip: bool = False\n    trip_delay: float = 0.05\n    fault_impedance: List[int] = [\n        1.0,\n        1.0,\n    ]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Bus subsystem model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class BusSubsystems(BaseModel):\n    \"Bus subsystem model defination\"\n    from_file: bool = False\n    bus_file: Optional[str]\n    bus_subsystem_list: List[List[int]] = [\n        [\n            74012,\n            17735,\n            20115,\n            38205,\n            70008,\n            80511,\n        ],\n    ]\n    publish_subsystems: List[int] = [\n        0,\n    ]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Bus trip model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class BusTrip(BaseModel):\n    \"Bus trip model defination\"\n    time: float = 0.2\n    bus_id: int = 38205\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Valid export models and associated options</p> Source code in <code>pypsse\\models.py</code> <pre><code>class ExportAssetTypes(BaseModel):\n    \"Valid export models and associated options\"\n\n    buses: Optional[List[BusProperties]]\n    areas: Optional[List[AreaProperties]]\n    zones: Optional[List[ZoneProperties]]\n    stations: Optional[List[StationProperties]]\n    dctransmissionlines: Optional[List[DCLineProperties]]\n    loads: Optional[List[LoadProperties]]\n    fixed_shunts: Optional[List[FixedShuntProperties]]\n    switched_shunts: Optional[List[SwitchedShuntProperties]]\n    transformers: Optional[List[TransformerProperties]]\n    branches: Optional[List[BranchProperties]]\n    induction_generators: Optional[List[InductionGeneratorProperties]]\n    machines: Optional[List[MachinesProperties]]\n    channels: Optional[List[str]]\n    channel_setup: Optional[List[Union[BusChannel, LoadChannel, MachineChannel]]]\n</code></pre> <p> </p> <p>             Bases: <code>ExportAssetTypes</code></p> <p>Exoprt settings for a PyPSSE project</p> Source code in <code>pypsse\\models.py</code> <pre><code>class ExportFileOptions(ExportAssetTypes):\n    \"Exoprt settings for a PyPSSE project\"\n\n    export_results_using_channels: bool = False\n    defined_subsystems_only: bool = True\n    file_format: ExportModes = \"h5\"\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Export setting model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class ExportSettings(BaseModel):\n    \"Export setting model defination\"\n\n    outx_file: Path = \"test.outx\"\n    out_file: Path = \"20LS11p.out\"\n    excel_file: Path = \"20LS11p.xls\"\n    log_file: Path = \"20LS11p.log\"\n    coordinate_file: Path = \"\"\n    networkx_graph_file: Path = \"20LS11p.gpickle\"\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>GIC export setting model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class GICExportSettings(BaseModel):\n    \"GIC export setting model defination\"\n    include_substation_connections: bool = False\n    include_transfomer_connections: bool = False\n    include_branch_connections: bool = True\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Generator model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class GeneratorSettings(BaseModel):\n    \"Generator model defination\"\n    missing_machine_model: int = 1\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>HELICS co-simualtion setting model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class HelicsSettings(BaseModel):\n    \"HELICS co-simualtion setting model defination\"\n    cosimulation_mode: bool = False\n    federate_name: str = \"psse\"\n    time_delta: timedelta = timedelta(seconds=0.00333333333)\n    core_type: HelicsCoreTypes = \"zmq\"\n    uninterruptible: bool = True\n    helics_logging_level: int = Field(5, ge=1, le=10)\n    create_subscriptions: bool = True\n    iterative_mode: bool = False\n    error_tolerance: float = Field(1e-5, g=0)\n    max_coiterations: int = Field(15, ge=1)\n    broker_ip: IPvAnyAddress = \"127.0.0.1\"\n    broker_port: int = 23404\n    disable_generation_on_coupled_buses: bool = True\n    publications: List[PublicationDefination]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Line fault model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LineFault(BaseModel):\n    \"Line fault model defination\"\n    time: float = 0.2\n    bus_ids: List[int]\n    duration: float = 0.3\n    bus_trip: bool = False\n    trip_delay: float = 0.05\n    fault_impedance: List[int] = [\n        1.0,\n        1.0,\n    ]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Line trip model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LineTrip(BaseModel):\n    \"Line trip model defination\"\n    time: float = 0.2\n    bus_ids: List[int]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Load ZIP model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LoadBreakdown(BaseModel):\n    \"Load ZIP model defination\"\n    constant_current_percentage: float = 0.0\n    constant_admittance_percentage: float = 0.0\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Load channel model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LoadChannel(BaseModel):\n    \"Load channel model defination\"\n\n    type: ChannelTypes = ChannelTypes.LOADS\n    use: UseModes = UseModes.LIST\n    regex: str = \"\"\n    list: List[List[str]] = [[]]\n    properties: List[str] = []\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Load model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LoadSettings(BaseModel):\n    \"Load model defination\"\n    convert: bool = True\n    active_load: LoadBreakdown\n    reactive_load: LoadBreakdown\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Logger setting model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LogSettings(BaseModel):\n    \"Logger setting model defination\"\n    disable_psse_logging: bool = True\n    logging_level: LoggingLevels\n    log_to_external_file: bool = True\n    display_on_screen: bool = True\n    clear_old_log_file: bool = True\n    pre_configured_logging: bool = False\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Machine channel model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class MachineChannel(BaseModel):\n    \"Machine channel model defination\"\n\n    type: ChannelTypes = ChannelTypes.MACHINES\n    use: UseModes = UseModes.LIST\n    regex: str = \"\"\n    list: List[List[str]] = [[]]\n    properties: List[str] = [\"PELEC\", \"QELEC\", \"SPEED\"]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Machine trip model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class MachineTrip(BaseModel):\n    \"Machine trip model defination\"\n    time: float = 0.2\n    bus_id: int = 38205\n    machine_id: str = \"\"\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Plotting setting model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class PlotSettings(BaseModel):\n    \"Plotting setting model defination\"\n    enable_dynamic_plots: bool = False\n    columns: int = Field(15, ge=1)\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Publication setting model defination</p> <p>Attributes:</p> Name Type Description <code>bus_subsystems</code> <code>list(int</code> <p>Description of <code>attr1</code>.</p> <code>model_type</code> <code>ModelTypes</code> <p>asdsad.</p> <code>attmodel_typer2</code> <code>List</code> <p>Description of <code>attr2</code>.</p> Source code in <code>pypsse\\models.py</code> <pre><code>class PublicationDefination(BaseModel):\n    \"\"\"Publication setting model defination\n\n    Attributes:\n        bus_subsystems (list(int)): Description of `attr1`.\n        model_type (ModelTypes): asdsad.\n        attmodel_typer2 (List, optional): Description of `attr2`.\n    \"\"\"\n    bus_subsystems: List[int] = [\n        0,\n    ]\n    model_type: ModelTypes = \"buses\"\n    model_properties: List[ModelProperties] = [\"FREQ\", \"PU\"]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Simulation setting  model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class SimSettings(BaseModel):\n    \"Simulation setting  model defination\"\n    simulation_time: timedelta = timedelta(seconds=3.0)\n    simulation_step_resolution: timedelta = timedelta(seconds=0.025)\n    psse_solver_timestep: timedelta = timedelta(seconds=0.00333333333)\n    start_time: datetime = \"01/01/2020 00:00:00\"\n    use_profile_manager: bool\n    psse_path: Path = \"C:/Program Files/PTI/PSSE35/35.4/PSSPY39232\"\n    project_path: Path = \"C:/Users/alatif/Desktop/NAERM/models/pyPSSEModel\"\n    case_study: Optional[Path]\n    raw_file: Optional[Path]\n    snp_file: Optional[Path]\n    dyr_file: Optional[Path]\n    rwm_file: Optional[Path]\n    gic_file: Optional[Path]\n    subscriptions_file: Optional[Path]\n    user_models: List[str] = []\n    setup_files: List[str] = []\n    simulation_mode: SimulationModes\n\n    @model_validator(mode='after') \n    def sim_res_smaller_than_sim_time(self):  \n        assert self.simulation_step_resolution &lt;= self.simulation_time, \"simulation_step_resolution should be smaller than simulation_time\"\n        return \n\n    @model_validator(mode='after') \n    def psse_res_smaller_than_sim_time(self): \n        assert self.psse_solver_timestep &lt;= self.simulation_time, \"psse_solver_timestep should be smaller than simulation_time\"\n        return \n\n    @model_validator(mode='after')\n    def validate_case_study(self):  # noqa: ARG002\n        file_types = [\"case_study\", \"raw_file\", \"snp_file\", \"dyr_file\", \"rwm_file\", \"gic_file\"]\n        base_project_path = self.project_path\n        for file in file_types:\n            if hasattr(self, file):\n                file_path = getattr(self, file)\n                file_path = base_project_path / CASESTUDY_FOLDER / file_path\n                assert file_path.exists(), f\"{file_path} does not exist\"\n\n    @model_validator(mode='after')\n    def validate_subscription_file(self): \n        base_project_path = self.project_path\n        if hasattr(self, 'subscriptions_file'):\n            self.subscriptions_file = base_project_path / self.subscriptions_file\n            assert self.subscriptions_file.exists(), f\"{self.subscriptions_file} does not esist\"\n            data = pd.read_csv(self.subscriptions_file)\n            csv_cols = set(data.columns)\n            sub_cols = {e.value for e in SubscriptionFileRequiredColumns}\n            assert sub_cols.issubset(csv_cols), f\"{sub_cols} are required columns for a valid subscription file\"\n\n    @model_validator(mode='after')\n    def validate_user_models(self):  \n        base_project_path = self.project_path\n        if hasattr(self, 'user_models'):\n            paths = []\n            for file in self.user_models:\n                model_file = base_project_path / CASESTUDY_FOLDER / file\n                assert model_file.exists(), f\"{model_file} does not esist\"\n                assert model_file.suffix == \".dll\", \"Invalid file extension. Use dll files\"\n                paths.append(model_file)\n\n    @model_validator(mode='after')\n    def validate_simulation_mode(self):\n        if self.simulation_mode == SimulationModes.DYNAMIC:\n            assert not self.simulation_mode[\n                \"use_profile_manager\"\n            ], \"Profile manager can not be used for dynamic simulations. Set 'Use profile manager' to False\"\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>PyPSSE project settings</p> Source code in <code>pypsse\\models.py</code> <pre><code>class SimulationSettings(BaseModel):\n    \"PyPSSE project settings\"\n\n    simulation: SimSettings\n    export: ExportSettings\n    helics: Optional[HelicsSettings]\n    log: LogSettings\n    plots: Optional[PlotSettings]\n    gic_export_settings: Optional[GICExportSettings]\n    bus_subsystems: BusSubsystems\n    loads: LoadSettings\n    generators: GeneratorSettings\n    contingencies: Optional[List[Union[BusFault, LineFault, LineTrip, BusTrip, MachineTrip]]]\n\n    @model_validator(mode='after')\n    def validate_export_paths(self):  \n        base_project_path = self.simulation.project_path\n        if self.export.outx_file:\n            self.export.outx_file = base_project_path / EXPORTS_FOLDER / self.export.outx_file\n        if self.export.out_file:\n            self.export.out_file = base_project_path / EXPORTS_FOLDER / self.export.out_file\n        if self.export.excel_file:\n            self.export.excel_file = base_project_path / EXPORTS_FOLDER / self.export.excel_file\n        if self.export.log_file:\n            self.export.log_file = base_project_path / LOGS_FOLDER / self.export.log_file\n        if self.export.networkx_graph_file:\n            self.export.networkx_graph_file = base_project_path / EXPORTS_FOLDER / self.export.networkx_graph_file\n        if self.export.coordinate_file:\n            self.export.coordinate_file = base_project_path / EXPORTS_FOLDER / self.export.coordinate_file\n</code></pre>"},{"location":"code/reference/","title":"Reference manual","text":""},{"location":"code/reference/#simulation-components","title":"Simulation components","text":"<p>Base class for the simulator</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>class Simulator:\n    \"Base class for the simulator\"\n\n    def __init__(self, settings_toml_path=\"\", psse_path=\"\"):\n        \"Load a valid PyPSSE project and sets up simulation\"\n\n        settings = self.read_settings(settings_toml_path)\n        self.settings = SimulationSettings.validate(settings)\n\n        export_settings_path = self.settings.simulation.project_path / EXPORTS_SETTINGS_FILENAME\n        assert export_settings_path.exists(), f\"{export_settings_path} does nor exist\"\n        export_settings = self.read_settings(export_settings_path)\n        self.export_settings = ExportFileOptions.validate(export_settings)\n\n        log_path = os.path.join(self.settings.simulation.project_path, LOGS_FOLDER)\n        self.logger = logger.get_logger(\"pyPSSE\", log_path, logger_options=self.settings.log)\n        self.logger.debug(\"Starting PSSE instance\")\n\n        if psse_path != \"\" and Path(psse_path).exists():\n            self.settings.simulation.psse_path = Path(psse_path)\n            sys.path.append(psse_path)\n            os.environ[\"PATH\"] += \";\" + psse_path\n        else:\n            sys.path.append(str(self.settings.simulation.psse_path))\n            os.environ[\"PATH\"] += \";\" + str(self.settings.simulation.psse_path)\n\n        try:\n            n_bus = 200000\n            if \"psse34\" in str(self.settings.simulation.psse_path).lower():\n                self.logger.debug(\"Instantiating psse version 34\")\n                import psse34\n            elif \"psse35\" in str(self.settings.simulation.psse_path).lower():\n                self.logger.debug(\"Instantiating psse version 35\")\n                import psse35\n            else:\n                self.logger.debug(\"Instantiating psse version 36\")\n                import psse36\n            import dyntools\n            import psspy\n\n            self.dyntools = dyntools\n            self.psse = psspy\n            # self.logger.debug('Initializing PSS/E. connecting to license server')\n            ierr = self.psse.psseinit(n_bus)\n            assert ierr == 0, f\"Error code: {ierr}\"\n            self.psse.psseinit(n_bus)\n            self.initComplete = True\n            self.message = \"success\"\n\n            self.start_simulation()\n            self.init()\n        except:\n            msg = \"A valid PSS/E license not found. License may currently be in use.\"\n            raise Exception(msg)\n\n    def dump_settings(self, dest_dir):\n        setting_toml_file = os.path.join(os.path.dirname(__file__), \"defaults\", \"pyPSSE_settings.toml\")\n        export_toml_file = os.path.join(os.path.dirname(__file__), \"defaults\", \"export_settings.toml\")\n        shutil.copy(setting_toml_file, dest_dir)\n        shutil.copy(export_toml_file, dest_dir)\n\n    def start_simulation(self):\n        \"Starts a loaded simulation\"\n\n        self.hi = None\n        self.simStartTime = time.time()\n\n        # ** Initialize PSSE modules\n\n        if self.settings.simulation.case_study.exists():\n            self.psse.case(str(self.settings.simulation.case_study))\n        elif self.settings.simulation.raw_file.exists():\n            self.psse.read(0, str(self.settings.simulation.raw_file))\n        else:\n            msg = \"Please pass a RAW or SAV file in the settings dictionary\"\n            raise Exception(msg)\n\n        self.logger.info(f\"Trying to read a file &gt;&gt;{self.settings.simulation.case_study}\")\n        self.raw_data = rd.Reader(self.psse, self.logger)\n        (\n            self.bus_subsystems,\n            self.all_subsysten_buses,\n        ) = self.define_bus_subsystems()\n\n        if self.export_settings.defined_subsystems_only:\n            valid_buses = self.all_subsysten_buses\n        else:\n            valid_buses = self.raw_data.buses\n\n        self.sim = sc.sim_controller(\n            self.psse,\n            self.dyntools,\n            self.settings,\n            self.export_settings,\n            self.logger,\n            valid_buses,\n            self.raw_data,\n        )\n\n        self.contingencies = self.build_contingencies()\n\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            if self.settings.simulation.simulation_mode in [\n                SimulationModes.DYNAMIC,\n                SimulationModes.SNAP,\n            ]:\n                ...\n            self.hi = HelicsInterface(\n                self.psse,\n                self.sim,\n                self.settings,\n                self.export_settings,\n                self.bus_subsystems,\n                self.logger,\n            )\n            self.publications = self.hi.register_publications(self.bus_subsystems)\n            if self.settings.helics.create_subscriptions:\n                self.subscriptions = self.hi.register_subscriptions()\n\n        if self.settings.simulation.gic_file:\n            self.network_graph = self.parse_gic_file()\n            self.bus_ids = self.network_graph.nodes.keys()\n        else:\n            self.network_graph = None\n\n        self.results = Container(self.settings, self.export_settings)\n        self.exp_vars = self.results.get_export_variables()\n        self.inc_time = True\n\n    def init(self):\n        \"Initializes the model\"\n\n        self.sim.init(self.bus_subsystems)\n\n        if self.settings.simulation.use_profile_manager:\n            self.pm = ProfileManager(None, self.sim, self.settings, self.logger)\n            self.pm.setup_profiles()\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            self.hi.enter_execution_mode()\n\n    def parse_gic_file(self):\n        \"Parses the GIC file (if included in the project)\"\n\n        gicdata = gp.GICParser(self.settings, self.logger)\n        return gicdata.psse_graph\n\n    def define_bus_subsystems(self):\n        \"Defines a bussystem in the loaded PSSE model\"\n\n        bus_subsystems_dict = {}\n        bus_subsystems = self.get_bus_indices()\n        # valid bus subsystem ID. Valid bus subsystem IDs range from 0 to 11 (PSSE documentation)\n        if len(bus_subsystems) &gt; 12:\n            msg = \"Number of subsystems can not be more that 12. See PSSE documentation\"\n            raise Exception(msg)\n\n        all_subsysten_buses = []\n        for i, buses in enumerate(bus_subsystems):\n            if not buses:\n                continue\n\n            all_subsysten_buses.extend(buses)\n            ierr = self.psse.bsysinit(i)\n            if ierr:\n                msg = \"Failed to create bus subsystem chosen buses.\"\n                raise Exception(msg)\n            else:\n                self.logger.debug(f'Bus subsystem \"{i}\" created')\n\n            ierr = self.psse.bsys(sid=i, numbus=len(buses), buses=buses)\n            if ierr:\n                msg = \"Failed to add buses to bus subsystem.\"\n                raise Exception(msg)\n            else:\n                bus_subsystems_dict[i] = buses\n                self.logger.debug(f'Buses {buses} added to subsystem \"{i}\"')\n        all_subsysten_buses = [str(x) for x in all_subsysten_buses]\n        return bus_subsystems_dict, all_subsysten_buses\n\n    def get_bus_indices(self):\n        \"Retuens bus indices for bus subsystems\"\n\n        if self.settings.bus_subsystems.from_file:\n            bus_file = self.settings.bus_subsystems.bus_file\n            bus_info = pd.read_csv(bus_file, index_col=None)\n            bus_info = bus_info.values\n            _, n_cols = bus_info.shape\n            bus_data = []\n            for col in range(n_cols):\n                data = [int(x) for x in bus_info[:, col] if not np.isnan(x)]\n                bus_data.append(data)\n        else:\n            bus_data = self.settings.bus_subsystems.bus_subsystem_list\n        return bus_data\n\n    def read_settings(self, settings_toml_path):\n        \"Read the user defined settings\"\n\n        settings_text = \"\"\n        f = open(settings_toml_path)\n        text = settings_text.join(f.readlines())\n        toml_data = toml.loads(text)\n        toml_data = {str(k): (str(v) if isinstance(v, str) else v) for k, v in toml_data.items()}\n        f.close()\n        return toml_data\n\n    def run(self):\n        \"Launches the simulation\"\n\n        if self.sim.initialization_complete:\n            if self.settings.plots and self.settings.plots.enable_dynamic_plots:\n                bokeh_server_proc = subprocess.Popen([\"bokeh\", \"serve\"], stdout=subprocess.PIPE)\n            else:\n                bokeh_server_proc = None\n            # self.initialize_loads()\n            self.logger.debug(\n                f\"Running dynamic simulation for time {self.settings.simulation.simulation_time.total_seconds()} sec\"\n            )\n            total_simulation_time = self.settings.simulation.simulation_time.total_seconds()\n            t = 0\n            while True:\n                self.step(t)\n                if self.inc_time:\n                    t += self.settings.simulation.simulation_step_resolution.total_seconds()\n                if t &gt;= total_simulation_time:\n                    break\n\n            self.psse.pssehalt_2()\n            if not self.export_settings.export_results_using_channels:\n                self.results.export_results()\n            else:\n                self.sim.export()\n\n            if bokeh_server_proc is not None:\n                bokeh_server_proc.terminate()\n        else:\n            self.logger.error(\"Run init() command to initialize models before running the simulation\")\n\n    def get_bus_ids(self):\n        \"Returns bus IDs\"\n\n        ierr, iarray = self.psse.abusint(-1, 1, \"NUMBER\")\n        assert ierr == 0, f\"Error code: {ierr}\"\n        return iarray\n\n    def step(self, t):\n        \"Steps through a single simulation time step. Is called iteratively to increment the simualtion\"\n\n        self.update_contingencies(t)\n        if self.settings.simulation.use_profile_manager:\n            self.pm.update()\n        ctime = time.time() - self.simStartTime\n        self.logger.debug(f\"Simulation time: {t} seconds; Run time: {ctime}; pyPSSE time: {self.sim.get_time()}\")\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            if self.settings.helics.create_subscriptions:\n                self.update_subscriptions()\n                self.logger.debug(f\"Time requested: {t}\")\n                self.inc_time, helics_time = self.update_federate_time(t)\n                self.logger.debug(f\"Time granted: {helics_time}\")\n\n        if self.inc_time:\n            self.sim.step(t)\n        else:\n            self.sim.resolve_step(t)\n\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            self.publish_data()\n        if self.export_settings.defined_subsystems_only:\n            curr_results = self.sim.read_subsystems(self.exp_vars, self.all_subsysten_buses)\n        else:\n            curr_results = self.sim.read_subsystems(self.exp_vars, self.raw_data.buses)\n            # curr_results = self.sim.read(self.exp_vars, self.raw_data)\n\n        if not USING_NAERM:\n            if self.inc_time and not self.export_settings.export_results_using_channels:\n                self.results.update(curr_results, t, self.sim.get_time())\n\n        return curr_results\n\n    def update_subscriptions(self):\n        \"Updates subscriptions (co-simulation mode only)\"\n\n        self.hi.subscribe()\n\n    def update_federate_time(self, t):\n        \"Makes a time request to teh HELICS broker (co-simulation mode only)\"\n\n        inc_time, curr_time = self.hi.request_time(t)\n        return inc_time, curr_time\n\n    def publish_data(self):\n        \"Updates publications (co-simulation mode only)\"\n        self.hi.publish()\n\n    def get_results(self, params):\n        \"Returns queried simulation results\"\n        self.exp_vars = self.results.update_export_variables(params)\n        curr_results = (\n            self.sim.read_subsystems(self.exp_vars, self.all_subsysten_buses)\n            if self.export_settings.defined_subsystems_only\n            else self.sim.read_subsystems(self.exp_vars, self.raw_data.buses)\n        )\n        # class_name = list(params.keys())[0]\n        return curr_results\n        # restruct_results = self.restructure_results(curr_results, class_name)\n        # return curr_results, restruct_results\n\n    def restructure_results(self, results, class_name):\n        \"Restructure results for the improved user experience\"\n\n        # c_names = []\n        p_names = []\n        data = []\n        bud_id = []\n        uuid = []\n        ckt_id = []\n        to_bus = []\n        to_bus2 = []\n        for class_ppty, v_dict in results.items():\n            if len(class_ppty.split(\"_\")) == 3:\n                c_name = class_ppty.split(\"_\")[0] + \"_\" + class_ppty.split(\"_\")[1]\n                p_name = class_ppty.split(\"_\")[2]\n            else:\n                c_name = class_ppty.split(\"_\")[0]\n                p_name = class_ppty.split(\"_\")[1]\n            if c_name == class_name:\n                # c_names.append(c_name)\n                p_names.append(p_name)\n                keys = list(v_dict.keys())\n                bud_id = []\n                ckt_id = []\n                uuid = []\n                to_bus = []\n                to_bus2 = []\n\n                for k_raw in keys:\n                    k = str(k_raw)\n                    if \"_\" in k:\n                        if len(k.split(\"_\")) == 2:\n                            bud_id.append(k.split(\"_\")[1])\n                            uuid.append(k.split(\"_\")[0])\n                        if len(k.split(\"_\")) == 3:\n                            bud_id.append(k.split(\"_\")[0])\n                            ckt_id.append(k.split(\"_\")[2])\n                            to_bus.append(k.split(\"_\")[1])\n                        if len(k.split(\"_\")) == 4:\n                            bud_id.append(k.split(\"_\")[0])\n                            ckt_id.append(k.split(\"_\")[3])\n                            to_bus.append(k.split(\"_\")[1])\n                            to_bus2.append(k.split(\"_\")[2])\n                    else:\n                        bud_id.append(k)\n                data.append(list(v_dict.values()))\n        return p_names, bud_id, uuid, to_bus, to_bus2, ckt_id, data\n\n    def get_bus_data(self, t, bus_subsystem_id):\n        \"Return bus data\"\n\n        bus_data_formated = []\n        ierr, rarray = self.psse.abusint(bus_subsystem_id, 1, \"NUMBER\")\n        assert ierr == 0, f\"Error code: {ierr}\"\n        bus_numbers = rarray[0]\n        ierr, bus_data = self.psse.abusreal(bus_subsystem_id, 1, [\"PU\", \"ANGLED\", \"MISMATCH\"])\n        assert ierr == 0, f\"Error code: {ierr}\"\n        if ierr:\n            self.logger.warning(f\"Unable to read voltage data at time {t} (seconds)\")\n        bus_data = np.array(bus_data)\n\n        for i, j in enumerate(bus_numbers):\n            bus_data_formated.append([j, bus_data[0, i], bus_data[1, i], bus_data[2, i]])\n        return bus_data_formated\n\n    def build_contingencies(self):\n        \"Builds user defined contengingies\"\n\n        contingencies = c.build_contingencies(self.psse, self.settings, self.logger)\n        return contingencies\n\n    def update_contingencies(self, t):\n        \"Updates contingencies during the simualtion run\"\n        for contingency in self.contingencies:\n            contingency.update(t)\n\n    def __del__(self):\n        if hasattr(self, \"PSSE\"):\n            self.psse.pssehalt_2()\n</code></pre> <p>This class defines the structure of a PyPSSE project</p> Source code in <code>pypsse\\project.py</code> <pre><code>class Project:\n    \"This class defines the structure of a PyPSSE project\"\n\n    def __init__(self):\n        logging.root.setLevel(\"DEBUG\")\n        self.basepath = os.path.dirname(pypsse.__path__[0])\n        pass\n\n    def create(\n        self,\n        path,\n        project_name,\n        psse_folder,\n        settings,\n        export_settings,\n        profile_store,\n        profile_mapping,\n        overwrite=True,\n        autofill=True,\n    ):\n        \"The methods creates a new PyPSSE project\"\n        if os.path.exists(path):\n            self._create_folders(path, project_name, overwrite)\n            u_settings, u_exports = self._update_settings(settings, export_settings)\n            u_settings[\"Simulation\"][\"Project Path\"] = os.path.join(path, project_name)\n\n            psse_files = self._copy_psse_project_files(path, project_name, psse_folder)\n            if autofill:\n                u_settings = self._autofill_settings(\n                    psse_files, u_settings, path, project_name, profile_store, profile_mapping\n                )\n            self._write_setting_files(path, project_name, u_settings, u_exports)\n\n        else:\n            msg = f\"Path provided does not exist ({path})\"\n            raise Exception(msg)\n\n    def _autofill_settings(self, psse_files, u_settings, path, project_name, profile_store, profile_mapping):\n        \"The method auto populates fields for a new PyPSSE project\"\n        psse_path = os.path.join(path, project_name, \"Case_study\")\n\n        u_settings = self._set_file(\"sav\", \"Case study\", psse_files, u_settings, psse_path)\n        u_settings = self._set_file(\"raw\", \"Raw file\", psse_files, u_settings, psse_path)\n        u_settings = self._set_file(\"snp\", \"Snp file\", psse_files, u_settings, psse_path)\n        u_settings = self._set_file(\"dyr\", \"Dyr file\", psse_files, u_settings, psse_path)\n        u_settings = self._set_file(\"gic\", \"GIC file\", psse_files, u_settings, psse_path)\n        u_settings = self._set_file(\"rwm\", \"Rwm file\", psse_files, u_settings, psse_path)\n        if \"dll\" in psse_files:\n            u_settings[\"Simulation\"][\"User models\"] = psse_files[\"dll\"]\n            logging.info(f\"Settings:User models={psse_files['dll']}\")\n        else:\n            logging.info(f\"No DLL files found in path {psse_path}\")\n        if \"idv\" in psse_files:\n            u_settings[\"Simulation\"][\"Setup files\"] = psse_files[\"idv\"]\n            logging.info(\n                f\"Settings:Setup files={psse_files['idv']}\"\n                f\"\\nSequence of IDV setup files is important. Manually change in TOML file f needed\"\n            )\n        else:\n            logging.info(f\"No IDV files found in path {psse_path}\")\n\n        if \"csv\" in psse_files:\n            subscripton_file = self._find_subscriptions_file(psse_files[\"csv\"], psse_path)\n            if subscripton_file:\n                u_settings[\"Simulation\"][\"Subscriptions file\"] = subscripton_file\n                logging.info(f\"Settings:Subscriptions file={subscripton_file}\")\n            else:\n                u_settings = self._create_default_sub_file(psse_path, u_settings)\n        else:\n            u_settings = self._create_default_sub_file(psse_path, u_settings)\n\n        store_path = os.path.join(path, project_name, \"Profiles\")\n        if profile_store and os.path.exists(profile_store):\n            try:\n                copy(profile_store, store_path)\n            except:\n                raise Exception(os.getcwd(), profile_store, store_path)\n        else:\n            ProfileManager(None, None, u_settings, logging)\n\n        if os.path.exists(profile_mapping):\n            copy(profile_mapping, store_path)\n        else:\n            # TODO: auto generate mapping file from bus subsystem files\n            with open(os.path.join(store_path, DEFAULT_PROFILE_MAPPING_FILENAME), \"w\") as _:\n                pass\n\n        return u_settings\n\n    def _create_default_sub_file(self, psse_path, u_settings):\n        \"Method creates a subscription file for the HELICS interface\"\n        data = pd.DataFrame({}, columns=list(SUBSCRIPTION_FIELDS))\n        data.to_csv(os.path.join(psse_path, DEFAULT_SUBSCRIPTION_FILENAMES), index=False)\n        logging.info(\n            f\"No valid HELICS subscriptions file found in path {psse_path}.\"\n            f\"Creating empty {DEFAULT_SUBSCRIPTION_FILENAMES} file\"\n        )\n        u_settings[\"Simulation\"][\"Subscriptions file\"] = DEFAULT_SUBSCRIPTION_FILENAMES\n        return u_settings\n\n    def _find_subscriptions_file(self, file_list, psse_path):\n        \"Validates an existing subscription file for the HELICS interface\"\n        s_file = None\n        for fi in file_list:\n            f_path = os.path.join(psse_path, fi)\n            with open(f_path) as f:\n                line = f.readline()\n            l_data = set(line.split(\",\"))\n            if SUBSCRIPTION_FIELDS.issubset(l_data):\n                s_file = fi\n                break\n        return s_file\n\n    def _set_file(self, f_type, key, psse_files, settings_dict, psse_path):\n        if f_type in psse_files:\n            relevent_files = psse_files[f_type]\n            settings_dict[\"Simulation\"][key] = relevent_files[0]\n            logging.info(f\"Settings:{key}={relevent_files[0]}\")\n            if len(relevent_files) &gt; 1:\n                logging.warning(\n                    f\"More than one file with extension {f_type} exist.\"\n                    f\"\\nFiles found: {relevent_files}\"\n                    f\"\\nManually update the settings toml file\"\n                )\n        else:\n            logging.warning(f\"No file with extension '{f_type}' in path {psse_path}\")\n        return settings_dict\n\n    def _psse_project_file_dict(self, path):\n        \"Creates a mapping of all PyPSSE project files\"\n        file_dict = {}\n        for _, _, files in os.walk(path):\n            for file in files:\n                _, ext = file.split(\".\")\n                if ext not in file_dict:\n                    file_dict[ext.lower()] = [file]\n                else:\n                    file_dict[ext.lower()].append(file)\n        return file_dict\n\n    def _copy_psse_project_files(self, path, project_name, psse_folder):\n        \"Copies PSSE file to the new project folder\"\n        if os.path.exists(psse_folder):\n            new_path = os.path.join(path, project_name, \"Case_study\")\n            copy_tree(psse_folder, os.path.join(path, new_path))\n            psse_files = self._psse_project_file_dict(new_path)\n        else:\n            msg = f\"PSSE project path does not exist. ({psse_folder}) {os.getcwd()}\"\n            raise Exception(msg)\n        return psse_files\n\n    def _update_settings(self, settings, export_settings):\n        \"Unables update of an existing settings file\"\n        default_settings = toml.load(os.path.join(self.basepath, \"pypsse\", \"defaults\", SIMULATION_SETTINGS_FILENAME))\n        default_exports = toml.load(os.path.join(self.basepath, \"pypsse\", \"defaults\", EXPORTS_SETTINGS_FILENAME))\n        default_settings.update(settings)\n        default_exports.update(export_settings)\n        return default_settings, default_exports\n\n    def _write_setting_files(self, path, project_name, settings, exports):\n        \"Creats a new settings file\"\n        with open(os.path.join(path, project_name, \"Settings\", SIMULATION_SETTINGS_FILENAME), \"w\") as f:\n            toml.dump(settings, f)\n\n        with open(os.path.join(path, project_name, \"Settings\", EXPORTS_SETTINGS_FILENAME), \"w\") as f:\n            toml.dump(exports, f)\n\n    def _create_folders(self, path, project_name, overwrite):\n        \"Creates folder structure for a new project. Older project can be over-written\"\n        project_path = os.path.join(path, project_name)\n        if os.path.exists(project_path) and overwrite:\n            rmtree(project_path)\n        elif os.path.exists(project_path) and not overwrite:\n            msg = \"Project already exists. Set 'overwrite' to true to overwrite existing project.\"\n            raise Exception(msg)\n\n        self.make_dir(project_path)\n        for f in PROJECT_FOLDERS:\n            self.make_dir(os.path.join(project_path, f))\n\n    def make_dir(self, path):\n        # try:\n        os.mkdir(path)\n</code></pre> <p>Class defination for the simulation result container</p> Source code in <code>pypsse\\result_container.py</code> <pre><code>class Container:\n    \"Class defination for the simulation result container\"\n\n    BULK_WRITE_MODES = [m.value for m in BulkWriteModes]\n    STREAMED_WRITE_MODES = [m.value for m in StreamedWriteModes]\n\n    def __init__(self, settings: SimulationSettings, export_settings: ExportAssetTypes):\n        \"Sets up the result container object\"\n\n        export__list = [m.value for m in ModelTypes]\n        self.export_path = settings.simulation.project_path / EXPORTS_FOLDER\n        self.export_settings = export_settings\n        self.settings = settings\n        self.results = {}\n        self.export_vars = {}\n        for class_name in export__list:\n            mapped_name = MAPPED_CLASS_NAMES[class_name.lower()]\n            variables = getattr(export_settings, class_name.lower())\n            if variables:\n                for variable in variables:\n                    self.results[f\"{mapped_name}_{variable.value}\"] = None\n                    if mapped_name not in self.export_vars:\n                        self.export_vars[mapped_name] = []\n                    self.export_vars[mapped_name].append(variable.value)\n\n        time_steps = int(\n            self.settings.simulation.simulation_time.total_seconds()\n            / self.settings.simulation.simulation_step_resolution.total_seconds()\n        )\n        if self.export_settings.file_format not in self.BULK_WRITE_MODES:\n            self.dataWriter = DataWriter(self.export_path, export_settings.file_format.value, time_steps)\n\n    def update_export_variables(self, params):\n        \"\"\"Updates the container with current system state.\n        Method is called iteratively to store results as a simulation executes\"\"\"\n\n        export__list = [m.value for m in ModelTypes]\n        self.results = {}\n        self.export_vars = {}\n\n        class_assets = ExportAssetTypes.validate(params) if params else self.export_settings\n\n        for class_name in export__list:\n            if class_name in params:\n                mapped_name = MAPPED_CLASS_NAMES[class_name]\n                variables = getattr(class_assets, class_name)\n                if variables:\n                    for variable in variables:\n                        self.results[f\"{mapped_name}_{variable.value}\"] = None\n                        if mapped_name not in self.export_vars:\n                            self.export_vars[mapped_name] = []\n                        self.export_vars[mapped_name].append(variable.value)\n\n        return self.export_vars\n\n    def get_export_variables(self):\n        \"Queries and return results from the current timestep\"\n        return self.export_vars\n\n    def update(self, bus_data, index, time):\n        \"Updates the results cotainer\"\n        if self.export_settings.file_format not in self.BULK_WRITE_MODES:\n            if self.settings.helics:\n                file_name = self.settings.helics.federate_name\n            else:\n                file_name = \"simulation_results\"\n            self.dataWriter.write(time, bus_data)\n        else:\n            for variable_name, _ in bus_data.items():\n                if not isinstance(self.results[f\"{variable_name}\"], pd.DataFrame):\n                    self.results[f\"{variable_name}\"] = pd.DataFrame(bus_data[variable_name], index=[0])\n                else:\n                    df1 = self.results[f\"{variable_name}\"]\n                    df2 = pd.DataFrame.from_dict([bus_data[variable_name]])\n                    concatenated = pd.concat([df1, df2])\n                    self.results[f\"{variable_name}\"] = concatenated\n\n    def export_results(self):\n        \"Exports all results stored to an external file.\"\n        if self.export_settings.file_format in self.BULK_WRITE_MODES:\n            for df_name, df in self.results.items():\n                export_path = (\n                    self.settings.simulation.project_path\n                    / EXPORTS_FOLDER\n                    / f'{df_name}.{self.export_settings[\"Write format\"]}'\n                )\n                if self.export_settings.file_format == BulkWriteModes.CSV:\n                    if isinstance(df, pd.DataFrame):\n                        df.to_csv(export_path)\n                elif self.export_settings.file_format == BulkWriteModes.PKL:\n                    df.to_pickle(export_path)\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.__init__","title":"<code>__init__(settings_toml_path='', psse_path='')</code>","text":"<p>Load a valid PyPSSE project and sets up simulation</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def __init__(self, settings_toml_path=\"\", psse_path=\"\"):\n    \"Load a valid PyPSSE project and sets up simulation\"\n\n    settings = self.read_settings(settings_toml_path)\n    self.settings = SimulationSettings.validate(settings)\n\n    export_settings_path = self.settings.simulation.project_path / EXPORTS_SETTINGS_FILENAME\n    assert export_settings_path.exists(), f\"{export_settings_path} does nor exist\"\n    export_settings = self.read_settings(export_settings_path)\n    self.export_settings = ExportFileOptions.validate(export_settings)\n\n    log_path = os.path.join(self.settings.simulation.project_path, LOGS_FOLDER)\n    self.logger = logger.get_logger(\"pyPSSE\", log_path, logger_options=self.settings.log)\n    self.logger.debug(\"Starting PSSE instance\")\n\n    if psse_path != \"\" and Path(psse_path).exists():\n        self.settings.simulation.psse_path = Path(psse_path)\n        sys.path.append(psse_path)\n        os.environ[\"PATH\"] += \";\" + psse_path\n    else:\n        sys.path.append(str(self.settings.simulation.psse_path))\n        os.environ[\"PATH\"] += \";\" + str(self.settings.simulation.psse_path)\n\n    try:\n        n_bus = 200000\n        if \"psse34\" in str(self.settings.simulation.psse_path).lower():\n            self.logger.debug(\"Instantiating psse version 34\")\n            import psse34\n        elif \"psse35\" in str(self.settings.simulation.psse_path).lower():\n            self.logger.debug(\"Instantiating psse version 35\")\n            import psse35\n        else:\n            self.logger.debug(\"Instantiating psse version 36\")\n            import psse36\n        import dyntools\n        import psspy\n\n        self.dyntools = dyntools\n        self.psse = psspy\n        # self.logger.debug('Initializing PSS/E. connecting to license server')\n        ierr = self.psse.psseinit(n_bus)\n        assert ierr == 0, f\"Error code: {ierr}\"\n        self.psse.psseinit(n_bus)\n        self.initComplete = True\n        self.message = \"success\"\n\n        self.start_simulation()\n        self.init()\n    except:\n        msg = \"A valid PSS/E license not found. License may currently be in use.\"\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.build_contingencies","title":"<code>build_contingencies()</code>","text":"<p>Builds user defined contengingies</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def build_contingencies(self):\n    \"Builds user defined contengingies\"\n\n    contingencies = c.build_contingencies(self.psse, self.settings, self.logger)\n    return contingencies\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.define_bus_subsystems","title":"<code>define_bus_subsystems()</code>","text":"<p>Defines a bussystem in the loaded PSSE model</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def define_bus_subsystems(self):\n    \"Defines a bussystem in the loaded PSSE model\"\n\n    bus_subsystems_dict = {}\n    bus_subsystems = self.get_bus_indices()\n    # valid bus subsystem ID. Valid bus subsystem IDs range from 0 to 11 (PSSE documentation)\n    if len(bus_subsystems) &gt; 12:\n        msg = \"Number of subsystems can not be more that 12. See PSSE documentation\"\n        raise Exception(msg)\n\n    all_subsysten_buses = []\n    for i, buses in enumerate(bus_subsystems):\n        if not buses:\n            continue\n\n        all_subsysten_buses.extend(buses)\n        ierr = self.psse.bsysinit(i)\n        if ierr:\n            msg = \"Failed to create bus subsystem chosen buses.\"\n            raise Exception(msg)\n        else:\n            self.logger.debug(f'Bus subsystem \"{i}\" created')\n\n        ierr = self.psse.bsys(sid=i, numbus=len(buses), buses=buses)\n        if ierr:\n            msg = \"Failed to add buses to bus subsystem.\"\n            raise Exception(msg)\n        else:\n            bus_subsystems_dict[i] = buses\n            self.logger.debug(f'Buses {buses} added to subsystem \"{i}\"')\n    all_subsysten_buses = [str(x) for x in all_subsysten_buses]\n    return bus_subsystems_dict, all_subsysten_buses\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.get_bus_data","title":"<code>get_bus_data(t, bus_subsystem_id)</code>","text":"<p>Return bus data</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def get_bus_data(self, t, bus_subsystem_id):\n    \"Return bus data\"\n\n    bus_data_formated = []\n    ierr, rarray = self.psse.abusint(bus_subsystem_id, 1, \"NUMBER\")\n    assert ierr == 0, f\"Error code: {ierr}\"\n    bus_numbers = rarray[0]\n    ierr, bus_data = self.psse.abusreal(bus_subsystem_id, 1, [\"PU\", \"ANGLED\", \"MISMATCH\"])\n    assert ierr == 0, f\"Error code: {ierr}\"\n    if ierr:\n        self.logger.warning(f\"Unable to read voltage data at time {t} (seconds)\")\n    bus_data = np.array(bus_data)\n\n    for i, j in enumerate(bus_numbers):\n        bus_data_formated.append([j, bus_data[0, i], bus_data[1, i], bus_data[2, i]])\n    return bus_data_formated\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.get_bus_ids","title":"<code>get_bus_ids()</code>","text":"<p>Returns bus IDs</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def get_bus_ids(self):\n    \"Returns bus IDs\"\n\n    ierr, iarray = self.psse.abusint(-1, 1, \"NUMBER\")\n    assert ierr == 0, f\"Error code: {ierr}\"\n    return iarray\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.get_bus_indices","title":"<code>get_bus_indices()</code>","text":"<p>Retuens bus indices for bus subsystems</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def get_bus_indices(self):\n    \"Retuens bus indices for bus subsystems\"\n\n    if self.settings.bus_subsystems.from_file:\n        bus_file = self.settings.bus_subsystems.bus_file\n        bus_info = pd.read_csv(bus_file, index_col=None)\n        bus_info = bus_info.values\n        _, n_cols = bus_info.shape\n        bus_data = []\n        for col in range(n_cols):\n            data = [int(x) for x in bus_info[:, col] if not np.isnan(x)]\n            bus_data.append(data)\n    else:\n        bus_data = self.settings.bus_subsystems.bus_subsystem_list\n    return bus_data\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.get_results","title":"<code>get_results(params)</code>","text":"<p>Returns queried simulation results</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def get_results(self, params):\n    \"Returns queried simulation results\"\n    self.exp_vars = self.results.update_export_variables(params)\n    curr_results = (\n        self.sim.read_subsystems(self.exp_vars, self.all_subsysten_buses)\n        if self.export_settings.defined_subsystems_only\n        else self.sim.read_subsystems(self.exp_vars, self.raw_data.buses)\n    )\n    # class_name = list(params.keys())[0]\n    return curr_results\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.init","title":"<code>init()</code>","text":"<p>Initializes the model</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def init(self):\n    \"Initializes the model\"\n\n    self.sim.init(self.bus_subsystems)\n\n    if self.settings.simulation.use_profile_manager:\n        self.pm = ProfileManager(None, self.sim, self.settings, self.logger)\n        self.pm.setup_profiles()\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        self.hi.enter_execution_mode()\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.parse_gic_file","title":"<code>parse_gic_file()</code>","text":"<p>Parses the GIC file (if included in the project)</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def parse_gic_file(self):\n    \"Parses the GIC file (if included in the project)\"\n\n    gicdata = gp.GICParser(self.settings, self.logger)\n    return gicdata.psse_graph\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.publish_data","title":"<code>publish_data()</code>","text":"<p>Updates publications (co-simulation mode only)</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def publish_data(self):\n    \"Updates publications (co-simulation mode only)\"\n    self.hi.publish()\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.read_settings","title":"<code>read_settings(settings_toml_path)</code>","text":"<p>Read the user defined settings</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def read_settings(self, settings_toml_path):\n    \"Read the user defined settings\"\n\n    settings_text = \"\"\n    f = open(settings_toml_path)\n    text = settings_text.join(f.readlines())\n    toml_data = toml.loads(text)\n    toml_data = {str(k): (str(v) if isinstance(v, str) else v) for k, v in toml_data.items()}\n    f.close()\n    return toml_data\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.restructure_results","title":"<code>restructure_results(results, class_name)</code>","text":"<p>Restructure results for the improved user experience</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def restructure_results(self, results, class_name):\n    \"Restructure results for the improved user experience\"\n\n    # c_names = []\n    p_names = []\n    data = []\n    bud_id = []\n    uuid = []\n    ckt_id = []\n    to_bus = []\n    to_bus2 = []\n    for class_ppty, v_dict in results.items():\n        if len(class_ppty.split(\"_\")) == 3:\n            c_name = class_ppty.split(\"_\")[0] + \"_\" + class_ppty.split(\"_\")[1]\n            p_name = class_ppty.split(\"_\")[2]\n        else:\n            c_name = class_ppty.split(\"_\")[0]\n            p_name = class_ppty.split(\"_\")[1]\n        if c_name == class_name:\n            # c_names.append(c_name)\n            p_names.append(p_name)\n            keys = list(v_dict.keys())\n            bud_id = []\n            ckt_id = []\n            uuid = []\n            to_bus = []\n            to_bus2 = []\n\n            for k_raw in keys:\n                k = str(k_raw)\n                if \"_\" in k:\n                    if len(k.split(\"_\")) == 2:\n                        bud_id.append(k.split(\"_\")[1])\n                        uuid.append(k.split(\"_\")[0])\n                    if len(k.split(\"_\")) == 3:\n                        bud_id.append(k.split(\"_\")[0])\n                        ckt_id.append(k.split(\"_\")[2])\n                        to_bus.append(k.split(\"_\")[1])\n                    if len(k.split(\"_\")) == 4:\n                        bud_id.append(k.split(\"_\")[0])\n                        ckt_id.append(k.split(\"_\")[3])\n                        to_bus.append(k.split(\"_\")[1])\n                        to_bus2.append(k.split(\"_\")[2])\n                else:\n                    bud_id.append(k)\n            data.append(list(v_dict.values()))\n    return p_names, bud_id, uuid, to_bus, to_bus2, ckt_id, data\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.run","title":"<code>run()</code>","text":"<p>Launches the simulation</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def run(self):\n    \"Launches the simulation\"\n\n    if self.sim.initialization_complete:\n        if self.settings.plots and self.settings.plots.enable_dynamic_plots:\n            bokeh_server_proc = subprocess.Popen([\"bokeh\", \"serve\"], stdout=subprocess.PIPE)\n        else:\n            bokeh_server_proc = None\n        # self.initialize_loads()\n        self.logger.debug(\n            f\"Running dynamic simulation for time {self.settings.simulation.simulation_time.total_seconds()} sec\"\n        )\n        total_simulation_time = self.settings.simulation.simulation_time.total_seconds()\n        t = 0\n        while True:\n            self.step(t)\n            if self.inc_time:\n                t += self.settings.simulation.simulation_step_resolution.total_seconds()\n            if t &gt;= total_simulation_time:\n                break\n\n        self.psse.pssehalt_2()\n        if not self.export_settings.export_results_using_channels:\n            self.results.export_results()\n        else:\n            self.sim.export()\n\n        if bokeh_server_proc is not None:\n            bokeh_server_proc.terminate()\n    else:\n        self.logger.error(\"Run init() command to initialize models before running the simulation\")\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.start_simulation","title":"<code>start_simulation()</code>","text":"<p>Starts a loaded simulation</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def start_simulation(self):\n    \"Starts a loaded simulation\"\n\n    self.hi = None\n    self.simStartTime = time.time()\n\n    # ** Initialize PSSE modules\n\n    if self.settings.simulation.case_study.exists():\n        self.psse.case(str(self.settings.simulation.case_study))\n    elif self.settings.simulation.raw_file.exists():\n        self.psse.read(0, str(self.settings.simulation.raw_file))\n    else:\n        msg = \"Please pass a RAW or SAV file in the settings dictionary\"\n        raise Exception(msg)\n\n    self.logger.info(f\"Trying to read a file &gt;&gt;{self.settings.simulation.case_study}\")\n    self.raw_data = rd.Reader(self.psse, self.logger)\n    (\n        self.bus_subsystems,\n        self.all_subsysten_buses,\n    ) = self.define_bus_subsystems()\n\n    if self.export_settings.defined_subsystems_only:\n        valid_buses = self.all_subsysten_buses\n    else:\n        valid_buses = self.raw_data.buses\n\n    self.sim = sc.sim_controller(\n        self.psse,\n        self.dyntools,\n        self.settings,\n        self.export_settings,\n        self.logger,\n        valid_buses,\n        self.raw_data,\n    )\n\n    self.contingencies = self.build_contingencies()\n\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        if self.settings.simulation.simulation_mode in [\n            SimulationModes.DYNAMIC,\n            SimulationModes.SNAP,\n        ]:\n            ...\n        self.hi = HelicsInterface(\n            self.psse,\n            self.sim,\n            self.settings,\n            self.export_settings,\n            self.bus_subsystems,\n            self.logger,\n        )\n        self.publications = self.hi.register_publications(self.bus_subsystems)\n        if self.settings.helics.create_subscriptions:\n            self.subscriptions = self.hi.register_subscriptions()\n\n    if self.settings.simulation.gic_file:\n        self.network_graph = self.parse_gic_file()\n        self.bus_ids = self.network_graph.nodes.keys()\n    else:\n        self.network_graph = None\n\n    self.results = Container(self.settings, self.export_settings)\n    self.exp_vars = self.results.get_export_variables()\n    self.inc_time = True\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.step","title":"<code>step(t)</code>","text":"<p>Steps through a single simulation time step. Is called iteratively to increment the simualtion</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def step(self, t):\n    \"Steps through a single simulation time step. Is called iteratively to increment the simualtion\"\n\n    self.update_contingencies(t)\n    if self.settings.simulation.use_profile_manager:\n        self.pm.update()\n    ctime = time.time() - self.simStartTime\n    self.logger.debug(f\"Simulation time: {t} seconds; Run time: {ctime}; pyPSSE time: {self.sim.get_time()}\")\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        if self.settings.helics.create_subscriptions:\n            self.update_subscriptions()\n            self.logger.debug(f\"Time requested: {t}\")\n            self.inc_time, helics_time = self.update_federate_time(t)\n            self.logger.debug(f\"Time granted: {helics_time}\")\n\n    if self.inc_time:\n        self.sim.step(t)\n    else:\n        self.sim.resolve_step(t)\n\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        self.publish_data()\n    if self.export_settings.defined_subsystems_only:\n        curr_results = self.sim.read_subsystems(self.exp_vars, self.all_subsysten_buses)\n    else:\n        curr_results = self.sim.read_subsystems(self.exp_vars, self.raw_data.buses)\n        # curr_results = self.sim.read(self.exp_vars, self.raw_data)\n\n    if not USING_NAERM:\n        if self.inc_time and not self.export_settings.export_results_using_channels:\n            self.results.update(curr_results, t, self.sim.get_time())\n\n    return curr_results\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.update_contingencies","title":"<code>update_contingencies(t)</code>","text":"<p>Updates contingencies during the simualtion run</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def update_contingencies(self, t):\n    \"Updates contingencies during the simualtion run\"\n    for contingency in self.contingencies:\n        contingency.update(t)\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.update_federate_time","title":"<code>update_federate_time(t)</code>","text":"<p>Makes a time request to teh HELICS broker (co-simulation mode only)</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def update_federate_time(self, t):\n    \"Makes a time request to teh HELICS broker (co-simulation mode only)\"\n\n    inc_time, curr_time = self.hi.request_time(t)\n    return inc_time, curr_time\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.update_subscriptions","title":"<code>update_subscriptions()</code>","text":"<p>Updates subscriptions (co-simulation mode only)</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def update_subscriptions(self):\n    \"Updates subscriptions (co-simulation mode only)\"\n\n    self.hi.subscribe()\n</code></pre>"},{"location":"code/reference/#pypsse.project.Project.create","title":"<code>create(path, project_name, psse_folder, settings, export_settings, profile_store, profile_mapping, overwrite=True, autofill=True)</code>","text":"<p>The methods creates a new PyPSSE project</p> Source code in <code>pypsse\\project.py</code> <pre><code>def create(\n    self,\n    path,\n    project_name,\n    psse_folder,\n    settings,\n    export_settings,\n    profile_store,\n    profile_mapping,\n    overwrite=True,\n    autofill=True,\n):\n    \"The methods creates a new PyPSSE project\"\n    if os.path.exists(path):\n        self._create_folders(path, project_name, overwrite)\n        u_settings, u_exports = self._update_settings(settings, export_settings)\n        u_settings[\"Simulation\"][\"Project Path\"] = os.path.join(path, project_name)\n\n        psse_files = self._copy_psse_project_files(path, project_name, psse_folder)\n        if autofill:\n            u_settings = self._autofill_settings(\n                psse_files, u_settings, path, project_name, profile_store, profile_mapping\n            )\n        self._write_setting_files(path, project_name, u_settings, u_exports)\n\n    else:\n        msg = f\"Path provided does not exist ({path})\"\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.result_container.Container.__init__","title":"<code>__init__(settings, export_settings)</code>","text":"<p>Sets up the result container object</p> Source code in <code>pypsse\\result_container.py</code> <pre><code>def __init__(self, settings: SimulationSettings, export_settings: ExportAssetTypes):\n    \"Sets up the result container object\"\n\n    export__list = [m.value for m in ModelTypes]\n    self.export_path = settings.simulation.project_path / EXPORTS_FOLDER\n    self.export_settings = export_settings\n    self.settings = settings\n    self.results = {}\n    self.export_vars = {}\n    for class_name in export__list:\n        mapped_name = MAPPED_CLASS_NAMES[class_name.lower()]\n        variables = getattr(export_settings, class_name.lower())\n        if variables:\n            for variable in variables:\n                self.results[f\"{mapped_name}_{variable.value}\"] = None\n                if mapped_name not in self.export_vars:\n                    self.export_vars[mapped_name] = []\n                self.export_vars[mapped_name].append(variable.value)\n\n    time_steps = int(\n        self.settings.simulation.simulation_time.total_seconds()\n        / self.settings.simulation.simulation_step_resolution.total_seconds()\n    )\n    if self.export_settings.file_format not in self.BULK_WRITE_MODES:\n        self.dataWriter = DataWriter(self.export_path, export_settings.file_format.value, time_steps)\n</code></pre>"},{"location":"code/reference/#pypsse.result_container.Container.export_results","title":"<code>export_results()</code>","text":"<p>Exports all results stored to an external file.</p> Source code in <code>pypsse\\result_container.py</code> <pre><code>def export_results(self):\n    \"Exports all results stored to an external file.\"\n    if self.export_settings.file_format in self.BULK_WRITE_MODES:\n        for df_name, df in self.results.items():\n            export_path = (\n                self.settings.simulation.project_path\n                / EXPORTS_FOLDER\n                / f'{df_name}.{self.export_settings[\"Write format\"]}'\n            )\n            if self.export_settings.file_format == BulkWriteModes.CSV:\n                if isinstance(df, pd.DataFrame):\n                    df.to_csv(export_path)\n            elif self.export_settings.file_format == BulkWriteModes.PKL:\n                df.to_pickle(export_path)\n</code></pre>"},{"location":"code/reference/#pypsse.result_container.Container.get_export_variables","title":"<code>get_export_variables()</code>","text":"<p>Queries and return results from the current timestep</p> Source code in <code>pypsse\\result_container.py</code> <pre><code>def get_export_variables(self):\n    \"Queries and return results from the current timestep\"\n    return self.export_vars\n</code></pre>"},{"location":"code/reference/#pypsse.result_container.Container.update","title":"<code>update(bus_data, index, time)</code>","text":"<p>Updates the results cotainer</p> Source code in <code>pypsse\\result_container.py</code> <pre><code>def update(self, bus_data, index, time):\n    \"Updates the results cotainer\"\n    if self.export_settings.file_format not in self.BULK_WRITE_MODES:\n        if self.settings.helics:\n            file_name = self.settings.helics.federate_name\n        else:\n            file_name = \"simulation_results\"\n        self.dataWriter.write(time, bus_data)\n    else:\n        for variable_name, _ in bus_data.items():\n            if not isinstance(self.results[f\"{variable_name}\"], pd.DataFrame):\n                self.results[f\"{variable_name}\"] = pd.DataFrame(bus_data[variable_name], index=[0])\n            else:\n                df1 = self.results[f\"{variable_name}\"]\n                df2 = pd.DataFrame.from_dict([bus_data[variable_name]])\n                concatenated = pd.concat([df1, df2])\n                self.results[f\"{variable_name}\"] = concatenated\n</code></pre>"},{"location":"code/reference/#pypsse.result_container.Container.update_export_variables","title":"<code>update_export_variables(params)</code>","text":"<p>Updates the container with current system state. Method is called iteratively to store results as a simulation executes</p> Source code in <code>pypsse\\result_container.py</code> <pre><code>def update_export_variables(self, params):\n    \"\"\"Updates the container with current system state.\n    Method is called iteratively to store results as a simulation executes\"\"\"\n\n    export__list = [m.value for m in ModelTypes]\n    self.results = {}\n    self.export_vars = {}\n\n    class_assets = ExportAssetTypes.validate(params) if params else self.export_settings\n\n    for class_name in export__list:\n        if class_name in params:\n            mapped_name = MAPPED_CLASS_NAMES[class_name]\n            variables = getattr(class_assets, class_name)\n            if variables:\n                for variable in variables:\n                    self.results[f\"{mapped_name}_{variable.value}\"] = None\n                    if mapped_name not in self.export_vars:\n                        self.export_vars[mapped_name] = []\n                    self.export_vars[mapped_name].append(variable.value)\n\n    return self.export_vars\n</code></pre>"},{"location":"code/reference/#profile-management","title":"Profile management","text":""},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager","title":"<code>ProfileManager</code>","text":"<p>Implentation for the profile manager for PyPSSE. Enables attacheing profilse to all PSSE objects and associated properties</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>class ProfileManager:\n    \"\"\"Implentation for the profile manager for PyPSSE.\n    Enables attacheing profilse to all PSSE objects and associated properties\"\"\"\n\n    def __init__(self, pypsse_objects, solver, settings: SimulationSettings, logger, mode=\"r+\"):\n        self._logger = logger\n        self.solver = solver\n        self.objects = pypsse_objects\n        self.settings = settings\n\n        file_path = settings.simulation.project_path / PROFILES_FOLDER / DEFAULT_PROFILE_STORE_FILENAME\n\n        if file_path.exists():\n            self._logger.info(\"Loading existing h5 store\")\n            self.store = h5py.File(file_path, mode)\n        else:\n            self._logger.info(\"Creating new h5 store\")\n            self.store = h5py.File(file_path, \"w\")\n            for profile_group in ProfileTypes.names():\n                self.store.create_group(profile_group)\n\n    def load_data(self, file_path):\n        \"Load in external profile data\"\n        toml_dict = toml.load(file_path)\n        return toml_dict\n\n    def setup_profiles(self):\n        \"Sets up all profiles in the profile manager\"\n        mapping_path = self.settings.simulation.project_path / PROFILES_FOLDER / DEFAULT_PROFILE_MAPPING_FILENAME\n        if mapping_path.exists():\n            self.profile_mapping = self.load_data(mapping_path)\n            self.profiles = {}\n            for group, profile_map in self.profile_mapping.items():\n                if group in self.store:\n                    grp = self.store[group]\n                    for profile_name, mapping_dict in profile_map.items():\n                        if profile_name in grp:\n                            self.profiles[f\"{group}/{profile_name}\"] = tsp(grp[profile_name], self.solver, mapping_dict)\n                        else:\n                            self._logger.warning(rf\"Group {group} \\ data set {profile_name} not found in the h5 store\")\n                else:\n                    self._logger.warning(f\"Group {group} not found in the h5 store\")\n        else:\n            msg = f\"Profile_mapping.toml file does not exist in path {mapping_path}\"\n            raise Exception(msg)\n\n    def create_dataset(self, dname, p_type, data, start_time, resolution, _, info):\n        \"Craete datasets for a PyPSSE project\"\n        grp = self.store[p_type]\n        if dname not in grp:\n            sa, sa_type = self.df_to_sarray(data)\n            dset = grp.create_dataset(\n                dname, data=sa, chunks=True, compression=\"gzip\", compression_opts=4, shuffle=True, dtype=sa_type\n            )\n            self.create_metadata(dset, start_time, resolution, data, list(data.columns), info, p_type)\n        else:\n            self._logger.error(f'Data set \"{dname}\" already exists in group \"{p_type}\".')\n            msg = f'Data set \"{dname}\" already exists in group \"{p_type}\".'\n            raise Exception(msg)\n\n    def df_to_sarray(self, df):\n        \"Enables data converson\"\n\n        def make_col_type(col_type, col):\n            try:\n                if \"numpy.object_\" in str(col_type.type):\n                    maxlens = col.dropna().str.len()\n                    if maxlens.any():\n                        maxlen = maxlens.max().astype(int)\n                        col_type = (\"S%s\" % maxlen, 1)\n                    else:\n                        col_type = \"f2\"\n                return col.name, col_type\n            except:\n                raise\n\n        v = df.values\n        types = df.dtypes\n        numpy_struct_types = [make_col_type(types[col], df.loc[:, col]) for col in df.columns]\n        dtype = np.dtype(numpy_struct_types)\n        z = np.zeros(v.shape[0], dtype)\n        for i, k in enumerate(z.dtype.names):\n            # This is in case you have problems with the encoding, remove the if branch if not\n            try:\n                if dtype[i].str.startswith(\"|S\"):\n                    z[k] = df[k].str.encode(\"latin\").astype(\"S\")\n                else:\n                    z[k] = v[:, i]\n            except:\n                raise\n\n        return z, dtype\n\n    def add_profiles_from_csv(self, csv_file, name, p_type, start_time, resolution_sec=900, units=\"\", info=\"\"):\n        \"Enables profiles from existing csv files\"\n        if p_type not in PROFILE_VALIDATION:\n            msg = f\"Valid profile types are: {list(PROFILE_VALIDATION.keys())}\"\n            raise Exception(msg)\n        data = pd.read_csv(csv_file)\n        for c in data.columns:\n            if c not in PROFILE_VALIDATION[p_type]:\n                msg = f\"{c} is not valid, Valid subtypes for '{p_type}' are: {PROFILE_VALIDATION[p_type]}\"\n                raise Exception(msg)\n        self.add_profiles(name, p_type, data, start_time, resolution_sec=resolution_sec, units=units, info=info)\n\n    def add_profiles(self, name, p_type, data, start_time, resolution_sec=900, units=\"\", info=\"\"):\n        \"Adds a profile to the profile manager\"\n        if type(start_time) is not datetime.datetime:\n            msg = \"start_time should be a python datetime object\"\n            raise InvalidParameterError(msg)\n        if p_type not in ProfileTypes.names():\n            msg = f\"Valid values for p_type are {ProfileTypes.names()}\"\n            raise InvalidParameterError(msg)\n        self.create_dataset(name, p_type, data, start_time, resolution_sec, units=units, info=info)\n\n    def create_metadata(self, d_set, start_time, resolution, data, units, info, p_type):\n        \"Adds a metadata to a profile\"\n        metadata = {\n            \"sTime\": str(start_time),\n            \"eTime\": str(start_time + datetime.timedelta(seconds=resolution * len(data))),\n            \"resTime\": resolution,\n            \"npts\": len(data),\n            \"min\": data.min(),\n            \"max\": data.max(),\n            \"mean\": np.mean(data),\n            \"units\": units,\n            \"info\": info,\n            \"type\": p_type,\n        }\n        for key, value in metadata.items():\n            if isinstance(value, str):\n                value_mod = np.string_(value)\n            else:\n                value_mod = value\n            d_set.attrs[key] = value_mod\n\n    def update(self):\n        \"Returns data for the current timestep for all mapped profiles\"\n        results = {}\n        for profile_name, profile_obj in self.profiles.items():\n            result = profile_obj.update()\n            results[profile_name] = result\n        return results\n\n    def __del__(self):\n        self.store.flush()\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.add_profiles","title":"<code>add_profiles(name, p_type, data, start_time, resolution_sec=900, units='', info='')</code>","text":"<p>Adds a profile to the profile manager</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def add_profiles(self, name, p_type, data, start_time, resolution_sec=900, units=\"\", info=\"\"):\n    \"Adds a profile to the profile manager\"\n    if type(start_time) is not datetime.datetime:\n        msg = \"start_time should be a python datetime object\"\n        raise InvalidParameterError(msg)\n    if p_type not in ProfileTypes.names():\n        msg = f\"Valid values for p_type are {ProfileTypes.names()}\"\n        raise InvalidParameterError(msg)\n    self.create_dataset(name, p_type, data, start_time, resolution_sec, units=units, info=info)\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.add_profiles_from_csv","title":"<code>add_profiles_from_csv(csv_file, name, p_type, start_time, resolution_sec=900, units='', info='')</code>","text":"<p>Enables profiles from existing csv files</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def add_profiles_from_csv(self, csv_file, name, p_type, start_time, resolution_sec=900, units=\"\", info=\"\"):\n    \"Enables profiles from existing csv files\"\n    if p_type not in PROFILE_VALIDATION:\n        msg = f\"Valid profile types are: {list(PROFILE_VALIDATION.keys())}\"\n        raise Exception(msg)\n    data = pd.read_csv(csv_file)\n    for c in data.columns:\n        if c not in PROFILE_VALIDATION[p_type]:\n            msg = f\"{c} is not valid, Valid subtypes for '{p_type}' are: {PROFILE_VALIDATION[p_type]}\"\n            raise Exception(msg)\n    self.add_profiles(name, p_type, data, start_time, resolution_sec=resolution_sec, units=units, info=info)\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.create_dataset","title":"<code>create_dataset(dname, p_type, data, start_time, resolution, _, info)</code>","text":"<p>Craete datasets for a PyPSSE project</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def create_dataset(self, dname, p_type, data, start_time, resolution, _, info):\n    \"Craete datasets for a PyPSSE project\"\n    grp = self.store[p_type]\n    if dname not in grp:\n        sa, sa_type = self.df_to_sarray(data)\n        dset = grp.create_dataset(\n            dname, data=sa, chunks=True, compression=\"gzip\", compression_opts=4, shuffle=True, dtype=sa_type\n        )\n        self.create_metadata(dset, start_time, resolution, data, list(data.columns), info, p_type)\n    else:\n        self._logger.error(f'Data set \"{dname}\" already exists in group \"{p_type}\".')\n        msg = f'Data set \"{dname}\" already exists in group \"{p_type}\".'\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.create_metadata","title":"<code>create_metadata(d_set, start_time, resolution, data, units, info, p_type)</code>","text":"<p>Adds a metadata to a profile</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def create_metadata(self, d_set, start_time, resolution, data, units, info, p_type):\n    \"Adds a metadata to a profile\"\n    metadata = {\n        \"sTime\": str(start_time),\n        \"eTime\": str(start_time + datetime.timedelta(seconds=resolution * len(data))),\n        \"resTime\": resolution,\n        \"npts\": len(data),\n        \"min\": data.min(),\n        \"max\": data.max(),\n        \"mean\": np.mean(data),\n        \"units\": units,\n        \"info\": info,\n        \"type\": p_type,\n    }\n    for key, value in metadata.items():\n        if isinstance(value, str):\n            value_mod = np.string_(value)\n        else:\n            value_mod = value\n        d_set.attrs[key] = value_mod\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.df_to_sarray","title":"<code>df_to_sarray(df)</code>","text":"<p>Enables data converson</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def df_to_sarray(self, df):\n    \"Enables data converson\"\n\n    def make_col_type(col_type, col):\n        try:\n            if \"numpy.object_\" in str(col_type.type):\n                maxlens = col.dropna().str.len()\n                if maxlens.any():\n                    maxlen = maxlens.max().astype(int)\n                    col_type = (\"S%s\" % maxlen, 1)\n                else:\n                    col_type = \"f2\"\n            return col.name, col_type\n        except:\n            raise\n\n    v = df.values\n    types = df.dtypes\n    numpy_struct_types = [make_col_type(types[col], df.loc[:, col]) for col in df.columns]\n    dtype = np.dtype(numpy_struct_types)\n    z = np.zeros(v.shape[0], dtype)\n    for i, k in enumerate(z.dtype.names):\n        # This is in case you have problems with the encoding, remove the if branch if not\n        try:\n            if dtype[i].str.startswith(\"|S\"):\n                z[k] = df[k].str.encode(\"latin\").astype(\"S\")\n            else:\n                z[k] = v[:, i]\n        except:\n            raise\n\n    return z, dtype\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.load_data","title":"<code>load_data(file_path)</code>","text":"<p>Load in external profile data</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def load_data(self, file_path):\n    \"Load in external profile data\"\n    toml_dict = toml.load(file_path)\n    return toml_dict\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.setup_profiles","title":"<code>setup_profiles()</code>","text":"<p>Sets up all profiles in the profile manager</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def setup_profiles(self):\n    \"Sets up all profiles in the profile manager\"\n    mapping_path = self.settings.simulation.project_path / PROFILES_FOLDER / DEFAULT_PROFILE_MAPPING_FILENAME\n    if mapping_path.exists():\n        self.profile_mapping = self.load_data(mapping_path)\n        self.profiles = {}\n        for group, profile_map in self.profile_mapping.items():\n            if group in self.store:\n                grp = self.store[group]\n                for profile_name, mapping_dict in profile_map.items():\n                    if profile_name in grp:\n                        self.profiles[f\"{group}/{profile_name}\"] = tsp(grp[profile_name], self.solver, mapping_dict)\n                    else:\n                        self._logger.warning(rf\"Group {group} \\ data set {profile_name} not found in the h5 store\")\n            else:\n                self._logger.warning(f\"Group {group} not found in the h5 store\")\n    else:\n        msg = f\"Profile_mapping.toml file does not exist in path {mapping_path}\"\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.update","title":"<code>update()</code>","text":"<p>Returns data for the current timestep for all mapped profiles</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def update(self):\n    \"Returns data for the current timestep for all mapped profiles\"\n    results = {}\n    for profile_name, profile_obj in self.profiles.items():\n        result = profile_obj.update()\n        results[profile_name] = result\n    return results\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile.Profile","title":"<code>Profile</code>","text":"<p>Class defination fora single profile</p> Source code in <code>pypsse\\profile_manager\\profile.py</code> <pre><code>class Profile:\n    \"Class defination fora single profile\"\n\n    DEFAULT_SETTINGS = {\"multiplier\": 1, \"normalize\": False, \"interpolate\": False}\n\n    def __init__(self, profile_obj, solver, mapping_dict, buffer_size=10, neglect_year=True):\n        self.value_settings = {f\"{x['bus']}__{x['id']}\": {**self.DEFAULT_SETTINGS, **x} for x in mapping_dict}\n        self.mapping_dict = mapping_dict\n        self.buffer_size = buffer_size\n        self.buffer = np.zeros(buffer_size)\n        self.profile = profile_obj\n        self.neglect_year = neglect_year\n        self.solver = solver\n        self.attrs = self.profile.attrs\n        s = self.attrs[\"sTime\"].decode()\n        stime = s if \".\" in s else s + \".00\"\n        e = self.attrs[\"eTime\"].decode()\n        etime = e if \".\" in e else e + \".00\"\n        self.stime = datetime.datetime.strptime(stime, \"%Y-%m-%d %H:%M:%S.%f\")\n        self.etime = datetime.datetime.strptime(etime, \"%Y-%m-%d %H:%M:%S.%f\")\n        self.sim_res = self.solver.get_step_size_cec()\n        self.time = copy.deepcopy(self.solver.get_time())\n        self.columns = self.attrs[\"units\"]\n        self.dtype = self.attrs[\"type\"].decode()\n\n    def update(self, update_object_properties=True):\n        \"Returns value at the current timestep in the given profile\"\n        self.time = copy.deepcopy(self.solver.get_time())\n        if self.time &lt; self.stime or self.time &gt; self.etime:\n            value = np.array([0] * len(self.profile[0]))\n            value1 = np.array([0] * len(self.profile[0]))\n        else:\n            dt = (self.time - self.stime).total_seconds()\n            n = int(dt / self.attrs[\"resTime\"])\n            value = np.array(list(self.profile[n]))\n            try:\n                valuen1 = np.array(list(self.profile[n + 1]))\n            except:\n                valuen1 = value\n\n            dt2 = (\n                self.time - (self.stime + datetime.timedelta(seconds=int(n * self.attrs[\"resTime\"])))\n            ).total_seconds()\n            value1 = value + (valuen1 - value) * dt2 / self.attrs[\"resTime\"]\n\n        if update_object_properties:\n            for obj_name in self.value_settings:\n                bus, object_id = obj_name.split(\"__\")\n                if self.value_settings[obj_name][\"interpolate\"]:\n                    value = value1\n                mult = self.value_settings[obj_name][\"multiplier\"]\n                if isinstance(mult, list):\n                    mult = np.array(mult)\n                if self.value_settings[obj_name][\"normalize\"]:\n                    value_f = value / self.attrs[\"max\"] * mult\n                else:\n                    value_f = value * mult\n                value_f = self.fill_missing_values(value_f)\n                self.solver.update_object(self.dtype, bus, object_id, value_f)\n        return value\n\n    def fill_missing_values(self, value):\n        \"Fixes issues in profile data\"\n        idx = [f\"realar{PROFILE_VALIDATION[self.dtype].index(c) + 1}\" for c in self.columns]\n        x = dict(zip(idx, list(value)))\n        return x\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile.Profile.fill_missing_values","title":"<code>fill_missing_values(value)</code>","text":"<p>Fixes issues in profile data</p> Source code in <code>pypsse\\profile_manager\\profile.py</code> <pre><code>def fill_missing_values(self, value):\n    \"Fixes issues in profile data\"\n    idx = [f\"realar{PROFILE_VALIDATION[self.dtype].index(c) + 1}\" for c in self.columns]\n    x = dict(zip(idx, list(value)))\n    return x\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile.Profile.update","title":"<code>update(update_object_properties=True)</code>","text":"<p>Returns value at the current timestep in the given profile</p> Source code in <code>pypsse\\profile_manager\\profile.py</code> <pre><code>def update(self, update_object_properties=True):\n    \"Returns value at the current timestep in the given profile\"\n    self.time = copy.deepcopy(self.solver.get_time())\n    if self.time &lt; self.stime or self.time &gt; self.etime:\n        value = np.array([0] * len(self.profile[0]))\n        value1 = np.array([0] * len(self.profile[0]))\n    else:\n        dt = (self.time - self.stime).total_seconds()\n        n = int(dt / self.attrs[\"resTime\"])\n        value = np.array(list(self.profile[n]))\n        try:\n            valuen1 = np.array(list(self.profile[n + 1]))\n        except:\n            valuen1 = value\n\n        dt2 = (\n            self.time - (self.stime + datetime.timedelta(seconds=int(n * self.attrs[\"resTime\"])))\n        ).total_seconds()\n        value1 = value + (valuen1 - value) * dt2 / self.attrs[\"resTime\"]\n\n    if update_object_properties:\n        for obj_name in self.value_settings:\n            bus, object_id = obj_name.split(\"__\")\n            if self.value_settings[obj_name][\"interpolate\"]:\n                value = value1\n            mult = self.value_settings[obj_name][\"multiplier\"]\n            if isinstance(mult, list):\n                mult = np.array(mult)\n            if self.value_settings[obj_name][\"normalize\"]:\n                value_f = value / self.attrs[\"max\"] * mult\n            else:\n                value_f = value * mult\n            value_f = self.fill_missing_values(value_f)\n            self.solver.update_object(self.dtype, bus, object_id, value_f)\n    return value\n</code></pre>"},{"location":"code/reference/#simulation-modes","title":"Simulation modes","text":""},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic","title":"<code>Dynamic</code>","text":"<p>             Bases: <code>AbstractMode</code>, <code>DynamicUtils</code></p> <p>Class defination for dynamic simulation mode (uses dyr and raw files)</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>class Dynamic(AbstractMode, DynamicUtils):\n    \"Class defination for dynamic simulation mode (uses dyr and raw files)\"\n\n    def __init__(\n        self,\n        psse,\n        dyntools,\n        settings: SimulationSettings,\n        export_settings: ExportSettings,\n        logger,\n        subsystem_buses,\n        raw_data,\n    ):\n        super().__init__(psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data)\n        self.time = settings.simulation.start_time\n        self._StartTime = settings.simulation.start_time\n        self.incTime = settings.simulation.simulation_step_resolution\n\n        self.init({})\n\n    def init(self, bus_subsystems):\n        \"Initializes the simulation\"\n        super().init(bus_subsystems)\n        self.iter_const = 100.0\n\n        if self.settings.simulation.rwm_file:\n            self.psse.mcre([1, 0], self.rwn_file)\n\n        self.psse.fnsl([0, 0, 0, 1, 0, 0, 0, self._i])\n\n        self.load_setup_files()\n        self.convert_load()\n\n        self.psse.gnet(1, 0)\n        self.psse.fdns([1, 1, 0, 1, 1, 0, 0, 0])\n        self.psse.fnsl([1, 1, 0, 1, 1, 0, 0, 0])\n        self.psse.cong(0)\n        # Solve for dynamics\n        self.psse.ordr(0)\n        self.psse.fact()\n        self.psse.tysl(0)\n        self.psse.tysl(0)\n        # self.psse.save(self.study_case_path.split('.')[0] + \".sav\")\n        dyr_path = self.settings.simulation.dyr_file\n        assert dyr_path and dyr_path.exists\n        self.logger.debug(f\"Loading dynamic model....{dyr_path}\")\n        self.psse.dynamicsmode(1)\n        ierr = self.psse.dyre_new([1, 1, 1, 1], str(dyr_path), r\"\"\"conec\"\"\", r\"\"\"conet\"\"\", r\"\"\"compile\"\"\")\n\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            if self.settings.helics.iterative_mode:\n                sim_step = self.settings.simulation.psse_solver_timestep.total_seconds() / self.iter_const\n            else:\n                sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n        else:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n\n        ierr = self.psse.dynamics_solution_param_2(\n            [60, self._i, self._i, self._i, self._i, self._i, self._i, self._i],\n            [0.4, self._f, sim_step, self._f, self._f, self._f, self._f, self._f],\n        )\n\n        if ierr:\n            msg = f'Error loading dynamic model file \"{dyr_path}\". Error code - {ierr}'\n            raise Exception(msg)\n        else:\n            self.logger.debug(f\"Dynamic file {dyr_path} sucessfully loaded\")\n\n        self.disable_load_models_for_coupled_buses()\n\n        if self.export_settings.export_results_using_channels:\n            self.setup_channels()\n\n        self.psse.delete_all_plot_channels()\n\n        self.setup_all_channels()\n\n        # Load user defined models\n        self.load_user_defined_models()\n\n        # Load flow settings\n        self.psse.fdns([0, 0, 0, 1, 1, 0, 99, 0])\n        # initialize\n        ierr = self.psse.strt_2(\n            [\n                1,\n                self.settings.generators.missing_machine_model,\n            ],\n            str(self.settings.export.outx_file),\n        )\n        if ierr:\n            self.initialization_complete = False\n            msg = f\"Dynamic simulation failed to successfully initialize. Error code - {ierr}\"\n            raise Exception(msg)\n        else:\n            self.initialization_complete = True\n            self.logger.debug(\"Dynamic simulation initialization sucess!\")\n        # get load info for the sub system\n        self.load_info = self.get_load_indices(bus_subsystems)\n\n        self.logger.debug(\"pyPSSE initialization complete!\")\n\n        self.xTime = 0\n\n        return self.initialization_complete\n\n    def step(self, t):\n        \"Increments the simulation\"\n\n        self.time = self.time + self.incTime\n        self.xTime = 0\n        return self.psse.run(0, t, 1, 1, 1)\n\n    def get_load_indices(self, bus_subsystems):\n        \"Returns load indices\"\n\n        all_bus_ids = {}\n        for bus_subsystem_id in bus_subsystems.keys():\n            load_info = {}\n            ierr, load_data = self.psse.aloadchar(bus_subsystem_id, 1, [\"ID\", \"NAME\", \"EXNAME\"])\n\n            load_data = np.array(load_data)\n            ierr, bus_data = self.psse.aloadint(bus_subsystem_id, 1, [\"NUMBER\"])\n\n            bus_data = bus_data[0]\n            for i, bus_id in enumerate(bus_data):\n                load_info[bus_id] = {\n                    \"Load ID\": load_data[0, i],\n                    \"Bus name\": load_data[1, i],\n                    \"Bus name (ext)\": load_data[2, i],\n                }\n            all_bus_ids[bus_subsystem_id] = load_info\n        return all_bus_ids\n\n    def resolve_step(self, t):\n        \"Resolves the current time step\"\n\n        err = self.psse.run(0, t + self.xTime * self.incTime / self.iter_const, 1, 1, 1)\n        self.xTime += 1\n        return err\n\n    def get_time(self):\n        \"Returns current simulator time\"\n\n        return self.time\n\n    def get_total_seconds(self):\n        \"Returns total simulation time\"\n\n        return (self.time - self._StartTime).total_seconds()\n\n    def get_step_size_cec(self):\n        \"Returns simulation timestep resolution\"\n        return self.settings.simulation.simulation_step_resolution.total_seconds()\n\n    @converter\n    def read_subsystems(self, quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None):\n        \"Queries the result container for current results\"\n\n        if ext_string2_info is None:\n            ext_string2_info = {}\n        if mapping_dict is None:\n            mapping_dict = {}\n        results = super().read_subsystems(\n            quantities, subsystem_buses, mapping_dict=mapping_dict, ext_string2_info=ext_string2_info\n        )\n\n        poll_results = self.poll_channels()\n        results.update(poll_results)\n        for class_name, var_list in quantities.items():\n            if class_name in dyn_only_options:\n                for v in var_list:\n                    if v in DYNAMIC_ONLY_PPTY[class_name]:\n                        for func_name in dyn_only_options[class_name]:\n                            if v in dyn_only_options[class_name][func_name]:\n                                con_ind = dyn_only_options[class_name][func_name][v]\n                                for bus in subsystem_buses:\n                                    if class_name == \"Loads\":\n                                        ierr = self.psse.inilod(int(bus))\n\n                                        ierr, ld_id = self.psse.nxtlod(int(bus))\n\n                                        if ld_id is not None:\n                                            ierr, con_index = getattr(self.psse, func_name)(\n                                                int(bus), ld_id, \"CHARAC\", \"CON\"\n                                            )\n\n                                            if con_index is not None:\n                                                act_con_index = con_index + con_ind\n                                                ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n\n                                                res_base = f\"{class_name}_{v}\"\n                                                if res_base not in results:\n                                                    results[res_base] = {}\n                                                obj_name = f\"{bus}_{ld_id}\"\n                                                results[res_base][obj_name] = value\n            else:\n                self.logger.warning(\"Extend function 'read_subsystems' in the Dynamic class (Dynamic.py)\")\n        return results\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.get_load_indices","title":"<code>get_load_indices(bus_subsystems)</code>","text":"<p>Returns load indices</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def get_load_indices(self, bus_subsystems):\n    \"Returns load indices\"\n\n    all_bus_ids = {}\n    for bus_subsystem_id in bus_subsystems.keys():\n        load_info = {}\n        ierr, load_data = self.psse.aloadchar(bus_subsystem_id, 1, [\"ID\", \"NAME\", \"EXNAME\"])\n\n        load_data = np.array(load_data)\n        ierr, bus_data = self.psse.aloadint(bus_subsystem_id, 1, [\"NUMBER\"])\n\n        bus_data = bus_data[0]\n        for i, bus_id in enumerate(bus_data):\n            load_info[bus_id] = {\n                \"Load ID\": load_data[0, i],\n                \"Bus name\": load_data[1, i],\n                \"Bus name (ext)\": load_data[2, i],\n            }\n        all_bus_ids[bus_subsystem_id] = load_info\n    return all_bus_ids\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.get_step_size_cec","title":"<code>get_step_size_cec()</code>","text":"<p>Returns simulation timestep resolution</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def get_step_size_cec(self):\n    \"Returns simulation timestep resolution\"\n    return self.settings.simulation.simulation_step_resolution.total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.get_time","title":"<code>get_time()</code>","text":"<p>Returns current simulator time</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def get_time(self):\n    \"Returns current simulator time\"\n\n    return self.time\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.get_total_seconds","title":"<code>get_total_seconds()</code>","text":"<p>Returns total simulation time</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def get_total_seconds(self):\n    \"Returns total simulation time\"\n\n    return (self.time - self._StartTime).total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.init","title":"<code>init(bus_subsystems)</code>","text":"<p>Initializes the simulation</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def init(self, bus_subsystems):\n    \"Initializes the simulation\"\n    super().init(bus_subsystems)\n    self.iter_const = 100.0\n\n    if self.settings.simulation.rwm_file:\n        self.psse.mcre([1, 0], self.rwn_file)\n\n    self.psse.fnsl([0, 0, 0, 1, 0, 0, 0, self._i])\n\n    self.load_setup_files()\n    self.convert_load()\n\n    self.psse.gnet(1, 0)\n    self.psse.fdns([1, 1, 0, 1, 1, 0, 0, 0])\n    self.psse.fnsl([1, 1, 0, 1, 1, 0, 0, 0])\n    self.psse.cong(0)\n    # Solve for dynamics\n    self.psse.ordr(0)\n    self.psse.fact()\n    self.psse.tysl(0)\n    self.psse.tysl(0)\n    # self.psse.save(self.study_case_path.split('.')[0] + \".sav\")\n    dyr_path = self.settings.simulation.dyr_file\n    assert dyr_path and dyr_path.exists\n    self.logger.debug(f\"Loading dynamic model....{dyr_path}\")\n    self.psse.dynamicsmode(1)\n    ierr = self.psse.dyre_new([1, 1, 1, 1], str(dyr_path), r\"\"\"conec\"\"\", r\"\"\"conet\"\"\", r\"\"\"compile\"\"\")\n\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        if self.settings.helics.iterative_mode:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds() / self.iter_const\n        else:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n    else:\n        sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n\n    ierr = self.psse.dynamics_solution_param_2(\n        [60, self._i, self._i, self._i, self._i, self._i, self._i, self._i],\n        [0.4, self._f, sim_step, self._f, self._f, self._f, self._f, self._f],\n    )\n\n    if ierr:\n        msg = f'Error loading dynamic model file \"{dyr_path}\". Error code - {ierr}'\n        raise Exception(msg)\n    else:\n        self.logger.debug(f\"Dynamic file {dyr_path} sucessfully loaded\")\n\n    self.disable_load_models_for_coupled_buses()\n\n    if self.export_settings.export_results_using_channels:\n        self.setup_channels()\n\n    self.psse.delete_all_plot_channels()\n\n    self.setup_all_channels()\n\n    # Load user defined models\n    self.load_user_defined_models()\n\n    # Load flow settings\n    self.psse.fdns([0, 0, 0, 1, 1, 0, 99, 0])\n    # initialize\n    ierr = self.psse.strt_2(\n        [\n            1,\n            self.settings.generators.missing_machine_model,\n        ],\n        str(self.settings.export.outx_file),\n    )\n    if ierr:\n        self.initialization_complete = False\n        msg = f\"Dynamic simulation failed to successfully initialize. Error code - {ierr}\"\n        raise Exception(msg)\n    else:\n        self.initialization_complete = True\n        self.logger.debug(\"Dynamic simulation initialization sucess!\")\n    # get load info for the sub system\n    self.load_info = self.get_load_indices(bus_subsystems)\n\n    self.logger.debug(\"pyPSSE initialization complete!\")\n\n    self.xTime = 0\n\n    return self.initialization_complete\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.read_subsystems","title":"<code>read_subsystems(quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None)</code>","text":"<p>Queries the result container for current results</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>@converter\ndef read_subsystems(self, quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None):\n    \"Queries the result container for current results\"\n\n    if ext_string2_info is None:\n        ext_string2_info = {}\n    if mapping_dict is None:\n        mapping_dict = {}\n    results = super().read_subsystems(\n        quantities, subsystem_buses, mapping_dict=mapping_dict, ext_string2_info=ext_string2_info\n    )\n\n    poll_results = self.poll_channels()\n    results.update(poll_results)\n    for class_name, var_list in quantities.items():\n        if class_name in dyn_only_options:\n            for v in var_list:\n                if v in DYNAMIC_ONLY_PPTY[class_name]:\n                    for func_name in dyn_only_options[class_name]:\n                        if v in dyn_only_options[class_name][func_name]:\n                            con_ind = dyn_only_options[class_name][func_name][v]\n                            for bus in subsystem_buses:\n                                if class_name == \"Loads\":\n                                    ierr = self.psse.inilod(int(bus))\n\n                                    ierr, ld_id = self.psse.nxtlod(int(bus))\n\n                                    if ld_id is not None:\n                                        ierr, con_index = getattr(self.psse, func_name)(\n                                            int(bus), ld_id, \"CHARAC\", \"CON\"\n                                        )\n\n                                        if con_index is not None:\n                                            act_con_index = con_index + con_ind\n                                            ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n\n                                            res_base = f\"{class_name}_{v}\"\n                                            if res_base not in results:\n                                                results[res_base] = {}\n                                            obj_name = f\"{bus}_{ld_id}\"\n                                            results[res_base][obj_name] = value\n        else:\n            self.logger.warning(\"Extend function 'read_subsystems' in the Dynamic class (Dynamic.py)\")\n    return results\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.resolve_step","title":"<code>resolve_step(t)</code>","text":"<p>Resolves the current time step</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def resolve_step(self, t):\n    \"Resolves the current time step\"\n\n    err = self.psse.run(0, t + self.xTime * self.incTime / self.iter_const, 1, 1, 1)\n    self.xTime += 1\n    return err\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.step","title":"<code>step(t)</code>","text":"<p>Increments the simulation</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def step(self, t):\n    \"Increments the simulation\"\n\n    self.time = self.time + self.incTime\n    self.xTime = 0\n    return self.psse.run(0, t, 1, 1, 1)\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap","title":"<code>Snap</code>","text":"<p>             Bases: <code>AbstractMode</code>, <code>DynamicUtils</code></p> <p>Class defination for snapshat simulation mode (uses snp and sav files)</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>class Snap(AbstractMode, DynamicUtils):\n    \"Class defination for snapshat simulation mode (uses snp and sav files)\"\n\n    def __init__(\n        self,\n        psse,\n        dyntools,\n        settings: SimulationSettings,\n        export_settings: ExportSettings,\n        logger,\n        subsystem_buses,\n        raw_data,\n    ):\n        super().__init__(psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data)\n        self.time = settings.simulation.start_time\n        self._StartTime = settings.simulation.start_time\n        self.incTime = settings.simulation.simulation_step_resolution\n        self.init(subsystem_buses)\n\n    def init(self, bus_subsystems):\n        \"Initializes the simulation\"\n        super().init(bus_subsystems)\n\n        self.iter_const = 100.0\n        self.xTime = 0\n\n        ierr = self.psse.case(str(self.settings.simulation.case_study))\n\n        self.load_setup_files()\n        self.convert_load()\n\n        self.logger.info(f\"Load snap file: {self.settings.simulation.snp_file}\")\n        ierr = self.psse.rstr(str(self.settings.simulation.snp_file))\n        #\n\n        # The following logic only runs when the helics interface is enabled\n        self.disable_load_models_for_coupled_buses()\n        self.disable_generation_for_coupled_buses()\n        # self.save_model()\n        ############# ------------------------------------- ###############\n\n        ierr = self.psse.strt_2([0, 1], str(self.settings.export.outx_file))\n\n        if ierr == 1:\n            self.psse.cong(0)\n            ierr = self.psse.strt_2([0, 1], str(self.settings.export.outx_file))\n\n        elif ierr &gt; 1:\n            msg = \"Error starting simulation\"\n            raise Exception(msg)\n\n        self.load_user_defined_models()\n\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            if self.settings.helics.iterative_mode:\n                sim_step = self.settings.simulation.psse_solver_timestep.total_seconds() / self.iter_const\n            else:\n                sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n        else:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n\n        self.psse.dynamics_solution_param_2(\n            [60, self._i, self._i, self._i, self._i, self._i, self._i, self._i],\n            [0.4, self._f, sim_step, self._f, self._f, self._f, self._f, self._f],\n        )\n\n        self.psse.delete_all_plot_channels()\n\n        self.setup_all_channels()\n\n        self.logger.debug(\"pyPSSE initialization complete!\")\n        self.initialization_complete = True\n        return self.initialization_complete\n\n    def step(self, t):\n        \"Increments the simulation\"\n        self.time = self.time + self.incTime\n        self.xTime = 0\n        return self.psse.run(0, t, 1, 1, 1)\n\n    def resolve_step(self, t):\n        \"Resolves the current time step\"\n        self.xTime += 1\n        return self.psse.run(0, t + self.xTime * self.incTime / self.iter_const, 1, 1, 1)\n\n    def get_load_indices(self, bus_subsystems):\n        \"Returns load indices\"\n        all_bus_ids = {}\n        for bus_subsystem_id in bus_subsystems.keys():\n            load_info = {}\n            ierr, load_data = self.psse.aloadchar(bus_subsystem_id, 1, [\"ID\", \"NAME\", \"EXNAME\"])\n\n            load_data = np.array(load_data)\n            ierr, bus_data = self.psse.aloadint(bus_subsystem_id, 1, [\"NUMBER\"])\n\n            bus_data = bus_data[0]\n            for i, bus_id in enumerate(bus_data):\n                load_info[bus_id] = {\n                    \"Load ID\": load_data[0, i],\n                    \"Bus name\": load_data[1, i],\n                    \"Bus name (ext)\": load_data[2, i],\n                }\n            all_bus_ids[bus_subsystem_id] = load_info\n        return all_bus_ids\n\n    def get_time(self):\n        \"Returns current simulator time\"\n        return self.time\n\n    def get_total_seconds(self):\n        \"Returns total simulation time\"\n        return (self.time - self._StartTime).total_seconds()\n\n    def get_step_size_cec(self):\n        \"Returns simulation timestep resolution\"\n        return self.settings.simulation.simulation_step_resolution.total_seconds()\n\n    @converter\n    def read_subsystems(self, quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None):\n        \"Queries the result container for current results\"\n        if ext_string2_info is None:\n            ext_string2_info = {}\n        if mapping_dict is None:\n            mapping_dict = {}\n        results = super().read_subsystems(\n            quantities, subsystem_buses, mapping_dict=mapping_dict, ext_string2_info=ext_string2_info\n        )\n\n        poll_results = self.poll_channels()\n        results.update(poll_results)\n        \"\"\" Add \"\"\"\n        for class_name, var_list in quantities.items():\n            if class_name in dyn_only_options:\n                for v in var_list:\n                    if v in DYNAMIC_ONLY_PPTY[class_name]:\n                        for func_name in dyn_only_options[class_name]:\n                            if v in dyn_only_options[class_name][func_name]:\n                                con_ind = dyn_only_options[class_name][func_name][v]\n                                for bus in subsystem_buses:\n                                    if class_name == \"Loads\":\n                                        ierr = self.psse.inilod(int(bus))\n\n                                        ierr, ld_id = self.psse.nxtlod(int(bus))\n\n                                        if ld_id is not None:\n                                            ierr, con_index = getattr(self.psse, func_name)(\n                                                int(bus), ld_id, \"CHARAC\", \"CON\"\n                                            )\n\n                                            if con_index is not None:\n                                                act_con_index = con_index + con_ind\n                                                ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n\n                                                res_base = f\"{class_name}_{v}\"\n                                                if res_base not in results:\n                                                    results[res_base] = {}\n                                                obj_name = f\"{bus}_{ld_id}\"\n                                                results[res_base][obj_name] = value\n            else:\n                self.logger.warning(\"Extend function 'read_subsystems' in the Snap class (Snap.py)\")\n\n        return results\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.get_load_indices","title":"<code>get_load_indices(bus_subsystems)</code>","text":"<p>Returns load indices</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def get_load_indices(self, bus_subsystems):\n    \"Returns load indices\"\n    all_bus_ids = {}\n    for bus_subsystem_id in bus_subsystems.keys():\n        load_info = {}\n        ierr, load_data = self.psse.aloadchar(bus_subsystem_id, 1, [\"ID\", \"NAME\", \"EXNAME\"])\n\n        load_data = np.array(load_data)\n        ierr, bus_data = self.psse.aloadint(bus_subsystem_id, 1, [\"NUMBER\"])\n\n        bus_data = bus_data[0]\n        for i, bus_id in enumerate(bus_data):\n            load_info[bus_id] = {\n                \"Load ID\": load_data[0, i],\n                \"Bus name\": load_data[1, i],\n                \"Bus name (ext)\": load_data[2, i],\n            }\n        all_bus_ids[bus_subsystem_id] = load_info\n    return all_bus_ids\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.get_step_size_cec","title":"<code>get_step_size_cec()</code>","text":"<p>Returns simulation timestep resolution</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def get_step_size_cec(self):\n    \"Returns simulation timestep resolution\"\n    return self.settings.simulation.simulation_step_resolution.total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.get_time","title":"<code>get_time()</code>","text":"<p>Returns current simulator time</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def get_time(self):\n    \"Returns current simulator time\"\n    return self.time\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.get_total_seconds","title":"<code>get_total_seconds()</code>","text":"<p>Returns total simulation time</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def get_total_seconds(self):\n    \"Returns total simulation time\"\n    return (self.time - self._StartTime).total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.init","title":"<code>init(bus_subsystems)</code>","text":"<p>Initializes the simulation</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def init(self, bus_subsystems):\n    \"Initializes the simulation\"\n    super().init(bus_subsystems)\n\n    self.iter_const = 100.0\n    self.xTime = 0\n\n    ierr = self.psse.case(str(self.settings.simulation.case_study))\n\n    self.load_setup_files()\n    self.convert_load()\n\n    self.logger.info(f\"Load snap file: {self.settings.simulation.snp_file}\")\n    ierr = self.psse.rstr(str(self.settings.simulation.snp_file))\n    #\n\n    # The following logic only runs when the helics interface is enabled\n    self.disable_load_models_for_coupled_buses()\n    self.disable_generation_for_coupled_buses()\n    # self.save_model()\n    ############# ------------------------------------- ###############\n\n    ierr = self.psse.strt_2([0, 1], str(self.settings.export.outx_file))\n\n    if ierr == 1:\n        self.psse.cong(0)\n        ierr = self.psse.strt_2([0, 1], str(self.settings.export.outx_file))\n\n    elif ierr &gt; 1:\n        msg = \"Error starting simulation\"\n        raise Exception(msg)\n\n    self.load_user_defined_models()\n\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        if self.settings.helics.iterative_mode:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds() / self.iter_const\n        else:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n    else:\n        sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n\n    self.psse.dynamics_solution_param_2(\n        [60, self._i, self._i, self._i, self._i, self._i, self._i, self._i],\n        [0.4, self._f, sim_step, self._f, self._f, self._f, self._f, self._f],\n    )\n\n    self.psse.delete_all_plot_channels()\n\n    self.setup_all_channels()\n\n    self.logger.debug(\"pyPSSE initialization complete!\")\n    self.initialization_complete = True\n    return self.initialization_complete\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.read_subsystems","title":"<code>read_subsystems(quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None)</code>","text":"<p>Queries the result container for current results</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>@converter\ndef read_subsystems(self, quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None):\n    \"Queries the result container for current results\"\n    if ext_string2_info is None:\n        ext_string2_info = {}\n    if mapping_dict is None:\n        mapping_dict = {}\n    results = super().read_subsystems(\n        quantities, subsystem_buses, mapping_dict=mapping_dict, ext_string2_info=ext_string2_info\n    )\n\n    poll_results = self.poll_channels()\n    results.update(poll_results)\n    \"\"\" Add \"\"\"\n    for class_name, var_list in quantities.items():\n        if class_name in dyn_only_options:\n            for v in var_list:\n                if v in DYNAMIC_ONLY_PPTY[class_name]:\n                    for func_name in dyn_only_options[class_name]:\n                        if v in dyn_only_options[class_name][func_name]:\n                            con_ind = dyn_only_options[class_name][func_name][v]\n                            for bus in subsystem_buses:\n                                if class_name == \"Loads\":\n                                    ierr = self.psse.inilod(int(bus))\n\n                                    ierr, ld_id = self.psse.nxtlod(int(bus))\n\n                                    if ld_id is not None:\n                                        ierr, con_index = getattr(self.psse, func_name)(\n                                            int(bus), ld_id, \"CHARAC\", \"CON\"\n                                        )\n\n                                        if con_index is not None:\n                                            act_con_index = con_index + con_ind\n                                            ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n\n                                            res_base = f\"{class_name}_{v}\"\n                                            if res_base not in results:\n                                                results[res_base] = {}\n                                            obj_name = f\"{bus}_{ld_id}\"\n                                            results[res_base][obj_name] = value\n        else:\n            self.logger.warning(\"Extend function 'read_subsystems' in the Snap class (Snap.py)\")\n\n    return results\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.resolve_step","title":"<code>resolve_step(t)</code>","text":"<p>Resolves the current time step</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def resolve_step(self, t):\n    \"Resolves the current time step\"\n    self.xTime += 1\n    return self.psse.run(0, t + self.xTime * self.incTime / self.iter_const, 1, 1, 1)\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.step","title":"<code>step(t)</code>","text":"<p>Increments the simulation</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def step(self, t):\n    \"Increments the simulation\"\n    self.time = self.time + self.incTime\n    self.xTime = 0\n    return self.psse.run(0, t, 1, 1, 1)\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static","title":"<code>Static</code>","text":"<p>             Bases: <code>AbstractMode</code></p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>class Static(AbstractMode):\n    def __init__(self, psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data):\n        \"Class defination for steady-state simulation mode\"\n\n        super().__init__(psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data)\n        self.time = settings.simulation.start_time\n        self._StartTime = settings.simulation.start_time\n        self.incTime = settings.simulation.simulation_step_resolution\n\n    def init(self, bussubsystems):\n        super().init(bussubsystems)\n        self.initialization_complete = True\n\n    def step(self, _):\n        \"Increments the simulation\"\n        ierr = self.psse.fnsl()\n        # check if powerflow completed successfully\n        if ierr == 0:\n            self.time = self.time + self.incTime\n        else:\n            msg = f\"Error code {ierr} returned from PSSE while running powerflow, please follow \\\n                            PSSE doumentation to know more about error\"\n            raise Exception(msg)\n\n    def resolve_step(self):\n        \"Resolves the current time step\"\n        ierr = self.psse.fnsl()\n        if ierr &gt; 0:\n            msg = f\"Error code {ierr} returned from PSSE while running powerflow, please follow \\\n                                        PSSE doumentation to know more about error\"\n            raise Exception(msg)\n\n    def get_time(self):\n        \"Returns current simulator time\"\n        return self.time\n\n    def get_total_seconds(self):\n        \"Returns total simulation time\"\n        return (self.time - self._StartTime).total_seconds()\n\n    def get_step_size_cec(self):\n        \"Returns simulation timestep resolution\"\n        return self.settings.simulation.simulation_step_resolution.total_seconds()\n\n    def export(self):\n        \"Exports simulation results\"\n        self.logger.debug(\"Starting export process. Can take a few minutes for large files\")\n        excelpath = os.path.join(self.export_path, self.settings[\"Excel file\"])\n        achnf = self.dyntools.CHNF(self.outx_path)\n        achnf.xlsout(channels=\"\", show=False, xlsfile=excelpath, outfile=\"\", sheet=\"Sheet1\", overwritesheet=True)\n        self.logger.debug(f\"{self.settings.export.excel_file} exported\")\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.__init__","title":"<code>__init__(psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data)</code>","text":"<p>Class defination for steady-state simulation mode</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def __init__(self, psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data):\n    \"Class defination for steady-state simulation mode\"\n\n    super().__init__(psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data)\n    self.time = settings.simulation.start_time\n    self._StartTime = settings.simulation.start_time\n    self.incTime = settings.simulation.simulation_step_resolution\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.export","title":"<code>export()</code>","text":"<p>Exports simulation results</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def export(self):\n    \"Exports simulation results\"\n    self.logger.debug(\"Starting export process. Can take a few minutes for large files\")\n    excelpath = os.path.join(self.export_path, self.settings[\"Excel file\"])\n    achnf = self.dyntools.CHNF(self.outx_path)\n    achnf.xlsout(channels=\"\", show=False, xlsfile=excelpath, outfile=\"\", sheet=\"Sheet1\", overwritesheet=True)\n    self.logger.debug(f\"{self.settings.export.excel_file} exported\")\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.get_step_size_cec","title":"<code>get_step_size_cec()</code>","text":"<p>Returns simulation timestep resolution</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def get_step_size_cec(self):\n    \"Returns simulation timestep resolution\"\n    return self.settings.simulation.simulation_step_resolution.total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.get_time","title":"<code>get_time()</code>","text":"<p>Returns current simulator time</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def get_time(self):\n    \"Returns current simulator time\"\n    return self.time\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.get_total_seconds","title":"<code>get_total_seconds()</code>","text":"<p>Returns total simulation time</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def get_total_seconds(self):\n    \"Returns total simulation time\"\n    return (self.time - self._StartTime).total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.resolve_step","title":"<code>resolve_step()</code>","text":"<p>Resolves the current time step</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def resolve_step(self):\n    \"Resolves the current time step\"\n    ierr = self.psse.fnsl()\n    if ierr &gt; 0:\n        msg = f\"Error code {ierr} returned from PSSE while running powerflow, please follow \\\n                                    PSSE doumentation to know more about error\"\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.step","title":"<code>step(_)</code>","text":"<p>Increments the simulation</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def step(self, _):\n    \"Increments the simulation\"\n    ierr = self.psse.fnsl()\n    # check if powerflow completed successfully\n    if ierr == 0:\n        self.time = self.time + self.incTime\n    else:\n        msg = f\"Error code {ierr} returned from PSSE while running powerflow, please follow \\\n                        PSSE doumentation to know more about error\"\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.simulation_controller.sim_controller","title":"<code>sim_controller(psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data)</code>","text":"<p>Sets up an appropriate simualtion controller based on user input</p> Source code in <code>pypsse\\simulation_controller.py</code> <pre><code>def sim_controller(psse, dyntools, settings: SimulationSettings, export_settings, logger, subsystem_buses, raw_data):\n    \"Sets up an appropriate simualtion controller based on user input\"\n    sim_modes = {\"Dynamic\": Dynamic, \"Steady-state\": Static, \"Snap\": Snap, \"ProductionCostModel\": ProductionCostModel}\n\n    sim = sim_modes[settings.simulation.simulation_mode.value](\n        psse, dyntools, settings, export_settings, logger, subsystem_buses, raw_data\n    )\n    return sim\n</code></pre>"},{"location":"code/reference/#model-parsers","title":"Model parsers","text":""},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser","title":"<code>GICParser</code>","text":"Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>class GICParser:\n    valid_verions = [\"3\"]\n\n    def __init__(self, settings: SimulationSettings, logger=None):\n        self.logger = logger\n        self.logger.debug(\"Starting RAW parser\")\n\n        self.settings = settings\n        self.filepath = str(settings.simulation.gic_file)\n\n        self.filehandle = open(self.filepath)\n        verion = self.filehandle.readline()\n        if \"GICFILEVRSN=\" in verion:\n            verion = verion.replace(\"GICFILEVRSN=\", \"\").replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n            if verion in self.valid_verions:\n                self.logger.debug(f\"Reading GIC file verion {verion}\")\n            else:\n                vers = \",\".join(self.valid_verions)\n                self.logger.debug(\n                    f\"Version {verion} is not supported.\\nFollowing version are currently supported: {vers}\"\n                )\n        else:\n            self.logger.debug(\"GIC file structue does not seem to be valid\")\n\n        self.get_bus_coordinates()\n        self.psse_graph = nx.Graph()\n        self.create_graph()\n        pos = {}\n        for node in self.psse_graph.nodes:\n            pos[node] = [\n                float(self.psse_graph.nodes[node][\"latitude\"]),\n                float(self.psse_graph.nodes[node][\"longitude\"]),\n            ]\n        export_path = os.path.join(\n            self.settings[\"Simulation\"][\"Project Path\"],\n            \"Exports\",\n            self.settings[\"Export_settings\"][\"NetworkX graph file\"],\n        )\n        nx.write_gpickle(self.psse_graph, export_path)\n        # nx.draw(self.psse_graph ,pos)\n        # plt.show()\n\n    def create_graph(self):\n        \"Creates graph representation\"\n\n        self.parse_substation_data()\n        self.parse_transformer_data()\n        self.parse_branch_data()\n        nx.set_node_attributes(self.psse_graph, self.bus_data)\n\n    def parse_substation_data(self):\n        \"Parses substation data\"\n\n        self.logger.debug(\"Parsing substation data...\")\n        linedata = \"\"\n        while True:\n            linedata = self.filehandle.readline()\n            if \"End of Bus Substation Data\" in linedata:\n                break\n            if self.settings[\"GIC_export_settings\"][\"include substation connections\"]:\n                buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n                buses = buses.split(\" \")\n                if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                    self.psse_graph.add_edge(buses[0], buses[1])\n                else:\n                    self.logger.debug(\n                        f\"Error parsing substation data egde: {buses}.\\nOne of the bus id does not exist in bus data\"\n                    )\n\n    def parse_transformer_data(self):\n        \"Parses transformer data\"\n\n        self.logger.debug(\"Parsing transformer data...\")\n        linedata = \"\"\n        while True:\n            linedata = self.filehandle.readline()\n            if \"End of Transformer Data\" in linedata:\n                break\n\n            if self.settings[\"GIC_export_settings\"][\"include transfomer connections\"]:\n                buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n                buses = buses.split(\" \")[:3]\n                if buses[2] == \"\":\n                    if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                        self.psse_graph.add_edge(buses[0], buses[1])\n                    else:\n                        self.logger.debug(\n                            f\"Error parsing transformer data egde: {buses}.\"\n                            f\"\\nOne of the bus id does not exist in bus data\"\n                        )\n                else:\n                    if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                        self.psse_graph.add_edge(buses[0], buses[1])\n                    if buses[2] in self.bus_data and buses[1] in self.bus_data:\n                        self.psse_graph.add_edge(buses[1], buses[2])\n                    if buses[2] in self.bus_data and buses[0] in self.bus_data:\n                        self.psse_graph.add_edge(buses[2], buses[0])\n                    pass\n\n    def parse_branch_data(self):\n        \"Parses branch data\"\n\n        self.logger.debug(\"Parsing branch data...\")\n        linedata = \"\"\n        while True:\n            linedata = self.filehandle.readline()\n            if \"End of Branch Data\" in linedata:\n                break\n            if self.settings[\"GIC_export_settings\"][\"include branch connections\"]:\n                buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n                buses = buses.split(\" \")[:2]\n                if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                    self.psse_graph.add_edge(buses[0], buses[1])\n                else:\n                    self.logger.debug(\n                        f\"Error parsing branch data egde: {buses}.\\nOne of the bus id does not exist in bus data\"\n                    )\n\n    def get_bus_coordinates(self):\n        \"Parses bus coordinates\"\n\n        self.logger.debug(\"Parsing bus coordinates...\")\n        bus_data_headers = [\"subsystem/bustype?\", \"latitude\", \"longitude\", \"angle?\"]\n        self.bus_data = {}\n        linedata = \"\"\n        start = \"'\"\n        end = \"'\"\n        while True:\n            linedata = self.filehandle.readline()\n            if \"End of Substation data\" in linedata:\n                break\n\n            bus_name = linedata[linedata.find(start) + len(start) : linedata.rfind(end)]\n            data = linedata.replace(f\" {start}{bus_name}{end}\", \"\")\n            data = data.replace(\"  \", \" \")\n            data = data.replace(\"  \", \" \")\n            data = data.split(\" \")\n            bus_id = data[0]\n\n            if bus_id not in self.bus_data:\n                self.bus_data[bus_id] = {}\n\n            self.bus_data[bus_id][\"bus_name\"] = bus_name\n            for val, label in zip(data[1:], bus_data_headers):\n                self.bus_data[bus_id][label] = val\n\n        bus_data = pd.DataFrame(self.bus_data).T\n        export_path = os.path.join(\n            self.settings[\"Simulation\"][\"Project Path\"], \"Exports\", self.settings[\"Export_settings\"][\"Coordinate file\"]\n        )\n        bus_data.to_csv(export_path)\n        self.logger.debug(f\"Bus coordinate file exported to: {export_path}\")\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser.create_graph","title":"<code>create_graph()</code>","text":"<p>Creates graph representation</p> Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>def create_graph(self):\n    \"Creates graph representation\"\n\n    self.parse_substation_data()\n    self.parse_transformer_data()\n    self.parse_branch_data()\n    nx.set_node_attributes(self.psse_graph, self.bus_data)\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser.get_bus_coordinates","title":"<code>get_bus_coordinates()</code>","text":"<p>Parses bus coordinates</p> Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>def get_bus_coordinates(self):\n    \"Parses bus coordinates\"\n\n    self.logger.debug(\"Parsing bus coordinates...\")\n    bus_data_headers = [\"subsystem/bustype?\", \"latitude\", \"longitude\", \"angle?\"]\n    self.bus_data = {}\n    linedata = \"\"\n    start = \"'\"\n    end = \"'\"\n    while True:\n        linedata = self.filehandle.readline()\n        if \"End of Substation data\" in linedata:\n            break\n\n        bus_name = linedata[linedata.find(start) + len(start) : linedata.rfind(end)]\n        data = linedata.replace(f\" {start}{bus_name}{end}\", \"\")\n        data = data.replace(\"  \", \" \")\n        data = data.replace(\"  \", \" \")\n        data = data.split(\" \")\n        bus_id = data[0]\n\n        if bus_id not in self.bus_data:\n            self.bus_data[bus_id] = {}\n\n        self.bus_data[bus_id][\"bus_name\"] = bus_name\n        for val, label in zip(data[1:], bus_data_headers):\n            self.bus_data[bus_id][label] = val\n\n    bus_data = pd.DataFrame(self.bus_data).T\n    export_path = os.path.join(\n        self.settings[\"Simulation\"][\"Project Path\"], \"Exports\", self.settings[\"Export_settings\"][\"Coordinate file\"]\n    )\n    bus_data.to_csv(export_path)\n    self.logger.debug(f\"Bus coordinate file exported to: {export_path}\")\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser.parse_branch_data","title":"<code>parse_branch_data()</code>","text":"<p>Parses branch data</p> Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>def parse_branch_data(self):\n    \"Parses branch data\"\n\n    self.logger.debug(\"Parsing branch data...\")\n    linedata = \"\"\n    while True:\n        linedata = self.filehandle.readline()\n        if \"End of Branch Data\" in linedata:\n            break\n        if self.settings[\"GIC_export_settings\"][\"include branch connections\"]:\n            buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n            buses = buses.split(\" \")[:2]\n            if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                self.psse_graph.add_edge(buses[0], buses[1])\n            else:\n                self.logger.debug(\n                    f\"Error parsing branch data egde: {buses}.\\nOne of the bus id does not exist in bus data\"\n                )\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser.parse_substation_data","title":"<code>parse_substation_data()</code>","text":"<p>Parses substation data</p> Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>def parse_substation_data(self):\n    \"Parses substation data\"\n\n    self.logger.debug(\"Parsing substation data...\")\n    linedata = \"\"\n    while True:\n        linedata = self.filehandle.readline()\n        if \"End of Bus Substation Data\" in linedata:\n            break\n        if self.settings[\"GIC_export_settings\"][\"include substation connections\"]:\n            buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n            buses = buses.split(\" \")\n            if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                self.psse_graph.add_edge(buses[0], buses[1])\n            else:\n                self.logger.debug(\n                    f\"Error parsing substation data egde: {buses}.\\nOne of the bus id does not exist in bus data\"\n                )\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser.parse_transformer_data","title":"<code>parse_transformer_data()</code>","text":"<p>Parses transformer data</p> Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>def parse_transformer_data(self):\n    \"Parses transformer data\"\n\n    self.logger.debug(\"Parsing transformer data...\")\n    linedata = \"\"\n    while True:\n        linedata = self.filehandle.readline()\n        if \"End of Transformer Data\" in linedata:\n            break\n\n        if self.settings[\"GIC_export_settings\"][\"include transfomer connections\"]:\n            buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n            buses = buses.split(\" \")[:3]\n            if buses[2] == \"\":\n                if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                    self.psse_graph.add_edge(buses[0], buses[1])\n                else:\n                    self.logger.debug(\n                        f\"Error parsing transformer data egde: {buses}.\"\n                        f\"\\nOne of the bus id does not exist in bus data\"\n                    )\n            else:\n                if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                    self.psse_graph.add_edge(buses[0], buses[1])\n                if buses[2] in self.bus_data and buses[1] in self.bus_data:\n                    self.psse_graph.add_edge(buses[1], buses[2])\n                if buses[2] in self.bus_data and buses[0] in self.bus_data:\n                    self.psse_graph.add_edge(buses[2], buses[0])\n                pass\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.reader.Reader","title":"<code>Reader</code>","text":"<p>Parser for indexing all PSSE model assets</p> Source code in <code>pypsse\\parsers\\reader.py</code> <pre><code>class Reader:\n    \"Parser for indexing all PSSE model assets\"\n\n    def __init__(self, psse_instance, logger):\n        self.psse = psse_instance\n        self.logger = logger\n        self.buses = self.get_data(\"abus\", tails=[\"int\"], strings=[\"NUMBER\"], flags=[2])\n        self.loads = self.get_data(\"aload\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ID\"], flags=[4, 4])\n        self.loads = self.get_data(\"aload\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ID\"], flags=[4, 4])\n        self.fixed_stunts = self.get_data(\"afxshunt\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ID\"], flags=[4, 4])\n        self.generators = self.get_data(\"amach\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ID\"], flags=[4, 4])\n        self.branches = self.get_data(\n            \"abrn\", tails=[\"int\", \"int\", \"char\"], strings=[\"FROMNUMBER\", \"TONUMBER\", \"ID\"], flags=[2, 2, 2]\n        )\n        self.transformers = self.get_data(\n            \"atr3\", tails=[\"int\", \"int\", \"int\"], strings=[\"WIND1NUMBER\", \"WIND2NUMBER\", \"WIND3NUMBER\"], flags=[2, 2, 2]\n        )\n        self.area = self.get_data(\n            \"aarea\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"AREANAME\"], flags=[2, 2]\n        )  # Talk to Aadil\n        self.dc_branch = self.get_data(\n            \"a2trmdc\", tails=[\"int\", \"int\"], strings=[\"FROMNUMBER\", \"TONUMBER\"], flags=[2, 2]\n        )  # three terminal dc lines not implemented\n        self.multi_term_dc = self.get_data(\n            \"amultitrmdc\", tails=[\"int\", \"int\"], strings=[\"VCNPOSNUMBER\", \"VCNNEGNUMBER\"], flags=[2, 2]\n        )\n        self.switched_shunt = self.get_data(\n            \"aswsh\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"DEVICENAME\"], flags=[4, 4]\n        )\n        self.zones = self.get_data(\"azone\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ZONENAME\"], flags=[2, 2])\n        self.owners = self.get_data(\"aowner\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"OWNERNAME\"], flags=[2, 2])\n\n    def get_data(self, func_name, tails=[], strings=[], flags=[]):\n        array_list = []\n        for tail, string, flag in zip(tails, strings, flags):\n            func = getattr(self.psse, func_name.lower() + tail)\n            ierr, array_1 = func(sid=-1, flag=flag, string=string)\n            assert ierr == 0, f\"Error code {ierr}, while running function '{func_name.lower() + tail}'\"\n            array_list.append([x for array in array_1 for x in array])\n\n        self.logger.info(f\"{func_name} count - {len(array_1)}\")\n        if len(array_list) == 1:\n            return array_list[0]\n\n        return list(zip(*array_list))\n</code></pre>"},{"location":"code/reference/#command-line-interface","title":"Command line interface","text":"<p>CLI to run a PyDSS project</p> <p>CLI to create a new PyPSSE project</p> <p>CLI to run a PyDSS project</p> <p>CLI to run the PyDSS server</p>"},{"location":"code/reference/#pypsse.cli.create_profiles.create_profiles","title":"<code>create_profiles(project_path, csv_file_path, profile_folder, profile_name, profile_type, start_time, profile_res, profile_info)</code>","text":"<p>Creates profiles for PyPSSE project.</p> Source code in <code>pypsse\\cli\\create_profiles.py</code> <pre><code>@click.argument(\n    \"project-path\",\n)\n@click.option(\n    \"-f\",\n    \"--csv-file-path\",\n    help=\"Path to a csv valid file\",\n    required=False,\n    default=\"\",\n)\n@click.option(\n    \"-p\",\n    \"--profile-folder\",\n    help=\"\"\"Path to folder containing csv profiles.\n    CSV file names should follow the following format: {profile-type}_{profile-name}\"\"\",\n    required=False,\n    default=\"\",\n)\n@click.option(\n    \"-n\",\n    \"--profile-name\",\n    required=False,\n    default=DEFAULT_PROFILE_NAME,\n    show_default=True,\n    help=\"Profile name\",\n)\n@click.option(\n    \"-t\",\n    \"--profile-type\",\n    required=False,\n    default=DEFAULT_PROFILE_TYPE,\n    show_default=True,\n    help=f\"Profile type; Possible values: {list(PROFILE_VALIDATION.keys())}\",\n)\n@click.option(\n    \"-T\",\n    \"--start-time\",\n    required=False,\n    default=DEFAULT_START_TIME,\n    show_default=True,\n    help=\"Time index for the first time step, format = Y-m-d H:M:S.f\",\n)\n@click.option(\n    \"-r\",\n    \"--profile-res\",\n    required=False,\n    default=DEFAULT_PROFILE_RESOLUTION,\n    show_default=True,\n    help=\"Profile time resolution in seconds\",\n)\n@click.option(\n    \"-i\",\n    \"--profile-info\",\n    required=False,\n    default=\"\",\n    show_default=True,\n    help=\"Profile time resolution in seconds\",\n)\n@click.command()\ndef create_profiles(\n    project_path, csv_file_path, profile_folder, profile_name, profile_type, start_time, profile_res, profile_info\n):\n    \"\"\"Creates profiles for PyPSSE project.\"\"\"\n    logging.root.setLevel(\"DEBUG\")\n    settings_file = os.path.join(project_path, \"Settings\", SIMULATION_SETTINGS_FILENAME)\n    if os.path.exists(settings_file):\n        if csv_file_path and os.path.exists(csv_file_path):\n            settings = toml.load(settings_file)\n            a = ProfileManager(None, None, settings, logging)\n            a.add_profiles_from_csv(\n                csv_file=csv_file_path,\n                name=profile_name,\n                pType=profile_type,\n                startTime=dt.datetime.strptime(start_time, \"%Y-%m-%d %H:%M:%S.%f\").astimezone(None),\n                resolution_sec=profile_res,\n                info=profile_info,\n            )\n            logging.info(f\"Profile '{profile_name}' added to group '{profile_type}'\")\n        elif os.path.exists(profile_folder):\n            settings = toml.load(settings_file)\n            a = ProfileManager(None, None, settings, logging)\n            for _, _, files in os.walk(profile_folder):\n                for file in files:\n                    if file.endswith(\".csv\"):\n                        filename = file.replace(\".csv\", \"\")\n                        if \"__\" in filename:\n                            dtype, p_name = filename.split(\"__\")\n                            a.add_profiles_from_csv(\n                                csv_file=os.path.join(profile_folder, file),\n                                name=p_name,\n                                pType=dtype,\n                                startTime=dt.datetime.strptime(start_time, \"%Y-%m-%d %H:%M:%S.%f\").astimezone(None),\n                                resolution_sec=profile_res,\n                                info=profile_info,\n                            )\n                            msg = f\"Profile '{p_name}'' added to group '{dtype}'\"\n                            logging.info(msg)\n        else:\n            msg = \"Value for either -f or -p flag has to be passed\"\n            raise Exception(msg)\n    else:\n        msg = f\"{project_path} is not a valid pypsse project\"\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.cli.create_project.create_project","title":"<code>create_project(path=None, project=None, psse_project_folder=None, simulation_file=None, export_settings_file=None, profile_store=None, profile_mapping=None, overwrite=None, autofill=None)</code>","text":"<p>Create a new PyPSSE project.</p> Source code in <code>pypsse\\cli\\create_project.py</code> <pre><code>@click.argument(\n    \"path\",\n)\n@click.option(\n    \"-p\",\n    \"--project\",\n    required=True,\n    help=\"project name\",\n)\n@click.option(\n    \"-F\",\n    \"--psse-project-folder\",\n    default=None,\n    required=False,\n    type=click.Path(exists=True),\n    help=\"PSS/E project folder path\",\n)\n@click.option(\n    \"-f\",\n    \"--simulation-file\",\n    required=False,\n    show_default=True,\n    default=\"\",\n    help=\"Simulation settings toml file path\",\n)\n@click.option(\n    \"-e\",\n    \"--export-settings-file\",\n    default=\"\",\n    help=\"Export settings toml file path\",\n)\n@click.option(\n    \"-s\",\n    \"--profile-store\",\n    default=\"\",\n    help=\"Path to a valid Profiles.hdf5 file (Contains profiles for time series simulations)\",\n)\n@click.option(\n    \"-m\",\n    \"--profile-mapping\",\n    default=\"\",\n    help=\"Path to a valid Profile_mapping.toml file (used to map profile to PSSE elements)\",\n)\n@click.option(\n    \"-a\",\n    \"--autofill\",\n    help=\"Attempt to auto fill settings. (Verify manually settings file is correct)\",\n    is_flag=True,\n    default=True,\n    show_default=True,\n)\n@click.option(\n    \"-o\",\n    \"--overwrite\",\n    help=\"Overwrite project is it already exists\",\n    is_flag=True,\n    default=True,\n    show_default=True,\n)\n@click.command()\ndef create_project(\n    path=None,\n    project=None,\n    psse_project_folder=None,\n    simulation_file=None,\n    export_settings_file=None,\n    profile_store=None,\n    profile_mapping=None,\n    overwrite=None,\n    autofill=None,\n):\n    \"\"\"Create a new PyPSSE project.\"\"\"\n    if os.path.exists(path):\n        s_settings = toml.load(simulation_file) if simulation_file else {}\n        e_settings = toml.load(export_settings_file) if export_settings_file else {}\n        # TODO: Validate settings\n        a = Project()\n        a.create(\n            path,\n            project,\n            psse_project_folder,\n            s_settings,\n            e_settings,\n            profile_store,\n            profile_mapping,\n            overwrite,\n            autofill,\n        )\n</code></pre>"},{"location":"code/reference/#pypsse.cli.run.run","title":"<code>run(project_path, simulations_file=None)</code>","text":"<p>Runs a valid PyPSSE simulation.</p> Source code in <code>pypsse\\cli\\run.py</code> <pre><code>@click.argument(\n    \"project-path\",\n)\n@click.option(\n    \"-s\",\n    \"--simulations-file\",\n    required=False,\n    default=SIMULATION_SETTINGS_FILENAME,\n    show_default=True,\n    help=\"scenario toml file to run (over rides default)\",\n)\n@click.command()\ndef run(project_path, simulations_file=None):\n    \"\"\"Runs a valid PyPSSE simulation.\"\"\"\n    path = os.path.join(project_path, simulations_file)\n    if os.path.exists(path):\n        x = Simulator(path)\n        # x.init()\n        x.run()\n    else:\n        msg = f\"'{path}' is not a valid path.\"\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.cli.serve.serve","title":"<code>serve(host_ip='127.0.0.1', port=9090)</code>","text":"<p>Run a PyPSSE RESTful API server.</p> Source code in <code>pypsse\\cli\\serve.py</code> <pre><code>@click.option(\n    \"-p\",\n    \"--port\",\n    default=9090,\n    show_default=True,\n    help=\"Socket port for the server\",\n)\n@click.option(\n    \"-h\",\n    \"--host-ip\",\n    default=\"127.0.0.1\",\n    show_default=True,\n    help=\"IP for the server\",\n)\n@click.command()\ndef serve(host_ip=\"127.0.0.1\", port=9090):\n    \"\"\"Run a PyPSSE RESTful API server.\"\"\"\n    timestamp_format = \"%(asctime)s - %(levelname)s - %(message)s\"\n    logging.basicConfig(level=logging.INFO, format=timestamp_format)\n    pydss = PSSEServer(host_ip, port)\n    web.run_app(host=host_ip, port=port, app=pydss.app)\n</code></pre>"},{"location":"code/reference/#data-interfaces","title":"Data interfaces","text":""},{"location":"code/reference/#pypsse.data_writers.data_writer.DataWriter","title":"<code>DataWriter</code>","text":"<p>Data writer class defination</p> Source code in <code>pypsse\\data_writers\\data_writer.py</code> <pre><code>class DataWriter:\n    \"Data writer class defination\"\n    modes = {\n        \"h5\": HDF5Writer,\n        \"csv\": CSVWriter,\n        \"json\": JSONWriter,\n        \"none\": DummyWriter,\n    }\n\n    def __init__(self, log_dir, formatnm, column_length):\n        \"Sets up a data writer as per user input\"\n        self.writer = self.modes[formatnm](log_dir, column_length)\n\n    def write(self, currenttime, powerflow_output):\n        \"Enables incremental write to the data writer object\"\n        self.writer.write(currenttime, powerflow_output)\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.data_writer.DataWriter.__init__","title":"<code>__init__(log_dir, formatnm, column_length)</code>","text":"<p>Sets up a data writer as per user input</p> Source code in <code>pypsse\\data_writers\\data_writer.py</code> <pre><code>def __init__(self, log_dir, formatnm, column_length):\n    \"Sets up a data writer as per user input\"\n    self.writer = self.modes[formatnm](log_dir, column_length)\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.data_writer.DataWriter.write","title":"<code>write(currenttime, powerflow_output)</code>","text":"<p>Enables incremental write to the data writer object</p> Source code in <code>pypsse\\data_writers\\data_writer.py</code> <pre><code>def write(self, currenttime, powerflow_output):\n    \"Enables incremental write to the data writer object\"\n    self.writer.write(currenttime, powerflow_output)\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.csv.CSVWriter","title":"<code>CSVWriter</code>","text":"<p>Class that handles writing simulation results to arrow files.</p> Source code in <code>pypsse\\data_writers\\csv.py</code> <pre><code>class CSVWriter:\n    \"\"\"Class that handles writing simulation results to arrow\n    files.\n    \"\"\"\n\n    def __init__(self, log_dir, column_length):\n        \"\"\"Constructor\"\"\"\n        self.column_length = column_length\n        self.log_dir = log_dir\n        self.timestamps = []\n        self.chunkRows = 1\n        self.dfs = {}\n        self.step = 0\n        # Create arrow writer for each object type\n\n    def write(self, currenttime, powerflow_output):\n        \"\"\"\n        Writes the status of BES assets at a particular timestep to an\n            arrow file.\n\n        :param fed_name: name of BES federate\n        :param log_fields: list of objects to log\n        :param currenttime: simulation timestep\n        :param powerflow_output: Powerflow solver timestep output as a dict\n        \"\"\"\n        # Iterate through each object type\n        self.timestamps.append(currenttime)\n        for obj_type in powerflow_output:\n            data = powerflow_output[obj_type]\n            if obj_type not in self.dfs:\n                self.dfs[obj_type] = [data]\n            else:\n                if self.dfs[obj_type] is None:\n                    self.dfs[obj_type] = [data]\n                else:\n                    self.dfs[obj_type].append(data)\n\n            if self.step % self.chunkRows == self.chunkRows - 1:\n                fpath = os.path.join(self.log_dir, f\"{obj_type}.csv\")\n                self.dfs[obj_type] = pd.DataFrame(self.dfs[obj_type], index=self.timestamps)\n                self.dfs[obj_type].to_csv(fpath, mode=\"a\")\n\n                self.dfs[obj_type] = None\n            self.Timestamp[self.step - 1] = np.string_(str(currenttime))\n        self.step += 1\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.csv.CSVWriter.__init__","title":"<code>__init__(log_dir, column_length)</code>","text":"<p>Constructor</p> Source code in <code>pypsse\\data_writers\\csv.py</code> <pre><code>def __init__(self, log_dir, column_length):\n    \"\"\"Constructor\"\"\"\n    self.column_length = column_length\n    self.log_dir = log_dir\n    self.timestamps = []\n    self.chunkRows = 1\n    self.dfs = {}\n    self.step = 0\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.csv.CSVWriter.write","title":"<code>write(currenttime, powerflow_output)</code>","text":"<p>Writes the status of BES assets at a particular timestep to an     arrow file.</p> <p>:param fed_name: name of BES federate :param log_fields: list of objects to log :param currenttime: simulation timestep :param powerflow_output: Powerflow solver timestep output as a dict</p> Source code in <code>pypsse\\data_writers\\csv.py</code> <pre><code>def write(self, currenttime, powerflow_output):\n    \"\"\"\n    Writes the status of BES assets at a particular timestep to an\n        arrow file.\n\n    :param fed_name: name of BES federate\n    :param log_fields: list of objects to log\n    :param currenttime: simulation timestep\n    :param powerflow_output: Powerflow solver timestep output as a dict\n    \"\"\"\n    # Iterate through each object type\n    self.timestamps.append(currenttime)\n    for obj_type in powerflow_output:\n        data = powerflow_output[obj_type]\n        if obj_type not in self.dfs:\n            self.dfs[obj_type] = [data]\n        else:\n            if self.dfs[obj_type] is None:\n                self.dfs[obj_type] = [data]\n            else:\n                self.dfs[obj_type].append(data)\n\n        if self.step % self.chunkRows == self.chunkRows - 1:\n            fpath = os.path.join(self.log_dir, f\"{obj_type}.csv\")\n            self.dfs[obj_type] = pd.DataFrame(self.dfs[obj_type], index=self.timestamps)\n            self.dfs[obj_type].to_csv(fpath, mode=\"a\")\n\n            self.dfs[obj_type] = None\n        self.Timestamp[self.step - 1] = np.string_(str(currenttime))\n    self.step += 1\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.json.JSONWriter","title":"<code>JSONWriter</code>","text":"<p>Class that handles writing simulation results to arrow files.</p> Source code in <code>pypsse\\data_writers\\json.py</code> <pre><code>class JSONWriter:\n    \"\"\"Class that handles writing simulation results to arrow\n    files.\n    \"\"\"\n\n    def __init__(self, log_dir, column_length):\n        \"\"\"Constructor\"\"\"\n        self.column_length = column_length\n        self.log_dir = log_dir\n        self.chunk_rows = 1\n        self.handles = {}\n        self.dfs = {}\n        self.step = 0\n        # Create arrow writer for each object type\n\n    def write(self, currenttime, powerflow_output):\n        \"\"\"\n        Writes the status of BES assets at a particular timestep to an\n            arrow file.\n\n        :param fed_name: name of BES federate\n        :param log_fields: list of objects to log\n        :param currenttime: simulation timestep\n        :param powerflow_output: Powerflow solver timestep output as a dict\n        \"\"\"\n        # Iterate through each object type\n\n        for obj_type in powerflow_output:\n            fpath = os.path.join(self.log_dir, f\"{obj_type}.json\")\n            if self.step == 0:\n                f = open(fpath, \"w\")\n                f.close()\n                self.handles[obj_type] = open(fpath, \"a\")\n            data = powerflow_output[obj_type]\n            if obj_type not in self.dfs:\n                self.dfs[obj_type] = {str(currenttime): data}\n            else:\n                if self.dfs[obj_type] is None:\n                    self.dfs[obj_type] = {str(currenttime): data}\n                else:\n                    self.dfs[obj_type][currenttime] = data\n            if self.step % self.chunk_rows == self.chunk_rows - 1:\n                try:\n                    json.dump(self.dfs[obj_type], self.handles[obj_type], indent=4)\n                    self.handles[obj_type].flush()\n                    self.dfs[obj_type] = None\n                except Exception as E:\n                    logger.warning(f\"Unable to write property {obj_type} to file: {E!s}\")\n\n        self.step += 1\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.json.JSONWriter.__init__","title":"<code>__init__(log_dir, column_length)</code>","text":"<p>Constructor</p> Source code in <code>pypsse\\data_writers\\json.py</code> <pre><code>def __init__(self, log_dir, column_length):\n    \"\"\"Constructor\"\"\"\n    self.column_length = column_length\n    self.log_dir = log_dir\n    self.chunk_rows = 1\n    self.handles = {}\n    self.dfs = {}\n    self.step = 0\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.json.JSONWriter.write","title":"<code>write(currenttime, powerflow_output)</code>","text":"<p>Writes the status of BES assets at a particular timestep to an     arrow file.</p> <p>:param fed_name: name of BES federate :param log_fields: list of objects to log :param currenttime: simulation timestep :param powerflow_output: Powerflow solver timestep output as a dict</p> Source code in <code>pypsse\\data_writers\\json.py</code> <pre><code>def write(self, currenttime, powerflow_output):\n    \"\"\"\n    Writes the status of BES assets at a particular timestep to an\n        arrow file.\n\n    :param fed_name: name of BES federate\n    :param log_fields: list of objects to log\n    :param currenttime: simulation timestep\n    :param powerflow_output: Powerflow solver timestep output as a dict\n    \"\"\"\n    # Iterate through each object type\n\n    for obj_type in powerflow_output:\n        fpath = os.path.join(self.log_dir, f\"{obj_type}.json\")\n        if self.step == 0:\n            f = open(fpath, \"w\")\n            f.close()\n            self.handles[obj_type] = open(fpath, \"a\")\n        data = powerflow_output[obj_type]\n        if obj_type not in self.dfs:\n            self.dfs[obj_type] = {str(currenttime): data}\n        else:\n            if self.dfs[obj_type] is None:\n                self.dfs[obj_type] = {str(currenttime): data}\n            else:\n                self.dfs[obj_type][currenttime] = data\n        if self.step % self.chunk_rows == self.chunk_rows - 1:\n            try:\n                json.dump(self.dfs[obj_type], self.handles[obj_type], indent=4)\n                self.handles[obj_type].flush()\n                self.dfs[obj_type] = None\n            except Exception as E:\n                logger.warning(f\"Unable to write property {obj_type} to file: {E!s}\")\n\n    self.step += 1\n</code></pre>"},{"location":"code/reference/#utility-functions","title":"Utility functions","text":""},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils","title":"<code>DynamicUtils</code>","text":"<p>Utility functions for dynamic simulations</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>class DynamicUtils:\n    \"Utility functions for dynamic simulations\"\n\n    dynamic_params: ClassVar[List[str]] = [\"FmA\", \"FmB\", \"FmC\", \"FmD\", \"Fel\"]\n\n    def disable_generation_for_coupled_buses(self):\n        \"Disables generation of coupled buses (co-simulation mode only)\"\n        if (\n            self.settings.helics\n            and self.settings.helics.cosimulation_mode\n            and self.settings.helics.disable_generation_on_coupled_buses\n        ):\n            sub_data = pd.read_csv(self.settings.simulation.subscriptions_file)\n            sub_data = sub_data[sub_data[\"element_type\"] == \"Load\"]\n            generators = {}\n            generator_list = {}\n\n            for gen_bus, gen_id in self.raw_data.generators:\n                if gen_bus not in generator_list:\n                    generator_list[gen_bus] = []\n                generator_list[gen_bus].append(gen_id)\n\n            for _, row in sub_data.iterrows():\n                bus = row[\"bus\"]\n                generators[bus] = generator_list[bus]\n\n            for bus_id, machines in generators.items():\n                for machine in machines:\n                    intgar = [0, self._i, self._i, self._i, self._i, self._i]\n                    realar = [\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                    ]\n                    self.psse.machine_chng_2(bus_id, machine, intgar, realar)\n                    self.logger.info(f\"Machine disabled: {bus_id}_{machine}\")\n\n    def disable_load_models_for_coupled_buses(self):\n        \"Disables loads of coupled buses (co-simulation mode only)\"\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            sub_data = pd.read_csv(self.settings.simulation.subscriptions_file)\n            sub_data = sub_data[sub_data[\"element_type\"] == \"Load\"]\n\n            self.psse_dict = {}\n            for _, row in sub_data.iterrows():\n                bus = row[\"bus\"]\n                load = row[\"element_id\"]\n                ierr = self.psse.ldmod_status(0, int(bus), str(load), 1, 0)\n                assert ierr == 0, f\"error={ierr}\"\n                self.logger.error(f\"Dynamic model for load {load} connected to bus {bus} has been disabled\")\n\n    def break_loads(self, loads=None, components_to_replace: List[str] = []):\n        \"Implements the load split logic\"\n        components_to_stay = [x for x in self.dynamic_params if x not in components_to_replace]\n        if loads is None:\n            loads = self._get_coupled_loads()\n        loads = self._get_load_static_data(loads)\n        loads = self._get_load_dynamic_data(loads)\n        loads = self._replicate_coupled_load(loads, components_to_replace)\n        self._update_dynamic_parameters(loads, components_to_stay, components_to_replace)\n\n    def _update_dynamic_parameters(self, loads, components_to_stay, components_to_replace):\n        \"Updates dynamic parameters of composite load models\"\n        new_percentages = {}\n        for load in loads:\n            count = 0\n            for comp in components_to_stay:\n                count += load[comp]\n            for comp in components_to_stay:\n                new_percentages[comp] = load[comp] / count\n            for comp in components_to_replace:\n                new_percentages[comp] = 0.0\n\n            settings = self._get_load_dynamic_properties(load)\n            #\n            for k, v in new_percentages.items():\n                idx = dyn_only_options[\"Loads\"][\"lmodind\"][k]\n                settings[idx] = v\n                # self.psse.change_ldmod_con(load['bus'], 'XX' ,r\"\"\"CMLDBLU2\"\"\" ,idx ,v)\n            values = list(settings.values())\n            self.psse.add_load_model(load[\"bus\"], \"XX\", 0, 1, r\"\"\"CMLDBLU2\"\"\", 2, [0, 0], [\"\", \"\"], 133, values)\n            self.logger.info(f\"Dynamic model parameters for load {load['id']} at bus 'XX' changed.\")\n\n    def _get_load_dynamic_properties(self, load):\n        \"Returns dynamic parameters of composite load models\"\n        settings = {}\n        for i in range(133):\n            ierr, con_index = self.psse.lmodind(load[\"bus\"], str(load[\"id\"]), \"CHARAC\", \"CON\")\n            if con_index is not None:\n                act_con_index = con_index + i\n                ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n                assert ierr == 0, f\"error={ierr}\"\n                settings[i] = value\n        return settings\n\n    def _replicate_coupled_load(self, loads, components_to_replace):\n        \"Create a replica of composite load model\"\n        for load in loads:\n            dynamic_percentage = load[\"FmA\"] + load[\"FmB\"] + load[\"FmC\"] + load[\"FmD\"] + load[\"Fel\"]\n            static_percentage = 1.0 - dynamic_percentage\n            for comp in components_to_replace:\n                static_percentage += load[comp]\n            remaining_load = 1 - static_percentage\n            total_load = load[\"MVA\"]\n            total_distribution_load = total_load * static_percentage\n            total_transmission_load = total_load * remaining_load\n            # ceate new load\n            self.psse.load_data_5(\n                load[\"bus\"],\n                \"XX\",\n                realar=[total_transmission_load.real, total_transmission_load.imag, 0.0, 0.0, 0.0, 0.0],\n                lodtyp=\"replica\",\n            )\n            # ierr, cmpval = self.psse.loddt2(load[\"bus\"], \"XX\" ,\"MVA\" , \"ACT\")\n            # modify old load\n            self.psse.load_data_5(\n                load[\"bus\"],\n                str(load[\"id\"]),\n                realar=[total_distribution_load.real, total_distribution_load.imag, 0.0, 0.0, 0.0, 0.0],\n                lodtyp=\"original\",\n            )\n            # ierr, cmpval = self.psse.loddt2(load[\"bus\"], load[\"id\"] ,\"MVA\" , \"ACT\")\n            self.logger.info(f\"Original load {load['id']} @ bus {load['bus']}: {total_load}\")\n            self.logger.info(f\"New load 'XX' @ bus {load['bus']} created successfully: {total_transmission_load}\")\n            self.logger.info(f\"Load {load['id']} @ bus {load['bus']} updated : {total_distribution_load}\")\n            load[\"distribution\"] = total_distribution_load\n            load[\"transmission\"] = total_transmission_load\n        return loads\n\n    def _get_coupled_loads(self):\n        \"Returns a list of all coupled loads ina give simualtion\"\n\n        sub_data = pd.read_csv(\n            os.path.join(\n                self.settings[\"Simulation\"][\"Project Path\"], \"Settings\", self.settings[\"HELICS\"][\"Subscriptions file\"]\n            )\n        )\n        load = []\n        for _, row in sub_data.iterrows():\n            if row[\"element_type\"] == \"Load\":\n                load.append(\n                    {\n                        \"type\": row[\"element_type\"],\n                        \"id\": row[\"element_id\"],\n                        \"bus\": row[\"bus\"],\n                    }\n                )\n        return load\n\n    def _get_load_static_data(self, loads):\n        \"Returns static data for load models\"\n\n        values = [\"MVA\", \"IL\", \"YL\", \"TOTAL\"]\n        for load in loads:\n            for v in values:\n                ierr, cmpval = self.psse.loddt2(load[\"bus\"], str(load[\"id\"]), v, \"ACT\")\n                load[v] = cmpval\n        return loads\n\n    def _get_load_dynamic_data(self, loads):\n        \"Returns dynamic data for load models\"\n        values = dyn_only_options[\"Loads\"][\"lmodind\"]\n        for load in loads:\n            for v, con_ind in values.items():\n                ierr = self.psse.inilod(load[\"bus\"])\n                assert ierr == 0, f\"error={ierr}\"\n                ierr, ld_id = self.psse.nxtlod(load[\"bus\"])\n                assert ierr == 0, f\"error={ierr}\"\n                if ld_id is not None:\n                    ierr, con_index = self.psse.lmodind(load[\"bus\"], ld_id, \"CHARAC\", \"CON\")\n                    assert ierr == 0, f\"error={ierr}\"\n                    if con_index is not None:\n                        act_con_index = con_index + con_ind\n                        ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n                        assert ierr == 0, f\"error={ierr}\"\n                        load[v] = value\n        return loads\n\n    def setup_machine_channels(self, machines, properties):\n        \"Sets up machine channels\"\n        for _, qty in enumerate(properties):\n            if qty not in self.channel_map:\n                nqty = f\"MACHINE_{qty}\"\n                self.channel_map[nqty] = {}\n            for mch, b in machines:\n                if qty in MACHINE_CHANNELS:\n                    self.channel_map[nqty][f\"{b}_{mch}\"] = [self.chnl_idx]\n                    chnl_id = MACHINE_CHANNELS[qty]\n                    self.logger.info(f\"{qty} for machine {b}_{mch} added to channel {self.chnl_idx}\")\n                    self.psse.machine_array_channel([self.chnl_idx, chnl_id, int(b)], mch, \"\")\n                    self.chnl_idx += 1\n\n    def setup_load_channels(self, loads):\n        \"Sets up load channels\"\n\n        if \"LOAD_P\" not in self.channel_map:\n            self.channel_map[\"LOAD_P\"] = {}\n            self.channel_map[\"LOAD_Q\"] = {}\n\n        for ld, b in loads:\n            self.channel_map[\"LOAD_P\"][f\"{b}_{ld}\"] = [self.chnl_idx]\n            self.channel_map[\"LOAD_Q\"][f\"{b}_{ld}\"] = [self.chnl_idx + 1]\n            self.psse.load_array_channel([self.chnl_idx, 1, int(b)], ld, \"\")\n            self.psse.load_array_channel([self.chnl_idx + 1, 2, int(b)], ld, \"\")\n            self.logger.info(f\"P and Q for load {b}_{ld} added to channel {self.chnl_idx} and {self.chnl_idx + 1}\")\n            self.chnl_idx += 2\n\n    def setup_bus_channels(self, buses, properties):\n        \"Sets up bus channels\"\n\n        for _, qty in enumerate(properties):\n            if qty not in self.channel_map:\n                self.channel_map[qty] = {}\n            for _, b in enumerate(buses):\n                if qty == \"frequency\":\n                    self.channel_map[qty][b] = [self.chnl_idx]\n                    self.psse.bus_frequency_channel([self.chnl_idx, int(b)], \"\")\n                    self.logger.info(f\"Frequency for bus {b} added to channel { self.chnl_idx}\")\n                    self.chnl_idx += 1\n                elif qty == \"voltage_and_angle\":\n                    self.channel_map[qty][b] = [self.chnl_idx, self.chnl_idx + 1]\n                    self.psse.voltage_and_angle_channel([self.chnl_idx, -1, -1, int(b)], \"\")\n                    self.logger.info(\n                        f\"Voltage and angle for bus {b} added to channel {self.chnl_idx} and {self.chnl_idx+1}\"\n                    )\n                    self.chnl_idx += 2\n\n    def poll_channels(self):\n        \"Polls all channels adde during the setup process\"\n\n        results = {}\n        for ppty, b_dict in self.channel_map.items():\n            ppty_new = ppty.split(\"_and_\")\n            for b, indices in b_dict.items():\n                for n, idx in zip(ppty_new, indices):\n                    if \"_\" not in n:\n                        n_name = f\"BUS_{n}\"\n                    else:\n                        n_name = n\n                    if n_name not in results:\n                        results[n_name] = {}\n                    ierr, value = self.psse.chnval(idx)\n                    assert ierr == 0, f\"error={ierr}\"\n                    if value is None:\n                        value = -1\n                    results[n_name][b] = value\n        return results\n\n    def setup_all_channels(self):\n        \"Sets up all user-defined channels for a project\"\n\n        self.channel_map = {}\n        self.chnl_idx = 1\n        if not self.export_settings.channel_setup:\n            return\n\n        for channel in self.export_settings.channel_setup:\n            method_type = channel.type.value\n            if method_type == \"buses\":\n                self.setup_bus_channels(channel.list, channel.properties)\n            elif method_type == \"loads\":\n                load_list = [[x, int(y)] for x, y in channel.list]\n                self.setup_load_channels(load_list)\n            elif method_type == \"machines\":\n                machine_list = [[x, int(y)] for x, y in channel.list]\n                self.setup_machine_channels(machine_list, channel.properties)\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.break_loads","title":"<code>break_loads(loads=None, components_to_replace=[])</code>","text":"<p>Implements the load split logic</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def break_loads(self, loads=None, components_to_replace: List[str] = []):\n    \"Implements the load split logic\"\n    components_to_stay = [x for x in self.dynamic_params if x not in components_to_replace]\n    if loads is None:\n        loads = self._get_coupled_loads()\n    loads = self._get_load_static_data(loads)\n    loads = self._get_load_dynamic_data(loads)\n    loads = self._replicate_coupled_load(loads, components_to_replace)\n    self._update_dynamic_parameters(loads, components_to_stay, components_to_replace)\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.disable_generation_for_coupled_buses","title":"<code>disable_generation_for_coupled_buses()</code>","text":"<p>Disables generation of coupled buses (co-simulation mode only)</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def disable_generation_for_coupled_buses(self):\n    \"Disables generation of coupled buses (co-simulation mode only)\"\n    if (\n        self.settings.helics\n        and self.settings.helics.cosimulation_mode\n        and self.settings.helics.disable_generation_on_coupled_buses\n    ):\n        sub_data = pd.read_csv(self.settings.simulation.subscriptions_file)\n        sub_data = sub_data[sub_data[\"element_type\"] == \"Load\"]\n        generators = {}\n        generator_list = {}\n\n        for gen_bus, gen_id in self.raw_data.generators:\n            if gen_bus not in generator_list:\n                generator_list[gen_bus] = []\n            generator_list[gen_bus].append(gen_id)\n\n        for _, row in sub_data.iterrows():\n            bus = row[\"bus\"]\n            generators[bus] = generator_list[bus]\n\n        for bus_id, machines in generators.items():\n            for machine in machines:\n                intgar = [0, self._i, self._i, self._i, self._i, self._i]\n                realar = [\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                ]\n                self.psse.machine_chng_2(bus_id, machine, intgar, realar)\n                self.logger.info(f\"Machine disabled: {bus_id}_{machine}\")\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.disable_load_models_for_coupled_buses","title":"<code>disable_load_models_for_coupled_buses()</code>","text":"<p>Disables loads of coupled buses (co-simulation mode only)</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def disable_load_models_for_coupled_buses(self):\n    \"Disables loads of coupled buses (co-simulation mode only)\"\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        sub_data = pd.read_csv(self.settings.simulation.subscriptions_file)\n        sub_data = sub_data[sub_data[\"element_type\"] == \"Load\"]\n\n        self.psse_dict = {}\n        for _, row in sub_data.iterrows():\n            bus = row[\"bus\"]\n            load = row[\"element_id\"]\n            ierr = self.psse.ldmod_status(0, int(bus), str(load), 1, 0)\n            assert ierr == 0, f\"error={ierr}\"\n            self.logger.error(f\"Dynamic model for load {load} connected to bus {bus} has been disabled\")\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.poll_channels","title":"<code>poll_channels()</code>","text":"<p>Polls all channels adde during the setup process</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def poll_channels(self):\n    \"Polls all channels adde during the setup process\"\n\n    results = {}\n    for ppty, b_dict in self.channel_map.items():\n        ppty_new = ppty.split(\"_and_\")\n        for b, indices in b_dict.items():\n            for n, idx in zip(ppty_new, indices):\n                if \"_\" not in n:\n                    n_name = f\"BUS_{n}\"\n                else:\n                    n_name = n\n                if n_name not in results:\n                    results[n_name] = {}\n                ierr, value = self.psse.chnval(idx)\n                assert ierr == 0, f\"error={ierr}\"\n                if value is None:\n                    value = -1\n                results[n_name][b] = value\n    return results\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.setup_all_channels","title":"<code>setup_all_channels()</code>","text":"<p>Sets up all user-defined channels for a project</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def setup_all_channels(self):\n    \"Sets up all user-defined channels for a project\"\n\n    self.channel_map = {}\n    self.chnl_idx = 1\n    if not self.export_settings.channel_setup:\n        return\n\n    for channel in self.export_settings.channel_setup:\n        method_type = channel.type.value\n        if method_type == \"buses\":\n            self.setup_bus_channels(channel.list, channel.properties)\n        elif method_type == \"loads\":\n            load_list = [[x, int(y)] for x, y in channel.list]\n            self.setup_load_channels(load_list)\n        elif method_type == \"machines\":\n            machine_list = [[x, int(y)] for x, y in channel.list]\n            self.setup_machine_channels(machine_list, channel.properties)\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.setup_bus_channels","title":"<code>setup_bus_channels(buses, properties)</code>","text":"<p>Sets up bus channels</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def setup_bus_channels(self, buses, properties):\n    \"Sets up bus channels\"\n\n    for _, qty in enumerate(properties):\n        if qty not in self.channel_map:\n            self.channel_map[qty] = {}\n        for _, b in enumerate(buses):\n            if qty == \"frequency\":\n                self.channel_map[qty][b] = [self.chnl_idx]\n                self.psse.bus_frequency_channel([self.chnl_idx, int(b)], \"\")\n                self.logger.info(f\"Frequency for bus {b} added to channel { self.chnl_idx}\")\n                self.chnl_idx += 1\n            elif qty == \"voltage_and_angle\":\n                self.channel_map[qty][b] = [self.chnl_idx, self.chnl_idx + 1]\n                self.psse.voltage_and_angle_channel([self.chnl_idx, -1, -1, int(b)], \"\")\n                self.logger.info(\n                    f\"Voltage and angle for bus {b} added to channel {self.chnl_idx} and {self.chnl_idx+1}\"\n                )\n                self.chnl_idx += 2\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.setup_load_channels","title":"<code>setup_load_channels(loads)</code>","text":"<p>Sets up load channels</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def setup_load_channels(self, loads):\n    \"Sets up load channels\"\n\n    if \"LOAD_P\" not in self.channel_map:\n        self.channel_map[\"LOAD_P\"] = {}\n        self.channel_map[\"LOAD_Q\"] = {}\n\n    for ld, b in loads:\n        self.channel_map[\"LOAD_P\"][f\"{b}_{ld}\"] = [self.chnl_idx]\n        self.channel_map[\"LOAD_Q\"][f\"{b}_{ld}\"] = [self.chnl_idx + 1]\n        self.psse.load_array_channel([self.chnl_idx, 1, int(b)], ld, \"\")\n        self.psse.load_array_channel([self.chnl_idx + 1, 2, int(b)], ld, \"\")\n        self.logger.info(f\"P and Q for load {b}_{ld} added to channel {self.chnl_idx} and {self.chnl_idx + 1}\")\n        self.chnl_idx += 2\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.setup_machine_channels","title":"<code>setup_machine_channels(machines, properties)</code>","text":"<p>Sets up machine channels</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def setup_machine_channels(self, machines, properties):\n    \"Sets up machine channels\"\n    for _, qty in enumerate(properties):\n        if qty not in self.channel_map:\n            nqty = f\"MACHINE_{qty}\"\n            self.channel_map[nqty] = {}\n        for mch, b in machines:\n            if qty in MACHINE_CHANNELS:\n                self.channel_map[nqty][f\"{b}_{mch}\"] = [self.chnl_idx]\n                chnl_id = MACHINE_CHANNELS[qty]\n                self.logger.info(f\"{qty} for machine {b}_{mch} added to channel {self.chnl_idx}\")\n                self.psse.machine_array_channel([self.chnl_idx, chnl_id, int(b)], mch, \"\")\n                self.chnl_idx += 1\n</code></pre>"},{"location":"code/reference/#contincency-interface","title":"Contincency interface","text":"<p>This module manages contingency modeling in PyPSSE</p>"},{"location":"code/reference/#pypsse.contingencies.BaseFault","title":"<code>BaseFault</code>","text":"<p>Base class defination for all fault types</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class BaseFault:\n    \"Base class defination for all fault types\"\n    __metaclass__ = ABCMeta\n\n    requirements = []\n    fault_settings = {}\n    fault_method = \"\"\n    element = None\n\n    def __init__(self, psse, settings, logger, contingency_type):\n        self.contingency_type = contingency_type\n        self.settings = settings\n        self.logger = logger\n        self.psse = psse\n        self.enabled = False\n        self.tripped = False\n\n    def update(self, t):\n        \"updates a fault event\"\n        self.t = t\n        if hasattr(self.settings, \"duration\"):\n            if self.settings.time + self.settings.duration &gt; t &gt;= self.settings.time and not self.enabled:\n                self.enabled = True\n                self.enable_fault()\n            if t &gt;= self.settings.time + self.settings.duration and self.enabled:\n                self.enabled = False\n                self.disable_fault()\n        elif not hasattr(self.settings, \"duration\") and t &gt;= self.settings.time and not self.tripped:\n            self.enable_fault()\n            self.tripped = True\n\n    def enable_fault(self):\n        \"Enables a fault event\"\n        err = getattr(self.psse, self.fault_method)(**self.fault_settings)\n        if err:\n            self.logger.warning(f\"Unable to enable {self.fault_method} at element {self.element}\")\n        else:\n            self.logger.debug(f\"{self.fault_method} applied to {self.element} at time {self.t} seconds\")\n\n    def disable_fault(self):\n        \"Disables a fault event\"\n        err = self.psse.dist_clear_fault()\n        if err:\n            self.logger.warning(f\"Unable to clear {self.fault_method} at element {self.element}\")\n        else:\n            self.logger.debug(f\"{self.fault_method} cleared at element {self.element} at time {self.t} seconds\")\n\n    def is_enabled(self):\n        \"Returns true if the fault object is enabled else false\"\n        return self.enabled\n\n    def is_tripped(self):\n        \"Returns true if the fault object is tripped else false\"\n        return self.tripped\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BaseFault.disable_fault","title":"<code>disable_fault()</code>","text":"<p>Disables a fault event</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def disable_fault(self):\n    \"Disables a fault event\"\n    err = self.psse.dist_clear_fault()\n    if err:\n        self.logger.warning(f\"Unable to clear {self.fault_method} at element {self.element}\")\n    else:\n        self.logger.debug(f\"{self.fault_method} cleared at element {self.element} at time {self.t} seconds\")\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BaseFault.enable_fault","title":"<code>enable_fault()</code>","text":"<p>Enables a fault event</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def enable_fault(self):\n    \"Enables a fault event\"\n    err = getattr(self.psse, self.fault_method)(**self.fault_settings)\n    if err:\n        self.logger.warning(f\"Unable to enable {self.fault_method} at element {self.element}\")\n    else:\n        self.logger.debug(f\"{self.fault_method} applied to {self.element} at time {self.t} seconds\")\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BaseFault.is_enabled","title":"<code>is_enabled()</code>","text":"<p>Returns true if the fault object is enabled else false</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def is_enabled(self):\n    \"Returns true if the fault object is enabled else false\"\n    return self.enabled\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BaseFault.is_tripped","title":"<code>is_tripped()</code>","text":"<p>Returns true if the fault object is tripped else false</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def is_tripped(self):\n    \"Returns true if the fault object is tripped else false\"\n    return self.tripped\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BaseFault.update","title":"<code>update(t)</code>","text":"<p>updates a fault event</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def update(self, t):\n    \"updates a fault event\"\n    self.t = t\n    if hasattr(self.settings, \"duration\"):\n        if self.settings.time + self.settings.duration &gt; t &gt;= self.settings.time and not self.enabled:\n            self.enabled = True\n            self.enable_fault()\n        if t &gt;= self.settings.time + self.settings.duration and self.enabled:\n            self.enabled = False\n            self.disable_fault()\n    elif not hasattr(self.settings, \"duration\") and t &gt;= self.settings.time and not self.tripped:\n        self.enable_fault()\n        self.tripped = True\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BusFault","title":"<code>BusFault</code>","text":"<p>             Bases: <code>BaseFault</code></p> <p>Class defination for a bus fault</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class BusFault(BaseFault):\n    \"Class defination for a bus fault\"\n    fault_method = \"dist_bus_fault\"\n    fault_settings = {}\n\n    def __init__(self, psse, settings: BusFault, logger, contingency_type):\n        super().__init__(psse, settings, logger, contingency_type)\n        self.fault_settings[\"ibus\"] = settings.bus_id\n        self.fault_settings[\"units\"] = 3\n        self.fault_settings[\"values\"] = settings.fault_impedance\n        self.fault_settings[\"basekv\"] = 0.0\n        self.element = settings.bus_id\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BusTrip","title":"<code>BusTrip</code>","text":"<p>             Bases: <code>BaseFault</code></p> <p>Class defination for a bus trip</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class BusTrip(BaseFault):\n    \"Class defination for a bus trip\"\n    fault_method = \"dist_bus_trip\"\n    fault_settings = {}\n\n    def __init__(self, psse, settings: BusTrip, logger, contingency_type):\n        super().__init__(psse, settings, logger, contingency_type)\n        self.fault_settings[\"ibus\"] = settings.bus_id\n        self.element = settings.bus_id\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.LineFault","title":"<code>LineFault</code>","text":"<p>             Bases: <code>BaseFault</code></p> <p>Class defination for a line fault</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class LineFault(BaseFault):\n    \"Class defination for a line fault\"\n    fault_method = \"dist_branch_fault\"\n    fault_settings = {}\n\n    def __init__(self, psse, settings: LineFault, logger, contingency_type):\n        super().__init__(psse, settings, logger, contingency_type)\n        self.fault_settings[\"ibus\"] = settings.bus_ids[0]\n        self.fault_settings[\"jbus\"] = settings.bus_ids[1]\n        self.fault_settings[\"id\"] = settings.bus_ids[2]\n        self.fault_settings[\"units\"] = 3\n        self.fault_settings[\"values\"] = settings.fault_impedance\n        self.fault_settings[\"basekv\"] = 0.0\n        self.element = settings.bus_ids\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.LineTrip","title":"<code>LineTrip</code>","text":"<p>             Bases: <code>BaseFault</code></p> <p>Class defination for a line trip</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class LineTrip(BaseFault):\n    \"Class defination for a line trip\"\n    fault_method = \"dist_branch_trip\"\n    fault_settings = {}\n\n    def __init__(self, psse, settings: LineTrip, logger, contingency_type):\n        super().__init__(psse, settings, logger, contingency_type)\n        self.fault_settings[\"ibus\"] = settings.bus_ids[0]\n        self.fault_settings[\"jbus\"] = settings.bus_ids[1]\n        self.element = settings.bus_ids\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.MachineTrip","title":"<code>MachineTrip</code>","text":"<p>             Bases: <code>BaseFault</code></p> <p>Class defination for a machine fault</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class MachineTrip(BaseFault):\n    \"Class defination for a machine fault\"\n    fault_method = \"dist_machine_trip\"\n    fault_settings = {}\n\n    def __init__(self, psse, settings: MachineTrip, logger, contingency_type):\n        super().__init__(psse, settings, logger, contingency_type)\n        self.fault_settings[\"ibus\"] = settings.bus_id\n        self.fault_settings[\"id\"] = settings.machine_id\n        self.element = settings.bus_id\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.add_contingency","title":"<code>add_contingency(contingency, cont_dict, dt, system_contingencies)</code>","text":"<p>Adds a new contingency</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def add_contingency(contingency, cont_dict, dt, system_contingencies):\n    \"Adds a new contingency\"\n    ontingency_type = contingency.__class__.__name__\n    if ontingency_type in contingencies:\n        system_contingencies.append(contingencies[ontingency_type](**cont_dict))\n    else:\n        msg = \"Invalid contingency type. Valid values are: {}\".format(\",\".join(contingencies.keys()))\n        raise Exception(msg)\n    return system_contingencies, dt\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.build_contingencies","title":"<code>build_contingencies(psse, settings, logger)</code>","text":"<p>Builds all contingencies defined in the settings file</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def build_contingencies(psse, settings: SimulationSettings, logger):\n    \"Builds all contingencies defined in the settings file\"\n    system_contingencies = []\n    if settings.contingencies:\n        for contingency in settings.contingencies:\n            contingency_type = contingency.__class__.__name__\n            if contingency_type in contingencies:\n                system_contingencies.append(\n                    contingencies[contingency_type](psse, contingency, logger, contingency_type)\n                )\n                logger.debug(f'Contingency of type \"{contingency_type}\" added')\n            else:\n                logger.warning(\"Invalid contingency type. Valid values are: {}\".format(\",\".join(contingencies.keys())))\n    else:\n        logger.debug(\"No contingencies to build\")\n    return system_contingencies\n</code></pre>"}]}