{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pypsse","title":"PyPSSE","text":"<p>PyPSSE is a Python wrapper around psspy\u2014a Python application programming interface (API) for the Power System Simulator for Engineering (PSS/E)\u2014to perform time series power flow and dynamic simulation for power systems.</p> <p>The PSS/E Python API psspy follows functional programming methodology. The API exposes thousands of methods and can be difficult for new users to work with. PyPSSE wraps around hundreds of function calls in a few methods. This functionality allows users to set up cosimulations with minimal effort.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install using pip:</p> pip install NREL-pypsseInstalled"},{"location":"#usage","title":"Usage","text":"<p>Running an existing PyPSSE project from CLI</p> pypsse run &lt;project path&gt; <p>Building a new PyPSSE project from CLI</p> pypsse create-project &lt;args&gt; <p>Running a PyPSSE server</p> pypsse serve"},{"location":"#features","title":"Features","text":"<ul> <li>Supports time-series steady-state simulations, which are not inherently supported by PSS/E</li> <li>Fully supports dynamic simulations</li> <li>Built in HELICS interface (for both steady-state and dynamic simulations) enables quick cosimulation setup without a without writing a single line of code</li> <li>Built in OpenMDAO interface for co-optimization / co-design type use cases </li> <li>Command line interface allows users to create new projects, run simulations, and view reports</li> <li>Offers RESTful API interface</li> <li>Profile and result management modules allow users to interface with external profiles and mange results</li> <li>Results manger can be configured to work with PSS/E channels and psspy API calls</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the BSD 3-Clause License - see the LICENSE file for details.</p>"},{"location":"#support","title":"Support","text":"<p>If you have questions or need help, please contact [aadil.latif@nrel.gov].</p>"},{"location":"license/","title":"License","text":"<p>Copyright (c) 2018, Alliance for Sustainable Energy LLC, All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ul> <li> <p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p> </li> </ul> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#installing-pypsse","title":"Installing PyPSSE","text":"<p>Create a new python environment using the following command. Make sure you install the correct python version supported by the local PSS/e installation. Also make sure correcly choose a 32 or 64 bit python installer.</p> # Creating a new environmentconda create -n pypsse python==3.9conda activate pypsse # Install the package# For local minimal installation, use the following commandpip install NREL-pypsse# For pypsse server implmentation, usepip install NREL-pypsse[server]# To use pypsse OpenMDAO interface, usepip install NREL-pypsse[mdao]# For development, in a new directory, use the following commandsgit clone https://github.com/NREL/PyPSSEconda install pygraphvizpip install -e.[mdao,server,doc,dev]"},{"location":"tutorials/#cli-commands","title":"CLI commands","text":"# Using the CLI# For CLI commands, type the following commandpypsse --help&gt; Usage: pypsse [OPTIONS] COMMAND [ARGS]...&gt;&gt; PyPSSE commands&gt;&gt; Options:&gt;  --help  Show this message and exit.0&gt;&gt; Commands:&gt;  create-profiles  Creates profiles for PyPSSE project.&gt;  create-project   Create a new PyPSSE project.&gt;  run              Runs a valid PyPSSE simulation.&gt;  serve            Run a PyPSSE RESTful API server."},{"location":"tutorials/#building-a-new-project","title":"Building a new project","text":"# CLI project build optionspypsse create-project --help&gt; Usage: pypsse create-project [OPTIONS] PATH&gt;  &gt;   Create a new PyPSSE project.&gt; &gt; Options:&gt;   -o, --overwrite                 Overwrite project is it already exists&gt;                                   [default: True]&gt;   -a, --autofill                  Attempt to auto fill settings. (Verify&gt;                                   manually settings file is correct)&gt;                                   [default: True]&gt;   -m, --profile-mapping TEXT      Path to a valid Profile_mapping.toml&gt;                                   file (used to map profile to PSSE&gt;                                   elements)&gt;   -s, --profile-store TEXT        Path to a valid Profiles.hdf5 file&gt;                                   (Contains profiles for time series&gt;                                   simulations)&gt;   -e, --export-settings-file TEXT&gt;                                   Export settings toml file path&gt;   -f, --simulation-file TEXT      Simulation settings toml file path&gt;   -F, --psse-project-folder PATH  PSS/E project folder path&gt;   -p, --project TEXT              project name  [required]&gt;   --help                          Show this message and exit."},{"location":"tutorials/#setting-a-new-project-using-cli","title":"setting a new project using cli","text":"# Building a project from scratch. Users will have to manually make all # required changes to the created project skeleton. pypsse create-project . -p test_project # Building a project from an existing PSS/e project. PyPSSE will attemp# to autofill most settings. pypsse create-project . -p test_project -F &lt;project path&gt; <p>Simulation settings can be changed within the simulation_settings.toml file.</p> <ul> <li>Simution type / time / duration</li> <li>Settung upEnabling / disabling the HELICS interface</li> <li>Setting up log preferences</li> <li>Setting up simulation contingencies</li> <li>Setting up simulation storage</li> <li>Setting up simulation profiles</li> </ul> <p></p>"},{"location":"tutorials/#running-a-simulation","title":"Running a simulation","text":"# Project run optionspypsse run --help &gt; Usage: pypsse run [OPTIONS] PROJECT_PATH&gt; &gt;   Runs a valid PyPSSE simulation.&gt; Options:&gt;   -s, --simulations-file TEXT  scenario toml file to run (over rides&gt;                                default)  [default:&gt;                                simulation_settings.toml]&gt;   --help                       Show this message and exit.# Running an existing PyPSSE projectpypsse run &lt;project path&gt;"},{"location":"tutorials/#working-with-a-pypsse-server","title":"Working with a PyPSSE server","text":"<p>PyPSSE implments both a REST API and a Web Socket interface for the PyPSSE server. Usage of both interfaces is similar. The server can be started from the command line using the following command. </p> # Starting a PyPSSE serverpypsse serve&gt; 2023-12-23 11:59:01,913 - INFO - Start PyPSSE server&gt; 2023-12-23 11:59:01,914 - INFO - Initializing service handler&gt; 2023-12-23 11:59:01,924 - INFO - Building web application&gt; 2023-12-23 11:59:01,932 - INFO - Building API endpoints&gt; INFO:     Started server process [15760]&gt; INFO:     Waiting for application startup.&gt; INFO:     Application startup complete.&gt; INFO:     Uvicorn running on http://127.0.0.1:9090 (Press CTRL+C to quit)# Open the link in the browser to view API documentation (Also documented in the reference guide) <p></p>"},{"location":"code/api/","title":"API interface","text":""},{"location":"code/api/#api-interfaces","title":"API interfaces","text":"<p>The PyPSSE REST API interface enables users to run PyPSSE on a server machine. The interface enables orchestration of multiple simualtion runs in parallel. Future extenions will support</p> <ul> <li>User management</li> <li>Result retrival during simulation runs using web socket implementation</li> <li>Ability to upload existing PyPSSE project to the server machine</li> </ul>"},{"location":"code/api/#fastapi-010","title":"FastAPI 0.1.0","text":""},{"location":"code/api/#endpoints","title":"Endpoints","text":""},{"location":"code/api/#put-simulator","title":"PUT /simulator/","text":"<p>Put Psse</p> <p>Request body</p> <p>application/json</p> <p></p><pre><code>{\n    \"uuid\": \"string\",\n    \"command\": \"run_simulation\",\n    \"parameters\": null\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the request body</p> <pre><code>{\n    \"properties\": {\n        \"uuid\": {\n            \"type\": \"string\",\n            \"format\": \"uuid4\",\n            \"title\": \"Uuid\"\n        },\n        \"command\": {\n            \"$ref\": \"#/components/schemas/ApiCommands\"\n        },\n        \"parameters\": {\n            \"anyOf\": [\n                {\n                    \"$ref\": \"#/components/schemas/ApiAssetQuery\"\n                },\n                {\n                    \"type\": \"null\"\n                }\n            ]\n        }\n    },\n    \"type\": \"object\",\n    \"required\": [\n        \"uuid\",\n        \"command\"\n    ],\n    \"title\": \"ApiPssePutRequest\"\n}\n</code></pre>"},{"location":"code/api/#response-200-ok","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#response-422-unprocessable-entity","title":"Response 422 Unprocessable Entity","text":"<p>application/json</p> <p></p><pre><code>{\n    \"detail\": [\n        {\n            \"loc\": [\n                null\n            ],\n            \"msg\": \"string\",\n            \"type\": \"string\"\n        }\n    ]\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the response body</p> <pre><code>{\n    \"properties\": {\n        \"detail\": {\n            \"items\": {\n                \"$ref\": \"#/components/schemas/ValidationError\"\n            },\n            \"type\": \"array\",\n            \"title\": \"Detail\"\n        }\n    },\n    \"type\": \"object\",\n    \"title\": \"HTTPValidationError\"\n}\n</code></pre>"},{"location":"code/api/#post-simulator","title":"POST /simulator/","text":"<p>Post Psse</p> <p>Description Create UUID and intialize and push to queue</p> <p>Request body</p> <p>application/json</p> <p></p><pre><code>{\n    \"project_name\": \"string\"\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the request body</p> <pre><code>{\n    \"properties\": {\n        \"project_name\": {\n            \"type\": \"string\",\n            \"title\": \"Project Name\",\n            \"default\": \"static_example\"\n        }\n    },\n    \"type\": \"object\",\n    \"title\": \"ApiPssePostRequest\"\n}\n</code></pre>"},{"location":"code/api/#response-200-ok_1","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#response-422-unprocessable-entity_1","title":"Response 422 Unprocessable Entity","text":"<p>application/json</p> <p></p><pre><code>{\n    \"detail\": [\n        {\n            \"loc\": [\n                null\n            ],\n            \"msg\": \"string\",\n            \"type\": \"string\"\n        }\n    ]\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the response body</p> <pre><code>{\n    \"properties\": {\n        \"detail\": {\n            \"items\": {\n                \"$ref\": \"#/components/schemas/ValidationError\"\n            },\n            \"type\": \"array\",\n            \"title\": \"Detail\"\n        }\n    },\n    \"type\": \"object\",\n    \"title\": \"HTTPValidationError\"\n}\n</code></pre>"},{"location":"code/api/#delete-simulatoruuiduuid","title":"DELETE /simulator/uuid/{uuid}","text":"<p>Delete Psse</p> <p>Description Delete an instance of simulation</p> <p>Input parameters</p> Parameter In Type Default Nullable Description uuid path string No"},{"location":"code/api/#response-200-ok_2","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#response-422-unprocessable-entity_2","title":"Response 422 Unprocessable Entity","text":"<p>application/json</p> <p></p><pre><code>{\n    \"detail\": [\n        {\n            \"loc\": [\n                null\n            ],\n            \"msg\": \"string\",\n            \"type\": \"string\"\n        }\n    ]\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the response body</p> <pre><code>{\n    \"properties\": {\n        \"detail\": {\n            \"items\": {\n                \"$ref\": \"#/components/schemas/ValidationError\"\n            },\n            \"type\": \"array\",\n            \"title\": \"Detail\"\n        }\n    },\n    \"type\": \"object\",\n    \"title\": \"HTTPValidationError\"\n}\n</code></pre>"},{"location":"code/api/#get-simulatoruuids","title":"GET /simulator/uuids","text":"<p>Get Instance Uuids</p> <p>Description Get all running simulation uuids</p>"},{"location":"code/api/#response-200-ok_3","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#get-simulatorstatusuuiduuid","title":"GET /simulator/status/uuid/{uuid}","text":"<p>Get Instance Status</p> <p>Description Get status of the current provided simuation instance</p> <p>Input parameters</p> Parameter In Type Default Nullable Description uuid path string No"},{"location":"code/api/#response-200-ok_4","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#response-422-unprocessable-entity_3","title":"Response 422 Unprocessable Entity","text":"<p>application/json</p> <p></p><pre><code>{\n    \"detail\": [\n        {\n            \"loc\": [\n                null\n            ],\n            \"msg\": \"string\",\n            \"type\": \"string\"\n        }\n    ]\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the response body</p> <pre><code>{\n    \"properties\": {\n        \"detail\": {\n            \"items\": {\n                \"$ref\": \"#/components/schemas/ValidationError\"\n            },\n            \"type\": \"array\",\n            \"title\": \"Detail\"\n        }\n    },\n    \"type\": \"object\",\n    \"title\": \"HTTPValidationError\"\n}\n</code></pre>"},{"location":"code/api/#get-simulatorresultsuuiduuid","title":"GET /simulator/results/uuid/{uuid}","text":"<p>Get Download Results</p> <p>Description Download results from a simulation instance</p> <p>Input parameters</p> Parameter In Type Default Nullable Description uuid path string No"},{"location":"code/api/#response-200-ok_5","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#response-422-unprocessable-entity_4","title":"Response 422 Unprocessable Entity","text":"<p>application/json</p> <p></p><pre><code>{\n    \"detail\": [\n        {\n            \"loc\": [\n                null\n            ],\n            \"msg\": \"string\",\n            \"type\": \"string\"\n        }\n    ]\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the response body</p> <pre><code>{\n    \"properties\": {\n        \"detail\": {\n            \"items\": {\n                \"$ref\": \"#/components/schemas/ValidationError\"\n            },\n            \"type\": \"array\",\n            \"title\": \"Detail\"\n        }\n    },\n    \"type\": \"object\",\n    \"title\": \"HTTPValidationError\"\n}\n</code></pre>"},{"location":"code/api/#get-simulatorloguuiduuid","title":"GET /simulator/log/uuid/{uuid}","text":"<p>Get Download Logs</p> <p>Description Download logs from a simulation instance</p> <p>Input parameters</p> Parameter In Type Default Nullable Description uuid path string No"},{"location":"code/api/#response-200-ok_6","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#response-422-unprocessable-entity_5","title":"Response 422 Unprocessable Entity","text":"<p>application/json</p> <p></p><pre><code>{\n    \"detail\": [\n        {\n            \"loc\": [\n                null\n            ],\n            \"msg\": \"string\",\n            \"type\": \"string\"\n        }\n    ]\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the response body</p> <pre><code>{\n    \"properties\": {\n        \"detail\": {\n            \"items\": {\n                \"$ref\": \"#/components/schemas/ValidationError\"\n            },\n            \"type\": \"array\",\n            \"title\": \"Detail\"\n        }\n    },\n    \"type\": \"object\",\n    \"title\": \"HTTPValidationError\"\n}\n</code></pre>"},{"location":"code/api/#get","title":"GET /","text":"<p>Get Main Page</p> <p>Description Method to handle service info route.</p>"},{"location":"code/api/#response-200-ok_7","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#post-upload","title":"POST /upload","text":"<p>Post Upload Zipped Project</p> <p>Description Upload a new zipped project to the server</p> <p>Request body</p> <p>multipart/form-data</p> <p></p><pre><code>{\n    \"file\": \"TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQ=\"\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the request body</p> <pre><code>{\n    \"properties\": {\n        \"file\": {\n            \"type\": \"string\",\n            \"format\": \"binary\",\n            \"title\": \"File\"\n        }\n    },\n    \"type\": \"object\",\n    \"required\": [\n        \"file\"\n    ],\n    \"title\": \"Body_post_upload_zipped_project_upload_post\"\n}\n</code></pre>"},{"location":"code/api/#response-200-ok_8","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#response-422-unprocessable-entity_6","title":"Response 422 Unprocessable Entity","text":"<p>application/json</p> <p></p><pre><code>{\n    \"detail\": [\n        {\n            \"loc\": [\n                null\n            ],\n            \"msg\": \"string\",\n            \"type\": \"string\"\n        }\n    ]\n}\n</code></pre> This example has been generated automatically from the schema and it is not accurate. Refer to the schema for more information. <p>Schema of the response body</p> <pre><code>{\n    \"properties\": {\n        \"detail\": {\n            \"items\": {\n                \"$ref\": \"#/components/schemas/ValidationError\"\n            },\n            \"type\": \"array\",\n            \"title\": \"Detail\"\n        }\n    },\n    \"type\": \"object\",\n    \"title\": \"HTTPValidationError\"\n}\n</code></pre>"},{"location":"code/api/#get-projects","title":"GET /projects","text":"<p>Get List Projects</p>"},{"location":"code/api/#response-200-ok_9","title":"Response 200 OK","text":"<p>application/json</p> <p>Schema of the response body</p>"},{"location":"code/api/#schemas","title":"Schemas","text":""},{"location":"code/api/#apiassetquery","title":"ApiAssetQuery","text":"Name Type asset_id asset_property asset_type ModelTypes"},{"location":"code/api/#apicommands","title":"ApiCommands","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#apipssepostrequest","title":"ApiPssePostRequest","text":"Name Type project_name string"},{"location":"code/api/#apipsseputrequest","title":"ApiPssePutRequest","text":"Name Type command ApiCommands parameters uuid string(uuid4)"},{"location":"code/api/#areaproperties","title":"AreaProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#body_post_upload_zipped_project_upload_post","title":"Body_post_upload_zipped_project_upload_post","text":"Name Type file string(binary)"},{"location":"code/api/#branchproperties","title":"BranchProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#busproperties","title":"BusProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#dclineproperties","title":"DCLineProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#fixedshuntproperties","title":"FixedShuntProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#httpvalidationerror","title":"HTTPValidationError","text":"Name Type detail Array&lt;ValidationError&gt;"},{"location":"code/api/#inductiongeneratorproperties","title":"InductionGeneratorProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#loadproperties","title":"LoadProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#machinesproperties","title":"MachinesProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#modeltypes","title":"ModelTypes","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#stationproperties","title":"StationProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#switchedshuntproperties","title":"SwitchedShuntProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#transformerproperties","title":"TransformerProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/api/#validationerror","title":"ValidationError","text":"Name Type loc Array&lt;&gt; msg string type string"},{"location":"code/api/#zoneproperties","title":"ZoneProperties","text":"<p>Type:\u00a0string</p>"},{"location":"code/cli/","title":"CLI interface","text":""},{"location":"code/cli/#api-interfaces","title":"API interfaces","text":""},{"location":"code/cli/#create-project","title":"create-project","text":"<p>Create a new PyPSSE project.</p> <p>Usage:</p> <pre><code>create-project [OPTIONS] PATH\n</code></pre> <p>Options:</p> <pre><code>  -o, --overwrite                 Overwrite project is it already exists\n                                  [default: True]\n  -a, --autofill                  Attempt to auto fill settings. (Verify\n                                  manually settings file is correct)\n                                  [default: True]\n  -m, --profile-mapping TEXT      Path to a valid Profile_mapping.toml file\n                                  (used to map profile to PSSE elements)\n  -s, --profile-store TEXT        Path to a valid Profiles.hdf5 file (Contains\n                                  profiles for time series simulations)\n  -e, --export-settings-file TEXT\n                                  Export settings toml file path\n  -f, --simulation-file TEXT      Simulation settings toml file path\n  -F, --psse-project-folder PATH  PSS/E project folder path\n  -p, --project TEXT              project name  [required]\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"code/cli/#run","title":"run","text":"<p>Runs a valid PyPSSE simulation.</p> <p>Usage:</p> <pre><code>run [OPTIONS] PROJECT_PATH\n</code></pre> <p>Options:</p> <pre><code>  -s, --simulations-file TEXT  scenario toml file to run (over rides default)\n                               [default: simulation_settings.toml]\n  --help                       Show this message and exit.\n</code></pre>"},{"location":"code/cli/#explore","title":"explore","text":"<p>Runs a valid PyPSSE simulation.</p> <p>Usage:</p> <pre><code>explore [OPTIONS] PROJECT_PATH\n</code></pre> <p>Options:</p> <pre><code>  --gen-bounds TEXT               bounds for generation   [default: 0/10000]\n  --load-bounds TEXT              bounds for load [example 10/100]  [default:\n                                  0/10000]\n  -b, --apply-bounds              applies load and generation limit bounds if\n                                  set to true\n  --comp-load / --no-comp-load    filter by composite load models [bool]\n                                  [default: no-comp-load]\n  --generation / --no-generation  filter by generation [bool]  [default: no-\n                                  generation]\n  -g, --gen-filter                applies generator filters if set to true\n  --load / --no-load              filter by load [bool]  [default: no-load]\n  -l, --load-filter               applies load filters if set to true\n  -e, --export-file-path TEXT     path for exporting filtered results\n                                  [default: ./filtered_results.csv]\n  -s, --simulations-file TEXT     scenario toml file to run (over rides\n                                  default)  [default:\n                                  simulation_settings.toml]\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"code/cli/#create-profiles","title":"create-profiles","text":"<p>Creates profiles for PyPSSE project.</p> <p>Usage:</p> <pre><code>create-profiles [OPTIONS] PROJECT_PATH\n</code></pre> <p>Options:</p> <pre><code>  -i, --profile-info TEXT    Profile time resolution in seconds\n  -r, --profile-res FLOAT    Profile time resolution in seconds  [default:\n                             1.0]\n  -T, --start-time TEXT      Time index for the first time step, format =\n                             Y-m-d H:M:S.f  [default: 2020-01-01 00:00:00.00]\n  -t, --profile-type TEXT    Profile type; Possible values:\n                             [&lt;ProfileTypes.LOAD: 'Load'&gt;,\n                             &lt;ProfileTypes.INDUCTION_MACHINE:\n                             'Induction_machine'&gt;, &lt;ProfileTypes.MACHINE:\n                             'Machine'&gt;, &lt;ProfileTypes.PLANT: 'Plant'&gt;]\n                             [default: Load]\n  -n, --profile-name TEXT    Profile name  [default: Default]\n  -p, --profile-folder TEXT  Path to folder containing csv profiles. CSV file\n                             names should follow the following format:\n                             {profile-type}_{profile-name}\n  -f, --csv-file-path TEXT   Path to a csv valid file\n  --help                     Show this message and exit.\n</code></pre>"},{"location":"code/cli/#serve","title":"serve","text":"<p>Run a PyPSSE RESTful API server.</p> <p>Usage:</p> <pre><code>serve [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -h, --host-ip TEXT  IP for the server  [default: 127.0.0.1]\n  -p, --port INTEGER  Socket port for the server  [default: 9090]\n  --help              Show this message and exit.\n</code></pre>"},{"location":"code/enumerations/","title":"Enumerations","text":""},{"location":"code/enumerations/#libray-enumerations","title":"Libray Enumerations","text":"<p>This page provides details on the enumerated classes part of the PyPSSE library.Enumerations map directly to .</p>"},{"location":"code/enumerations/#apicommands","title":"ApiCommands","text":"Key Value pypsse.enumerations.ApiCommands.RUN_SIMUALTION run_simulation pypsse.enumerations.ApiCommands.STATUS status pypsse.enumerations.ApiCommands.SOLVE_STEP run_step pypsse.enumerations.ApiCommands.OPEN_CASE open_case pypsse.enumerations.ApiCommands.CLOSE_CASE close_case pypsse.enumerations.ApiCommands.UDPATE_MODEL update_model pypsse.enumerations.ApiCommands.UPDATE_PARAMETERS update_settings pypsse.enumerations.ApiCommands.QUERY_ALL query_all pypsse.enumerations.ApiCommands.QUERY_BY_ID query_by_asset pypsse.enumerations.ApiCommands.QUERY_BY_PPTY query_by_ppty pypsse.enumerations.ApiCommands.QUERY_ASSET_LIST query_asset_list"},{"location":"code/enumerations/#areaproperties","title":"AreaProperties","text":"Key Value pypsse.enumerations.AreaProperties.LOAD LOAD pypsse.enumerations.AreaProperties.LOADID LOADID pypsse.enumerations.AreaProperties.LGDN LGDN pypsse.enumerations.AreaProperties.LDGNLD LDGNLD pypsse.enumerations.AreaProperties.GEN GEN pypsse.enumerations.AreaProperties.AREANAME AREANAME pypsse.enumerations.AreaProperties.AREANUMBER AREANUMBER"},{"location":"code/enumerations/#branchproperties","title":"BranchProperties","text":"Key Value pypsse.enumerations.BranchProperties.RATEn RATEn pypsse.enumerations.BranchProperties.RATEA RATEA pypsse.enumerations.BranchProperties.RATEB RATEB pypsse.enumerations.BranchProperties.RATEC RATEC pypsse.enumerations.BranchProperties.RATE RATE pypsse.enumerations.BranchProperties.LENGTH LENGTH pypsse.enumerations.BranchProperties.CHARG CHARG pypsse.enumerations.BranchProperties.CHARGZ CHARGZ pypsse.enumerations.BranchProperties.FRACT1 FRACT1 pypsse.enumerations.BranchProperties.FRACT2 FRACT2 pypsse.enumerations.BranchProperties.FRACT3 FRACT3 pypsse.enumerations.BranchProperties.FRACT4 FRACT4 pypsse.enumerations.BranchProperties.RX RX pypsse.enumerations.BranchProperties.ISHNT ISHNT pypsse.enumerations.BranchProperties.JSHNT JSHNT pypsse.enumerations.BranchProperties.RXZ RXZ pypsse.enumerations.BranchProperties.ISHNTZ ISHNTZ pypsse.enumerations.BranchProperties.JSHNTZ JSHNTZ pypsse.enumerations.BranchProperties.LOSSES LOSSES pypsse.enumerations.BranchProperties.O_LOSSES O_LOSSES pypsse.enumerations.BranchProperties.MVA MVA pypsse.enumerations.BranchProperties.AMPS AMPS pypsse.enumerations.BranchProperties.PUCUR PUCUR pypsse.enumerations.BranchProperties.CURANG CURANG pypsse.enumerations.BranchProperties.P P pypsse.enumerations.BranchProperties.O_P O_P pypsse.enumerations.BranchProperties.Q Q pypsse.enumerations.BranchProperties.O_Q O_Q pypsse.enumerations.BranchProperties.PLOS PLOS pypsse.enumerations.BranchProperties.O_PLOS O_PLOS pypsse.enumerations.BranchProperties.QLOS QLOS pypsse.enumerations.BranchProperties.O_QLOS O_QLOS"},{"location":"code/enumerations/#bulkwritemodes","title":"BulkWriteModes","text":"Key Value pypsse.enumerations.BulkWriteModes.CSV csv pypsse.enumerations.BulkWriteModes.PKL pkl"},{"location":"code/enumerations/#busproperties","title":"BusProperties","text":"Key Value pypsse.enumerations.BusProperties.BASE BASE pypsse.enumerations.BusProperties.FREQ FREQ pypsse.enumerations.BusProperties.PU PU pypsse.enumerations.BusProperties.KV KV pypsse.enumerations.BusProperties.ANGLE ANGLE pypsse.enumerations.BusProperties.ANGLED ANGLED pypsse.enumerations.BusProperties.NVLMHI NVLMHI pypsse.enumerations.BusProperties.NVLMLO NVLMLO pypsse.enumerations.BusProperties.EVLMHI EVLMHI pypsse.enumerations.BusProperties.EVLMLO EVLMLO"},{"location":"code/enumerations/#channeltypes","title":"ChannelTypes","text":"Key Value pypsse.enumerations.ChannelTypes.BUSES buses pypsse.enumerations.ChannelTypes.LOADS loads pypsse.enumerations.ChannelTypes.MACHINES machines"},{"location":"code/enumerations/#dclineproperties","title":"DCLineProperties","text":"Key Value pypsse.enumerations.DCLineProperties.DCLINENAME DCLINENAME pypsse.enumerations.DCLineProperties.MDC MDC pypsse.enumerations.DCLineProperties.RECT RECT pypsse.enumerations.DCLineProperties.INV INV pypsse.enumerations.DCLineProperties.METER METER pypsse.enumerations.DCLineProperties.NBR NBR pypsse.enumerations.DCLineProperties.NBI NBI pypsse.enumerations.DCLineProperties.ICR ICR pypsse.enumerations.DCLineProperties.ICI ICI pypsse.enumerations.DCLineProperties.NDR NDR pypsse.enumerations.DCLineProperties.NDI NDI"},{"location":"code/enumerations/#enum","title":"Enum","text":"Key Value"},{"location":"code/enumerations/#exportmodes","title":"ExportModes","text":"Key Value pypsse.enumerations.ExportModes.JSON json pypsse.enumerations.ExportModes.CSV csv pypsse.enumerations.ExportModes.H5 h5"},{"location":"code/enumerations/#fixedshuntproperties","title":"FixedShuntProperties","text":"Key Value pypsse.enumerations.FixedShuntProperties.ACT ACT pypsse.enumerations.FixedShuntProperties.O_ACT O_ACT pypsse.enumerations.FixedShuntProperties.NOM NOM pypsse.enumerations.FixedShuntProperties.O_NOM O_NOM pypsse.enumerations.FixedShuntProperties.PQZERO PQZERO pypsse.enumerations.FixedShuntProperties.PQZ PQZ pypsse.enumerations.FixedShuntProperties.O_PQZ O_PQZ"},{"location":"code/enumerations/#helicscoretypes","title":"HelicsCoreTypes","text":"Key Value pypsse.enumerations.HelicsCoreTypes.ZMQ zmq"},{"location":"code/enumerations/#inductiongeneratorproperties","title":"InductionGeneratorProperties","text":"Key Value pypsse.enumerations.InductionGeneratorProperties.MBASE MBASE pypsse.enumerations.InductionGeneratorProperties.RATEKV RATEKV pypsse.enumerations.InductionGeneratorProperties.PSET PSET pypsse.enumerations.InductionGeneratorProperties.RA RA pypsse.enumerations.InductionGeneratorProperties.XA XA pypsse.enumerations.InductionGeneratorProperties.R1 R1 pypsse.enumerations.InductionGeneratorProperties.X1 X1 pypsse.enumerations.InductionGeneratorProperties.R2 R2 pypsse.enumerations.InductionGeneratorProperties.X2 X2 pypsse.enumerations.InductionGeneratorProperties.X3 X3 pypsse.enumerations.InductionGeneratorProperties.E1 E1 pypsse.enumerations.InductionGeneratorProperties.SE1 SE1 pypsse.enumerations.InductionGeneratorProperties.E2 E2 pypsse.enumerations.InductionGeneratorProperties.SE2 SE2 pypsse.enumerations.InductionGeneratorProperties.IA1 IA1 pypsse.enumerations.InductionGeneratorProperties.IA2 IA2 pypsse.enumerations.InductionGeneratorProperties.XAMULT XAMULT pypsse.enumerations.InductionGeneratorProperties.TRQA TRQA pypsse.enumerations.InductionGeneratorProperties.TRQB TRQB pypsse.enumerations.InductionGeneratorProperties.TRQD TRQD pypsse.enumerations.InductionGeneratorProperties.TRQE TRQE pypsse.enumerations.InductionGeneratorProperties.H H pypsse.enumerations.InductionGeneratorProperties.IRATIO IRATIO pypsse.enumerations.InductionGeneratorProperties.ROVERX ROVERX pypsse.enumerations.InductionGeneratorProperties.RZERO RZERO pypsse.enumerations.InductionGeneratorProperties.XZERO XZERO pypsse.enumerations.InductionGeneratorProperties.RGRND RGRND pypsse.enumerations.InductionGeneratorProperties.XGRND XGRND pypsse.enumerations.InductionGeneratorProperties.P P pypsse.enumerations.InductionGeneratorProperties.O_P O_P pypsse.enumerations.InductionGeneratorProperties.Q Q pypsse.enumerations.InductionGeneratorProperties.O_Q O_Q pypsse.enumerations.InductionGeneratorProperties.MVA MVA pypsse.enumerations.InductionGeneratorProperties.O_MVA O_MVA pypsse.enumerations.InductionGeneratorProperties.SLIP SLIP pypsse.enumerations.InductionGeneratorProperties.ZA ZA pypsse.enumerations.InductionGeneratorProperties.Z1 Z1 pypsse.enumerations.InductionGeneratorProperties.Z2 Z2 pypsse.enumerations.InductionGeneratorProperties.ZZERO ZZERO pypsse.enumerations.InductionGeneratorProperties.ZGRND ZGRND pypsse.enumerations.InductionGeneratorProperties.PQ PQ pypsse.enumerations.InductionGeneratorProperties.O_PQ O_PQ"},{"location":"code/enumerations/#intenum","title":"IntEnum","text":"Key Value"},{"location":"code/enumerations/#loadproperties","title":"LoadProperties","text":"Key Value pypsse.enumerations.LoadProperties.MVA MVA pypsse.enumerations.LoadProperties.IL IL pypsse.enumerations.LoadProperties.YL YL pypsse.enumerations.LoadProperties.TOTAL TOTAL pypsse.enumerations.LoadProperties.YNEG YNEG pypsse.enumerations.LoadProperties.YZERO YZERO pypsse.enumerations.LoadProperties.FmA FmA pypsse.enumerations.LoadProperties.FmB FmB pypsse.enumerations.LoadProperties.FmC FmC pypsse.enumerations.LoadProperties.FmD FmD pypsse.enumerations.LoadProperties.Fel Fel pypsse.enumerations.LoadProperties.PFel PFel pypsse.enumerations.LoadProperties.TD TD pypsse.enumerations.LoadProperties.TC TC"},{"location":"code/enumerations/#logginglevels","title":"LoggingLevels","text":"Key Value pypsse.enumerations.LoggingLevels.NOTSET 0 pypsse.enumerations.LoggingLevels.DEBUG 10 pypsse.enumerations.LoggingLevels.INFO 20 pypsse.enumerations.LoggingLevels.WARN 30 pypsse.enumerations.LoggingLevels.ERROR 40 pypsse.enumerations.LoggingLevels.CRITICAL 50"},{"location":"code/enumerations/#machinesproperties","title":"MachinesProperties","text":"Key Value pypsse.enumerations.MachinesProperties.QMAX QMAX pypsse.enumerations.MachinesProperties.O_QMAX O_QMAX pypsse.enumerations.MachinesProperties.QMIN QMIN pypsse.enumerations.MachinesProperties.O_QMIN O_QMIN pypsse.enumerations.MachinesProperties.PMAX PMAX pypsse.enumerations.MachinesProperties.O_PMAX O_PMAX pypsse.enumerations.MachinesProperties.PMIN PMIN pypsse.enumerations.MachinesProperties.O_PMIN O_PMIN pypsse.enumerations.MachinesProperties.MBASE MBASE pypsse.enumerations.MachinesProperties.MVA MVA pypsse.enumerations.MachinesProperties.O_MVA O_MVA pypsse.enumerations.MachinesProperties.P P pypsse.enumerations.MachinesProperties.O_P O_P pypsse.enumerations.MachinesProperties.Q Q pypsse.enumerations.MachinesProperties.O_Q O_Q pypsse.enumerations.MachinesProperties.PERCENT PERCENT pypsse.enumerations.MachinesProperties.GENTAP GENTAP pypsse.enumerations.MachinesProperties.VSCHED VSCHED pypsse.enumerations.MachinesProperties.WPF WPF pypsse.enumerations.MachinesProperties.RMPCT RMPCT pypsse.enumerations.MachinesProperties.RPOS RPOS pypsse.enumerations.MachinesProperties.XSUBTR XSUBTR pypsse.enumerations.MachinesProperties.XTRANS XTRANS pypsse.enumerations.MachinesProperties.XSYNCH XSYNCH pypsse.enumerations.MachinesProperties.PQ PQ pypsse.enumerations.MachinesProperties.O_PQ O_PQ pypsse.enumerations.MachinesProperties.ZSORCE ZSORCE pypsse.enumerations.MachinesProperties.XTRAN XTRAN pypsse.enumerations.MachinesProperties.ZPOS ZPOS pypsse.enumerations.MachinesProperties.ZNEG ZNEG pypsse.enumerations.MachinesProperties.ZZERO ZZERO pypsse.enumerations.MachinesProperties.ZGRND ZGRND"},{"location":"code/enumerations/#modelproperties","title":"ModelProperties","text":"Key Value pypsse.enumerations.ModelProperties.PU PU pypsse.enumerations.ModelProperties.FREQ FREQ pypsse.enumerations.ModelProperties.ANGLE ANGLE pypsse.enumerations.ModelProperties.ANGLED ANGLED"},{"location":"code/enumerations/#modeltypes","title":"ModelTypes","text":"Key Value pypsse.enumerations.ModelTypes.BUSES Buses pypsse.enumerations.ModelTypes.BRANCHES Branches pypsse.enumerations.ModelTypes.LOADS Loads pypsse.enumerations.ModelTypes.GENERATORS Induction_generators pypsse.enumerations.ModelTypes.MACHINES Machines pypsse.enumerations.ModelTypes.FIXED_SHUNTS Fixed_shunts pypsse.enumerations.ModelTypes.SWITCHED_SHUNTS Switched_shunts pypsse.enumerations.ModelTypes.TRANSFORMERS Transformers pypsse.enumerations.ModelTypes.AREAS Areas pypsse.enumerations.ModelTypes.ZONES Zones pypsse.enumerations.ModelTypes.DC_LINES DCtransmissionlines pypsse.enumerations.ModelTypes.STATIONS Stations"},{"location":"code/enumerations/#psse_versions","title":"PSSE_VERSIONS","text":"Key Value pypsse.enumerations.PSSE_VERSIONS.PSSE34 psse34 pypsse.enumerations.PSSE_VERSIONS.PSSE35 psse35 pypsse.enumerations.PSSE_VERSIONS.PSSE36 psse36"},{"location":"code/enumerations/#projectfolders","title":"ProjectFolders","text":"Key Value pypsse.enumerations.ProjectFolders.CASESTUDY case_study pypsse.enumerations.ProjectFolders.EXPORTS exports pypsse.enumerations.ProjectFolders.GISDATA gis_data pypsse.enumerations.ProjectFolders.LOGS logs pypsse.enumerations.ProjectFolders.PROFILES profiles"},{"location":"code/enumerations/#simulationmodes","title":"SimulationModes","text":"Key Value pypsse.enumerations.SimulationModes.PCM PCM pypsse.enumerations.SimulationModes.SNAP Snap pypsse.enumerations.SimulationModes.STATIC Steady-state pypsse.enumerations.SimulationModes.DYNAMIC Dynamic"},{"location":"code/enumerations/#simulationstatus","title":"SimulationStatus","text":"Key Value pypsse.enumerations.SimulationStatus.NOT_INITIALIZED Instance not initialized pypsse.enumerations.SimulationStatus.STARTING_INSTANCE Starting PyPSSE instance pypsse.enumerations.SimulationStatus.INITIALIZATION_COMPLETE PyPSSE initialization complete pypsse.enumerations.SimulationStatus.RUNNING_SIMULATION Running simulation pypsse.enumerations.SimulationStatus.SIMULATION_COMPLETE Simulation complete pypsse.enumerations.SimulationStatus.STARTING_RESULT_EXPORT Starting exports pypsse.enumerations.SimulationStatus.RESULT_EXPORT_COMPLETE Export coplete"},{"location":"code/enumerations/#stationproperties","title":"StationProperties","text":"Key Value pypsse.enumerations.StationProperties.SUBNAME SUBNAME pypsse.enumerations.StationProperties.SUBNUMBER SUBNUMBER pypsse.enumerations.StationProperties.BUSES BUSES pypsse.enumerations.StationProperties.GENERATORS GENERATORS pypsse.enumerations.StationProperties.TRANSFORMERS TRANSFORMERS pypsse.enumerations.StationProperties.NOMKV NOMKV pypsse.enumerations.StationProperties.LOADMW LOADMW pypsse.enumerations.StationProperties.GENMW GENMW"},{"location":"code/enumerations/#streamedwritemodes","title":"StreamedWriteModes","text":"Key Value pypsse.enumerations.StreamedWriteModes.H5 h5"},{"location":"code/enumerations/#subscriptionfilerequiredcolumns","title":"SubscriptionFileRequiredColumns","text":"Key Value pypsse.enumerations.SubscriptionFileRequiredColumns.bus_subsystem_id bus_subsystem_id pypsse.enumerations.SubscriptionFileRequiredColumns.element_type element_type pypsse.enumerations.SubscriptionFileRequiredColumns.element_id element_id pypsse.enumerations.SubscriptionFileRequiredColumns.element_property element_property pypsse.enumerations.SubscriptionFileRequiredColumns.sub_tag sub_tag pypsse.enumerations.SubscriptionFileRequiredColumns.scaler scaler pypsse.enumerations.SubscriptionFileRequiredColumns.bus bus"},{"location":"code/enumerations/#switchedshuntproperties","title":"SwitchedShuntProperties","text":"Key Value pypsse.enumerations.SwitchedShuntProperties.VSWHI VSWHI pypsse.enumerations.SwitchedShuntProperties.VSWLO VSWLO pypsse.enumerations.SwitchedShuntProperties.RMPCT RMPCT pypsse.enumerations.SwitchedShuntProperties.BINIT BINIT pypsse.enumerations.SwitchedShuntProperties.O_BINIT O_BINIT"},{"location":"code/enumerations/#transformerproperties","title":"TransformerProperties","text":"Key Value pypsse.enumerations.TransformerProperties.RATIO RATIO pypsse.enumerations.TransformerProperties.RATIO2 RATIO2 pypsse.enumerations.TransformerProperties.ANGLE ANGLE pypsse.enumerations.TransformerProperties.RMAX RMAX pypsse.enumerations.TransformerProperties.RMIN RMIN pypsse.enumerations.TransformerProperties.VMAX VMAX pypsse.enumerations.TransformerProperties.VMIN VMIN pypsse.enumerations.TransformerProperties.STEP STEP pypsse.enumerations.TransformerProperties.CR CR pypsse.enumerations.TransformerProperties.CX CX pypsse.enumerations.TransformerProperties.CNXANG CNXANG pypsse.enumerations.TransformerProperties.SBASE1 SBASE1 pypsse.enumerations.TransformerProperties.NOMV1 NOMV1 pypsse.enumerations.TransformerProperties.NOMV2 NOMV2 pypsse.enumerations.TransformerProperties.GMAGNT GMAGNT pypsse.enumerations.TransformerProperties.BMAGNT BMAGNT pypsse.enumerations.TransformerProperties.RG1 RG1 pypsse.enumerations.TransformerProperties.XG1 XG1 pypsse.enumerations.TransformerProperties.R01 R01 pypsse.enumerations.TransformerProperties.X01 X01 pypsse.enumerations.TransformerProperties.RG2 RG2 pypsse.enumerations.TransformerProperties.XG2 XG2 pypsse.enumerations.TransformerProperties.R02 R02 pypsse.enumerations.TransformerProperties.X02 X02 pypsse.enumerations.TransformerProperties.RNUTRL RNUTRL pypsse.enumerations.TransformerProperties.XNUTRL XNUTRL pypsse.enumerations.TransformerProperties.RX1_2 RX1-2 pypsse.enumerations.TransformerProperties.RX2_3 RX2-3 pypsse.enumerations.TransformerProperties.RX3_1 RX3-1 pypsse.enumerations.TransformerProperties.YMAGNT YMAGNT pypsse.enumerations.TransformerProperties.ZG1 ZG1 pypsse.enumerations.TransformerProperties.Z01 Z01 pypsse.enumerations.TransformerProperties.ZG2 ZG2 pypsse.enumerations.TransformerProperties.Z02 Z02 pypsse.enumerations.TransformerProperties.ZG3 ZG3 pypsse.enumerations.TransformerProperties.Z03 Z03 pypsse.enumerations.TransformerProperties.ZNUTRL ZNUTRL"},{"location":"code/enumerations/#usemodes","title":"UseModes","text":"Key Value pypsse.enumerations.UseModes.REGEX regex pypsse.enumerations.UseModes.LIST list pypsse.enumerations.UseModes.ALL all"},{"location":"code/enumerations/#writablemodeltypes","title":"WritableModelTypes","text":"Key Value pypsse.enumerations.WritableModelTypes.LOAD Load pypsse.enumerations.WritableModelTypes.PLANT Plant pypsse.enumerations.WritableModelTypes.MACHINE Machine pypsse.enumerations.WritableModelTypes.GENERATOR Induction_machine"},{"location":"code/enumerations/#zoneproperties","title":"ZoneProperties","text":"Key Value pypsse.enumerations.ZoneProperties.LOAD LOAD pypsse.enumerations.ZoneProperties.LOADID LOADID pypsse.enumerations.ZoneProperties.LGDN LGDN pypsse.enumerations.ZoneProperties.LDGNLD LDGNLD pypsse.enumerations.ZoneProperties.GEN GEN pypsse.enumerations.ZoneProperties.ZONENAME ZONENAME pypsse.enumerations.ZoneProperties.ZONENUMBER ZONENUMBER"},{"location":"code/helics_interface/","title":"HELICS","text":""},{"location":"code/helics_interface/#reference-manual","title":"Reference manual","text":"<p>PyPSSE enables out of the box integration for co-simulation and co-optimization / co-design frameworks.</p>"},{"location":"code/helics_interface/#the-helics-co-simulation-framework","title":"The HELICS co-simulation framework","text":"<p>HELICS is a scalable open-source co-simulation framework is designed to integrate simulators designed for separate TDC domains to simulate regional and interconnection-scale power system behaviors at unprecedented levels of detail and speed. </p>"},{"location":"code/helics_interface/#setting-up-the-helics-co-simulation-interface","title":"Setting up the HELICS co-simulation interface","text":"<p>To enabled the HELICS interface, set <code>cosimulation_mode = true</code> in the <code>`simulation_settings.toml</code> file.</p> <p>The helics interface requires an existing HELCIS broker running either locally or remotely that the federate can connect to. Broker settings ca also be defined in the same file.</p> <p>Valid HELICS interface settings are:</p> <p> </p>"},{"location":"code/helics_interface/#setting-up-subscriptions","title":"Setting up subscriptions","text":"<p>Federate subscriptions can be set up by creating a <code>Subscription.csv</code>. The table below presents an example implementation.  </p> bus_subsystem_id bus element_type element_id element_property sub_tag scaler 0 153 Load 1 ['PL'] test.load1.P [1.0] 0 153 Load 1 ['QL'] test.load1.Q [1.0] 0 154 Load 2 ['PL'] test.load2.P [1.0] 0 154 Load 2 ['QL'] test.load2.Q [1.0]"},{"location":"code/helics_interface/#setting-up-publications","title":"Setting up publications","text":"<p>Valid publiations can be defined in PyPSSE in two ways.</p>"},{"location":"code/helics_interface/#pulishing-results-from-the-result-container","title":"Pulishing results from the result container","text":"<p>PyPSSE allows publication of results stored in the simulation store. Publications are set up directly in  <code>simulation_settings.toml</code> file in the PyPSSE project structure.</p> <pre><code>[[helics.publications]]\nbus_subsystems = [ 0,]\nasset_type = \"Buses\"\nasset_properties = [ \"FREQ\", \"PU\",]\n</code></pre> <p>All fields are validated against availble datasets in the simulation store. Valid model types and properties are documented here</p> <p></p>"},{"location":"code/helics_interface/#publishing-results-collected-from-channels","title":"Publishing results collected from channels","text":"<p>Results from channels in PSSE can also be published via the HELICS (dynamic simulation only). The setup mechanism is different.</p> <p>Channels can be set up in the <code>export_settings.toml</code> file in a PyPSSE project structure.</p> <p>The following data models can be refered to ensure valid implementation. Results from all channels are published to the simulation store and the HLEICS interface. </p> <p> </p> <p>Both interfaces can be used simultaneously as well</p>"},{"location":"code/helics_interface/#running-the-provided-helics-example","title":"Running the provided HELICS example","text":""},{"location":"code/mdao/","title":"OpenMDAO","text":""},{"location":"code/mdao/#reference-manual","title":"Reference manual","text":"<p>PyPSSE enables out of the box integration for co-simulation and co-optimization / co-design frameworks.</p>"},{"location":"code/mdao/#co-optimization-co-design-with-openmdao","title":"Co-optimization / co-design with OpenMDAO","text":"<p>The OpenMDAO framework enables multi-domain co-optimization by structuring the problem as a group of sub problems. (Ssee OpenMDAO documentation). The OpenMDAO interface implemented in PyPSSE enables it to a subproblem in a larger co-optimization or co-design problem. </p>"},{"location":"code/mdao/#runnning-the-provided-mdao-example","title":"Runnning the provided MDAO example","text":""},{"location":"code/models/","title":"Data models","text":""},{"location":"code/models/#library-data-models","title":"Library data models","text":"<p>This page provides details on the data models part of the PyPSSE library.</p> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class ApiAssetQuery(BaseModel):\n    asset_type: ModelTypes\n    asset_property: Optional[\n        Union[\n            BusProperties,\n            AreaProperties,\n            ZoneProperties,\n            StationProperties,\n            DCLineProperties,\n            LoadProperties,\n            FixedShuntProperties,\n            SwitchedShuntProperties,\n            TransformerProperties,\n            BranchProperties,\n            InductionGeneratorProperties,\n            MachinesProperties,\n        ]\n    ] = None\n    asset_id: Optional[str] = None\n\n    @model_validator(mode=\"after\")\n    def define_atleast_one(self):\n        assert not (\n            self.asset_id is None and self.asset_property is None\n        ), \"Atleast one 'asset_id' or 'asset_property' should be defined\"\n        return self\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class ApiPsseException(BaseModel):\n    message: str\n    uuid: Union[UUID4, None] = None\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class ApiPssePostRequest(BaseModel):\n    project_name: str = \"static_example\"\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class ApiPssePutRequest(BaseModel):\n    uuid: UUID4\n    command: ApiCommands\n    parameters: Optional[ApiAssetQuery] = None\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class ApiPsseReply(BaseModel):\n    status: str\n    message: Union[Dict, str]\n    uuid: Union[UUID4, None] = None\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class ApiPsseReplyInstances(BaseModel):\n    status: str\n    message: str\n    simulators: List[UUID4] = []\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class ApiWebSocketRequest(BaseModel):\n    command: ApiCommands\n    parameters: Optional[Dict] = None\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Bus channel model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class BusChannel(BaseModel):\n    \"Bus channel model defination\"\n\n    asset_type: Literal[ChannelTypes.BUSES.value]\n    use: UseModes = UseModes.LIST\n    regex: str = \"\"\n    asset_list: List[int] = []\n    asset_properties: List[str] = [\"voltage_and_angle\", \"frequency\"]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Bus fault model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class BusFault(BaseModel):\n    \"Bus fault model defination\"\n    time: float = 0.2\n    bus_id: int = 38205\n    duration: float = 0.3\n    bus_trip: bool = False\n    trip_delay: float = 0.05\n    fault_impedance: List[float] = [\n        1.0,\n        1.0,\n    ]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Bus subsystem model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class BusSubsystems(BaseModel):\n    \"Bus subsystem model defination\"\n    from_file: bool = False\n    bus_file: Optional[str] = None\n    bus_subsystem_list: List[List[int]] = [\n        [\n            74012,\n            17735,\n            20115,\n            38205,\n            70008,\n            80511,\n        ],\n    ]\n    publish_subsystems: List[int] = [\n        0,\n    ]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Bus trip model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class BusTrip(BaseModel):\n    \"Bus trip model defination\"\n    time: float = 0.2\n    bus_id: int = 38205\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class Contingencies(BaseModel):\n    contingencies: List[Union[BusFault, BusTrip, LineFault, LineTrip, MachineTrip]]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Valid export models and associated options</p> Source code in <code>pypsse\\models.py</code> <pre><code>class ExportAssetTypes(BaseModel):\n    \"Valid export models and associated options\"\n\n    buses: Optional[List[BusProperties]] = None\n    areas: Optional[List[AreaProperties]] = None\n    zones: Optional[List[ZoneProperties]] = None\n    stations: Optional[List[StationProperties]] = None\n    dctransmissionlines: Optional[List[DCLineProperties]] = None\n    loads: Optional[List[LoadProperties]] = None\n    fixed_shunts: Optional[List[FixedShuntProperties]] = None\n    switched_shunts: Optional[List[SwitchedShuntProperties]] = None\n    transformers: Optional[List[TransformerProperties]] = None\n    branches: Optional[List[BranchProperties]] = None\n    induction_generators: Optional[List[InductionGeneratorProperties]] = None\n    machines: Optional[List[MachinesProperties]] = None\n</code></pre> <p> </p> <p>             Bases: <code>ExportAssetTypes</code></p> <p>Export settings for a PyPSSE project</p> Source code in <code>pypsse\\models.py</code> <pre><code>class ExportFileOptions(ExportAssetTypes):\n    \"Export settings for a PyPSSE project\"\n\n    export_results_using_channels: bool = False\n    filename_prefix :str = \"\"\n    defined_subsystems_only: bool = True\n    file_format: ExportModes = \"h5\"\n    channels: Optional[List[str]] = None\n    channel_setup: Optional[List[channel_types]] = None\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Export setting model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class ExportSettings(BaseModel):\n    \"Export setting model defination\"\n\n    outx_file: Path = \"test.outx\"\n    out_file: Path = \"20LS11p.out\"\n    excel_file: Path = \"20LS11p.xls\"\n    log_file: Path = \"20LS11p.log\"\n    coordinate_file: Path = \"\"\n    networkx_graph_file: Path = \"20LS11p.gpickle\"\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>GIC export setting model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class GICExportSettings(BaseModel):\n    \"GIC export setting model defination\"\n    include_substation_connections: bool = False\n    include_transfomer_connections: bool = False\n    include_branch_connections: bool = True\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Generator model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class GeneratorSettings(BaseModel):\n    \"Generator model defination\"\n    missing_machine_model: int = 1\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>HELICS co-simualtion setting model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class HelicsSettings(BaseModel):\n    \"HELICS co-simualtion setting model defination\"\n    cosimulation_mode: bool = False\n    federate_name: str = \"psse\"\n    time_delta: timedelta = timedelta(seconds=0.00333333333)\n    core_type: HelicsCoreTypes = \"zmq\"\n    uninterruptible: bool = True\n    helics_logging_level: int = Field(5, ge=1, le=10)\n    create_subscriptions: bool = True\n    iterative_mode: bool = False\n    error_tolerance: float = Field(1e-5, g=0)\n    max_coiterations: int = Field(15, ge=1)\n    broker_ip: IPvAnyAddress = \"127.0.0.1\"\n    broker_port: int = 23404\n    disable_generation_on_coupled_buses: bool = True\n    publications: List[PublicationDefination]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Line fault model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LineFault(BaseModel):\n    \"Line fault model defination\"\n    time: float = 0.2\n    bus_ids: List[int]\n    duration: float = 0.3\n    bus_trip: bool = False\n    trip_delay: float = 0.05\n    fault_impedance: List[float] = [\n        1.0,\n        1.0,\n    ]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Line trip model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LineTrip(BaseModel):\n    \"Line trip model defination\"\n    time: float = 0.2\n    bus_ids: List[int]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Load ZIP model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LoadBreakdown(BaseModel):\n    \"Load ZIP model defination\"\n    constant_current_percentage: float = 0.0\n    constant_admittance_percentage: float = 0.0\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Load channel model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LoadChannel(BaseModel):\n    \"Load channel model defination\"\n\n    asset_type: Literal[ChannelTypes.LOADS.value]\n    use: UseModes = UseModes.LIST\n    regex: str = \"\"\n    asset_list: List[List[str]] = [[]]\n    asset_properties: List[str] = []\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Load model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LoadSettings(BaseModel):\n    \"Load model defination\"\n    convert: bool = True\n    active_load: LoadBreakdown = LoadBreakdown()\n    reactive_load: LoadBreakdown = LoadBreakdown()\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Logger setting model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class LogSettings(BaseModel):\n    \"Logger setting model defination\"\n    disable_psse_logging: bool = True\n    logging_level: LoggingLevels = LoggingLevels.DEBUG\n    log_to_external_file: bool = True\n    display_on_screen: bool = True\n    clear_old_log_file: bool = True\n    pre_configured_logging: bool = False\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Machine channel model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class MachineChannel(BaseModel):\n    \"Machine channel model defination\"\n\n    asset_type: Literal[ChannelTypes.MACHINES.value]\n    use: UseModes = UseModes.LIST\n    regex: str = \"\"\n    asset_list: List[List[str]] = [[]]\n    asset_properties: List[str] = [\"PELEC\", \"QELEC\", \"SPEED\"]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Machine trip model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class MachineTrip(BaseModel):\n    \"Machine trip model defination\"\n    time: float = 0.2\n    bus_id: int = 38205\n    machine_id: str = \"\"\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class MdaoInput(BaseModel):\n    asset_type: WritableModelTypes\n    asset_bus: int\n    asset_id: str\n    attributes: Dict\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class MdaoOutput(BaseModel):\n    buses: List[int]\n    quantities: Dict[ModelTypes, List[str]]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> Source code in <code>pypsse\\models.py</code> <pre><code>class MdaoProblem(BaseModel):\n    outputs: MdaoOutput\n    inputs: List[MdaoInput]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Plotting setting model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class PlotSettings(BaseModel):\n    \"Plotting setting model defination\"\n    enable_dynamic_plots: bool = False\n    columns: int = Field(15, ge=1)\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>PyPSSE project defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class ProjectDefination(BaseModel):\n    \"PyPSSE project defination\"\n    overwrite: bool = False\n    autofill: bool = True\n    project_name: str\n    project_folders: List[ProjectFolders] = list(ProjectFolders)\n    simulation_settings: SimulationSettings\n    export_settings: ExportFileOptions\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Publication setting model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class PublicationDefination(BaseModel):\n    \"\"\"Publication setting model defination\"\"\"\n\n    bus_subsystems: List[int] = [\n        0,\n    ]\n    asset_type: ModelTypes = ModelTypes.BUSES\n    asset_properties: List[ModelProperties] = [ModelProperties.FREQ, ModelProperties.PU]\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>Simulation setting  model defination</p> Source code in <code>pypsse\\models.py</code> <pre><code>class SimSettings(BaseModel):\n    \"Simulation setting  model defination\"\n    simulation_time: timedelta = timedelta(seconds=3.0)\n    simulation_step_resolution: timedelta = timedelta(seconds=0.025)\n    psse_solver_timestep: timedelta = timedelta(seconds=0.00333333333)\n    start_time: datetime = \"01/01/2020 00:00:00\"\n    use_profile_manager: bool\n    project_path: Path = \"C:/Users/alatif/Desktop/NAERM/models/pyPSSEModel\"\n    case_study: Optional[Path] = None\n    raw_file: Optional[Path] = None\n    snp_file: Optional[Path] = None\n    dyr_file: Optional[Path] = None\n    rwm_file: Optional[Path] = None\n    gic_file: Optional[Path] = None\n    subscriptions_file: Optional[Path] = None\n    user_models: List[str] = []\n    setup_files: List[str] = []\n    simulation_mode: SimulationModes\n\n    @model_validator(mode=\"after\")\n    def sim_res_smaller_than_sim_time(self):\n        assert (\n            self.simulation_step_resolution &lt;= self.simulation_time\n        ), \"simulation_step_resolution should be smaller than simulation_time\"\n        return self\n\n    @model_validator(mode=\"after\")\n    def psse_res_smaller_than_sim_time(self):\n        assert (\n            self.psse_solver_timestep &lt;= self.simulation_time\n        ), \"psse_solver_timestep should be smaller than simulation_time\"\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_case_study(self):\n        file_types = [\n            \"case_study\",\n            \"raw_file\",\n            \"snp_file\",\n            \"dyr_file\",\n            \"rwm_file\",\n            \"gic_file\",\n        ]\n        base_project_path = self.project_path\n        for file in file_types:\n            file_path = getattr(self, file)\n            if (\n                file_path\n                and str(file_path) != \".\"\n                and not Path(file_path).exists()\n            ):\n                file_path = base_project_path / CASESTUDY_FOLDER / file_path\n                setattr(self, file, file_path)\n                assert file_path.exists(), f\"{file_path} does not exist\"\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_subscription_file(self):\n        base_project_path = self.project_path\n        if self.subscriptions_file and str(self.subscriptions_file) != \".\":\n            self.subscriptions_file = (\n                base_project_path / self.subscriptions_file\n            )\n            assert (\n                self.subscriptions_file.exists()\n            ), f\"{self.subscriptions_file} does not exist\"\n            data = pd.read_csv(self.subscriptions_file)\n            csv_cols = set(data.columns)\n            sub_cols = {e.value for e in SubscriptionFileRequiredColumns}\n            assert sub_cols.issubset(\n                csv_cols\n            ), f\"{sub_cols} are required columns for a valid subscription file\"\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_user_models(self):\n        base_project_path = self.project_path\n        if self.user_models:\n            paths = []\n            for file in self.user_models:\n                model_file = base_project_path / CASESTUDY_FOLDER / file\n                assert model_file.exists(), f\"{model_file} does not esist\"\n                assert (\n                    model_file.suffix == \".dll\"\n                ), \"Invalid file extension. Use dll files\"\n                paths.append(model_file)\n            self.user_models = paths\n        return self\n\n    @model_validator(mode=\"after\")\n    def validate_simulation_mode(self):\n        if self.simulation_mode in [\n            SimulationModes.DYNAMIC,\n            SimulationModes.SNAP,\n        ]:\n            assert (\n                not self.use_profile_manager\n            ), \"Profile manager can not be used for dynamic simulations. Set 'Use profile manager' to False\"\n        return self\n</code></pre> <p> </p> <p>             Bases: <code>BaseModel</code></p> <p>PyPSSE project settings</p> Source code in <code>pypsse\\models.py</code> <pre><code>class SimulationSettings(BaseModel):\n    \"PyPSSE project settings\"\n\n    simulation: SimSettings\n    export: ExportSettings = ExportSettings()\n    helics: Optional[HelicsSettings] = None\n    log: LogSettings = LogSettings()\n    plots: Optional[PlotSettings] = None\n    gic_export_settings: Optional[GICExportSettings] = None\n    bus_subsystems: BusSubsystems = BusSubsystems()\n    loads: LoadSettings = LoadSettings()\n    generators: GeneratorSettings = GeneratorSettings()\n    contingencies: Optional[\n        List[Union[BusFault, LineFault, LineTrip, BusTrip, MachineTrip]]\n    ] = None\n\n    @model_validator(mode=\"after\")\n    def validate_export_paths(self):\n        base_project_path = self.simulation.project_path\n        if self.export.outx_file:\n            self.export.outx_file = (\n                base_project_path / EXPORTS_FOLDER / self.export.outx_file\n            )\n        if self.export.out_file:\n            self.export.out_file = (\n                base_project_path / EXPORTS_FOLDER / self.export.out_file\n            )\n        if self.export.excel_file:\n            self.export.excel_file = (\n                base_project_path / EXPORTS_FOLDER / self.export.excel_file\n            )\n        if self.export.log_file:\n            self.export.log_file = (\n                base_project_path / LOGS_FOLDER / self.export.log_file\n            )\n        if self.export.networkx_graph_file:\n            self.export.networkx_graph_file = (\n                base_project_path\n                / EXPORTS_FOLDER\n                / self.export.networkx_graph_file\n            )\n        if self.export.coordinate_file:\n            self.export.coordinate_file = (\n                base_project_path / EXPORTS_FOLDER / self.export.coordinate_file\n            )\n        return self\n</code></pre>"},{"location":"code/reference/","title":"PyPSSE package","text":""},{"location":"code/reference/#reference-manual","title":"Reference manual","text":""},{"location":"code/reference/#simulation-components","title":"Simulation components","text":"<p>Base class for the simulator</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>class Simulator:\n    \"Base class for the simulator\"\n\n    _status: SimulationStatus = SimulationStatus.NOT_INITIALIZED\n\n    def __init__(\n        self,\n        settings: SimulationSettings,\n        export_settings: Union[ExportFileOptions, None] = None,\n        psse_version: str = PSSE_VERSIONS.PSSE35.value,\n    ):\n        \"\"\"Load a valid PyPSSE project and sets up simulation\n\n        Args:\n            settings (SimulationSettings): simulation settings\n            export_settings (Union[ExportFileOptions, None]): export settings\n            psse_path (Union[str, Path], optional): Path to python environment within the PSS/e install directory\n        \"\"\"\n\n        self._status = SimulationStatus.STARTING_INSTANCE\n        self.settings = settings\n\n        logger.debug(f\"Instantiating psse version {psse_version}\")\n        __import__(psse_version, fromlist=[\"\"])  # noqa: F401\n\n        import dyntools\n        import psspy\n        logger.debug(f\"Imported psspy suscessfully\")\n\n        ierr = psspy.psseinit(N_BUS)\n        assert ierr == 0, f\"Error code: {ierr}\"\n        logger.debug(f\"PSSE initialized sucessfully suscessfully\")\n        if export_settings is None:\n            export_settings_path = (\n                Path(self.settings.simulation.project_path)\n                / EXPORTS_SETTINGS_FILENAME\n            )\n            assert (\n                export_settings_path.exists()\n            ), f\"{export_settings_path} does nor exist\"\n            export_settings = toml.load(export_settings_path)\n            export_settings = ExportFileOptions(**export_settings)\n\n        self.export_settings = export_settings\n        log_path = os.path.join(\n            self.settings.simulation.project_path, LOGS_FOLDER\n        )\n        logger.debug(\"Starting PSSE instance\")\n\n        self.dyntools = dyntools\n        self.psse = psspy\n        # logger.debug('Initializing PSS/E. connecting to license server')\n\n        self.start_simulation()\n        self.init()\n        self._status = SimulationStatus.INITIALIZATION_COMPLETE\n\n    @classmethod\n    def from_setting_files(\n        cls, simulation_settiings_file: Path, export_Settings_file: Path = None\n    ):\n        \"\"\"build 'Simulator' from toml settings files\n\n        Args:\n            simulation_settiings_file (Path): simulation settings\n            export_Settings_file (Path): export settings\n        \"\"\"\n        simulation_settiings = toml.load(simulation_settiings_file)\n        if export_Settings_file:\n            export_Settings = toml.load(export_Settings_file)\n        else:\n            export_Settings = toml.load(\n                simulation_settiings_file.parent / EXPORTS_SETTINGS_FILENAME\n            )\n\n        simulation_settiings = SimulationSettings(**simulation_settiings)\n        export_Settings = ExportFileOptions(**export_Settings)\n        return cls(simulation_settiings, export_Settings)\n\n    def dump_settings(\n        self,\n        dest_dir: Path,\n        simulation_file: str = SIMULATION_SETTINGS_FILENAME,\n        export_file: str = EXPORTS_SETTINGS_FILENAME,\n    ):\n        \"\"\"Dumps simulation settings to a provided path\n\n        Args:\n            dest_dir (Path): Directory where settins are dumped\n            simulation_file (str, optional): simulation filename. Defaults to SIMULATION_SETTINGS_FILENAME.\n            export_file (str, optional): export setting filename. Defaults to EXPORTS_SETTINGS_FILENAME.\n        \"\"\"\n\n        settings_json = self.settings.model_dump_json()\n        json.dump(settings_json, open(dest_dir / simulation_file, \"w\"))\n\n        export_settings_json = self.settings.model_dump_json()\n        json.dump(export_settings_json, open(dest_dir / export_file, \"w\"))\n\n    def start_simulation(self):\n        \"\"\"Starts a loaded simulation\n\n        Raises:\n            Exception: Please pass a RAW or SAV file in the settings dictionary\n        \"\"\"\n\n        self.hi = None\n        self.simStartTime = time.time()\n\n        if self.settings.simulation.case_study.exists():\n            self.psse.case(str(self.settings.simulation.case_study))\n        elif self.settings.simulation.raw_file.exists():\n            self.psse.read(0, str(self.settings.simulation.raw_file))\n        else:\n            msg = \"Please pass a RAW or SAV file in the settings dictionary\"\n            raise Exception(msg)\n\n        logger.info(\n            f\"Trying to read a file &gt;&gt;{self.settings.simulation.case_study}\"\n        )\n        self.raw_data = rd.Reader(self.psse)\n        (\n            self.bus_subsystems,\n            self.all_subsysten_buses,\n        ) = self.define_bus_subsystems()\n\n        if self.export_settings.defined_subsystems_only:\n            valid_buses = self.all_subsysten_buses\n        else:\n            valid_buses = self.raw_data.buses\n\n        self.sim = sc.sim_controller(\n            self.psse,\n            self.dyntools,\n            self.settings,\n            self.export_settings,\n            valid_buses,\n            self.raw_data,\n        )\n\n        self.contingencies = self.build_contingencies()\n\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            if self.settings.simulation.simulation_mode in [\n                SimulationModes.DYNAMIC,\n                SimulationModes.SNAP,\n            ]:\n                ...\n            self.hi = HelicsInterface(\n                self.psse,\n                self.sim,\n                self.settings,\n                self.export_settings,\n                self.bus_subsystems,\n            )\n            self.publications = self.hi.register_publications(\n                self.bus_subsystems\n            )\n            if self.settings.helics.create_subscriptions:\n                self.subscriptions = self.hi.register_subscriptions()\n\n        if self.settings.simulation.gic_file:\n            self.network_graph = self.parse_gic_file()\n            self.bus_ids = self.network_graph.nodes.keys()\n        else:\n            self.network_graph = None\n\n        self.results = Container(self.settings, self.export_settings)\n        self.exp_vars = self.results.get_export_variables()\n        self.inc_time = True\n\n    def init(self):\n        \"\"\"Initializes the model\"\"\"\n\n        self.sim.init(self.bus_subsystems)\n\n        if self.settings.simulation.use_profile_manager:\n            self.pm = ProfileManager(self.sim, self.settings)\n            self.pm.setup_profiles()\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            self.hi.enter_execution_mode()\n\n    def parse_gic_file(self) -&gt; Graph:\n        \"\"\"Parses the GIC file (if included in the project)\n\n        Returns:\n            Graph: Networkx graph representation for the model\n        \"\"\"\n\n        gicdata = gp.GICParser(self.settings)\n        return gicdata.psse_graph\n\n    def define_bus_subsystems(self) -&gt; (dict, list):\n        \"\"\"Defines a bussystem in the loaded PSSE model\n\n        Raises:\n            LookupError: Failed to create bus subsystem chosen buses.\n            ValueError: Number of subsystems can not be more that 12. See PSSE documentation\n            RuntimeError: Failed to add buses to bus subsystem\n\n        Returns:\n            dict: mapping of bus subsystems to buses\n            list: List of bus subsystems\n        \"\"\"\n\n        bus_subsystems_dict = {}\n        bus_subsystems = self.get_bus_indices()\n        # valid bus subsystem ID. Valid bus subsystem IDs range from 0 to 11 (PSSE documentation)\n        if len(bus_subsystems) &gt; MAX_PSSE_BUSSYSTEMS:\n            msg = \"Number of subsystems can not be more that 12. See PSSE documentation\"\n            raise ValueError(msg)\n\n        all_subsysten_buses = []\n        for i, buses in enumerate(bus_subsystems):\n            if not buses:\n                continue\n\n            all_subsysten_buses.extend(buses)\n            ierr = self.psse.bsysinit(i)\n            if ierr:\n                msg = \"Failed to create bus subsystem chosen buses.\"\n                raise LookupError(msg)\n            else:\n                logger.debug(f'Bus subsystem \"{i}\" created')\n\n            ierr = self.psse.bsys(sid=i, numbus=len(buses), buses=buses)\n            if ierr:\n                msg = \"Failed to add buses to bus subsystem.\"\n                raise RuntimeError(msg)\n            else:\n                bus_subsystems_dict[i] = buses\n                logger.debug(f'Buses {buses} added to subsystem \"{i}\"')\n        all_subsysten_buses = [str(x) for x in all_subsysten_buses]\n        return bus_subsystems_dict, all_subsysten_buses\n\n    def get_bus_indices(self) -&gt; BusSubsystems:\n        \"\"\"Returns bus indices for bus subsystems\n\n        Returns:\n            BusSubsystems: Bus subsystem model\n        \"\"\"\n\n        if self.settings.bus_subsystems.from_file:\n            bus_file = self.settings.bus_subsystems.bus_file\n            bus_info = pd.read_csv(bus_file, index_col=None)\n            bus_info = bus_info.values\n            _, n_cols = bus_info.shape\n            bus_data = []\n            for col in range(n_cols):\n                data = [int(x) for x in bus_info[:, col] if not np.isnan(x)]\n                bus_data.append(data)\n        else:\n            bus_data = self.settings.bus_subsystems.bus_subsystem_list\n        return bus_data\n\n    def run(self):\n        \"\"\"Launches the simulation\"\"\"\n\n        self._status = SimulationStatus.RUNNING_SIMULATION\n        if self.sim.initialization_complete:\n            if self.settings.plots and self.settings.plots.enable_dynamic_plots:\n                bokeh_server_proc = subprocess.Popen(\n                    [\"bokeh\", \"serve\"], stdout=subprocess.PIPE\n                )  # noqa: S603,S607\n            else:\n                bokeh_server_proc = None\n\n            logger.debug(\n                f\"Running dynamic simulation for time {self.settings.simulation.simulation_time.total_seconds()} sec\"\n            )\n            total_simulation_time = (\n                self.settings.simulation.simulation_time.total_seconds()\n            )\n            t = 0\n            while True:\n                self.step(t)\n                if self.inc_time:\n                    t += (\n                        self.settings.simulation.simulation_step_resolution.total_seconds()\n                    )\n                if t &gt;= total_simulation_time:\n                    break\n\n            self.psse.pssehalt_2()\n            if not self.export_settings.export_results_using_channels:\n                self.results.export_results()\n            else:\n                self.sim.export()\n\n            if bokeh_server_proc is not None:\n                bokeh_server_proc.terminate()\n        else:\n            logger.error(\n                \"Run init() command to initialize models before running the simulation\"\n            )\n        self._status = \"Simulation complete\"\n\n    def get_bus_ids(self) -&gt; list:\n        \"\"\"Returns bus IDs\n\n        Returns:\n            list: Array of bus numbers\n        \"\"\"\n\n        ierr, iarray = self.psse.abusint(-1, 1, \"NUMBER\")\n        assert ierr == 0, f\"Error code: {ierr}\"\n        return iarray\n\n    def step(self, t: float) -&gt; dict:\n        \"\"\"Steps through a single simulation time step. Is called iteratively to increment the simualtion\n\n        Args:\n            t (float): time step for the simulation\n\n        Returns:\n            dict: results from the current timestep\n        \"\"\"\n\n        self.update_contingencies(t)\n        if self.settings.simulation.use_profile_manager:\n            self.pm.update()\n        ctime = time.time() - self.simStartTime\n        logger.debug(\n            f\"Simulation time: {t} seconds\\nRun time: {ctime}\\npsse time: {self.sim.get_time()}\"\n        )\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            if self.settings.helics.create_subscriptions:\n                self.update_subscriptions()\n                logger.debug(f\"Time requested: {t}\")\n                self.inc_time, helics_time = self.update_federate_time(t)\n                logger.debug(f\"Time granted: {helics_time}\")\n\n        if self.inc_time:\n            self.sim.step(t)\n        else:\n            self.sim.resolve_step()\n\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            self.publish_data()\n\n        curr_results = self.update_result_container(t)\n        return curr_results\n\n    def update_result_container(self, t: float) -&gt; dict:\n        \"\"\"Updates the result container with results from the current time step\n\n        Args:\n            t (float): simulation time in seconds\n\n        Returns:\n            dict: simulation reults from the current time step\n        \"\"\"\n\n        if self.export_settings.defined_subsystems_only:\n            curr_results = self.sim.read_subsystems(\n                self.exp_vars, self.all_subsysten_buses\n            )\n        else:\n            curr_results = self.sim.read_subsystems(\n                self.exp_vars, self.raw_data.buses\n            )\n\n        if not USING_NAERM:\n            if not self.export_settings.export_results_using_channels:\n                self.results.update(\n                    curr_results,\n                    t,\n                    self.sim.get_time(),\n                    self.sim.has_converged(),\n                )\n        return curr_results\n\n    def update_subscriptions(self):\n        \"\"\"Updates subscriptions (co-simulation mode only)\"\"\"\n\n        self.hi.subscribe()\n\n    def update_federate_time(self, t: float) -&gt; (float, float):\n        \"\"\"Makes a time request to teh HELICS broker (co-simulation mode only)\n\n        Args:\n            t (float): simulation time in seconds\n\n        Returns:\n            float: requested time in seconds\n            float: current simualtion time in seconds\n        \"\"\"\n\n        inc_time, curr_time = self.hi.request_time(t)\n        return inc_time, curr_time\n\n    def publish_data(self):\n        \"\"\"Updates publications (co-simulation mode only)\"\"\"\n\n        self.hi.publish()\n\n    def get_results(self, params: Union[ExportAssetTypes, dict]) -&gt; dict:\n        \"\"\"Returns queried simulation results\n\n        Args:\n            params (Union[ExportAssetTypes, dict]): _description_\n\n        Returns:\n            dict: simulation results\n        \"\"\"\n\n        self._status = SimulationStatus.STARTING_RESULT_EXPORT\n        self.exp_vars = self.results.update_export_variables(params)\n        curr_results = (\n            self.sim.read_subsystems(self.exp_vars, self.all_subsysten_buses)\n            if self.export_settings.defined_subsystems_only\n            else self.sim.read_subsystems(self.exp_vars, self.raw_data.buses)\n        )\n        self._status = SimulationStatus.RESULT_EXPORT_COMPLETE\n        return curr_results\n\n    def status(self) -&gt; SimulationStatus:\n        \"\"\"returns current simulation status\n\n        Returns:\n            SimulationStatus: state of the simulator\n        \"\"\"\n        return self._status.value\n\n    def build_contingencies(\n        self,\n    ) -&gt; List[\n        Union[\n            BusTripObject,\n            BusFaultObject,\n            LineTripObject,\n            LineFaultObject,\n            MachineTripObject,\n        ]\n    ]:\n        \"\"\"Builds user defined contengingies\n\n        Returns:\n            List[Union[BusFault, LineFault, LineTrip, BusTrip, MachineTrip]]: List of contingencies\n        \"\"\"\n\n        contingencies = c.build_contingencies(self.psse, self.settings)\n        return contingencies\n\n    def inject_contingencies_external(self, contigencies: Contingencies):\n        \"\"\"Inject external contingencies.\n\n        Args:\n            contigencies (Contingencies): Contigencies Object\n        \"\"\"\n        contingencies = c.build_contingencies(self.psse, contigencies)\n        self.contingencies.extend(contingencies)\n\n    def update_contingencies(self, t: float):\n        \"\"\"Updates contingencies during the simualtion run\n\n        Args:\n            t (float): simulation time in seconds\n        \"\"\"\n\n        for contingency in self.contingencies:\n            contingency.update(t)\n\n    def force_psse_halt(self):\n        \"\"\"forces cleaup of pypss imort\"\"\"\n        ierr = self.psse.pssehalt_2()\n        assert ierr == 0, f\"failed to halt PSSE. Error code - {ierr}\"\n\n    def __del__(self):\n        try:\n            self.force_psse_halt()\n        except:\n            pass\n</code></pre> <p>This class defines the structure of a PyPSSE project</p> Source code in <code>pypsse\\project.py</code> <pre><code>class Project:\n    \"This class defines the structure of a PyPSSE project\"\n\n    def __init__(self):\n        self.basepath = Path(__file__).parent\n\n    def create(\n        self,\n        parent_path: Path,\n        project_name: str,\n        psse_folder: Path,\n        simulation_settings_file: Path,\n        export_settings_file: Path,\n        profile_store_file: Path,\n        profile_mapping_file: Path,\n        overwrite: bool = True,\n        autofill: bool = True,\n    ):\n        \"\"\"The methods creates a new PyPSSE project\n\n        Args:\n            parent_path (Path): path to new pypsse project\n            project_name (str): project name\n            psse_folder (Path): _description_\n            simulation_settings_file (Path): simulation settings toml file path\n            export_settings_file (Path): export settings toml file path\n            profile_store_file (Path): path to a valid Profiles.hdf5 file (Contains profiles for time series simulations)\n            profile_mapping_file (Path): path to a valid Profile_mapping.toml file (used to map profile to PSSE elements)\n            overwrite (bool, optional): Attempt to auto fill settings. (Verify manually settings file is correct). Defaults to True.\n            autofill (bool, optional): Overwrite project is it already exists. Defaults to True.\n        \"\"\"\n\n        self.project_path = Path(parent_path) / project_name\n\n        exports_dict = toml.load(self.basepath / DEFAULTS_FOLDER / EXPORTS_SETTINGS_FILENAME)\n        export_settings = ExportFileOptions(**exports_dict)\n\n        if export_settings_file:\n            export_settings_file = Path(export_settings_file)\n            assert export_settings_file.exists(), f\"Export file '{export_settings_file}' does not exist\"\n            new_export_settings = toml.load(export_settings_file)\n            export_settings.update(**new_export_settings)\n\n        sim_setting_dict = toml.load(self.basepath / DEFAULTS_FOLDER / SIMULATION_SETTINGS_FILENAME)\n        sim_setting_dict[\"simulation\"][\"project_path\"] = str(self.project_path)\n        simulation_settings = SimulationSettings(**sim_setting_dict)\n\n        if simulation_settings_file:\n            simulation_settings_file = Path(simulation_settings_file)\n            assert simulation_settings_file.exists(), f\"Export file '{simulation_settings_file}' does not exist\"\n            sim_setting_dict = toml.load(simulation_settings_file)\n            simulation_settings.update(**sim_setting_dict)\n\n        simulation_settings.simulation.project_path = Path(parent_path) / project_name\n\n        self.project = ProjectDefination(\n            project_name=project_name,\n            simulation_settings=simulation_settings,\n            export_settings=export_settings,\n            overwrite=overwrite,\n            autofill=autofill,\n        )\n\n        self._create_folders()\n\n        if psse_folder:\n            psse_files = self._copy_psse_project_files(psse_folder)\n            if autofill and psse_files:\n                self._autofill_settings(psse_files, profile_store_file, profile_mapping_file)\n\n        self._update_export_files()\n        self._write_setting_files()\n\n    def _update_export_files(self):\n        \"\"\"sets up export file paths\"\"\"\n        self.project.simulation_settings.export.out_file = DEFAULT_OUT_FILE\n        self.project.simulation_settings.export.outx_file = DEFAULT_OUTX_FILE\n        self.project.simulation_settings.export.log_file = DEFAULT_LOG_FILE\n        self.project.simulation_settings.export.excel_file = DEFAULT_EXCEL_FILE\n        self.project.simulation_settings.export.coordinate_file = DEFAULT_COORDINATES_FILE\n        self.project.simulation_settings.export.networkx_graph_file = DEFAULT_GRAPH_FILE\n\n    def _psse_project_file_dict(self, path: Path) -&gt; dict:\n        \"\"\"Creates a mapping of all project files in a folder\n\n        Args:\n            path (Path): path (folder) to existing psse project\n\n        Returns:\n            dict: mapping of file types to paths\n        \"\"\"\n\n        file_dict = {}\n        for _, _, files in os.walk(path):\n            for file in files:\n                _, ext = file.split(\".\")\n                if ext not in file_dict:\n                    file_dict[ext.lower()] = [file]\n                else:\n                    file_dict[ext.lower()].append(file)\n        return file_dict\n\n    def _copy_psse_project_files(self, psse_folder: Path) -&gt; dict:\n        \"\"\"Copies psse files to a new project\n\n        Args:\n            psse_folder (Path): path (folder) to existing psse project\n\n        Raises:\n            FileExistsError: raised if provided project path does not exist\n\n        Returns:\n            dict: mapping of file types to paths\n        \"\"\"\n\n        psse_folder = Path(psse_folder)\n        if psse_folder.exists():\n            new_path = self.project_path / CASESTUDY_FOLDER\n            copy_tree(str(psse_folder.absolute()), str(new_path.absolute()))\n            psse_files = self._psse_project_file_dict(new_path)\n        else:\n            msg = f\"PSSE project path does not exist. ({psse_folder}) {os.getcwd()}\"\n            raise FileExistsError(msg)\n        return psse_files\n\n    def _write_setting_files(self):\n        \"\"\"serialized simulation and export setting  files for the new project\"\"\"\n        sim_file_path = self.project_path / SIMULATION_SETTINGS_FILENAME\n        with open(sim_file_path, \"w\") as f:\n            toml.dump(json.loads(self.project.simulation_settings.model_dump_json()), f)\n            logger.info(f\"writing file : {sim_file_path!s}\")\n\n        export_file_path = self.project_path / EXPORTS_SETTINGS_FILENAME\n        with open(export_file_path, \"w\") as f:\n            toml.dump(json.loads(self.project.export_settings.model_dump_json()), f)\n            logger.info(f\"writing file : {export_file_path!s}\")\n\n    def _create_folders(self):\n        \"\"\"Creates folder structure for a new project. Older project can be over-written\n\n        Raises:\n            FileExistsError: raised if provided folder path does not exist\n        \"\"\"\n\n        for folder in self.project.project_folders:\n            project_folder = self.project_path / folder.value\n            if project_folder.exists() and not self.project.overwrite:\n                msg = \"Project folder already exists. Set overwrite=true to overwrite existing projects\"\n                raise FileExistsError(msg)\n            elif not project_folder.exists():\n                project_folder.mkdir(parents=True, exist_ok=True)\n                logger.info(f\"folder created: {project_folder!s}\")\n\n    def _autofill_settings(self, psse_files: dict, profile_store_file: Path, profile_mapping_file: Path):\n        \"\"\"The method auto populates fields for a new PyPSSE project\n\n        Args:\n            psse_files (dict): mapping of file type to file path\n            profile_store_file (Path): path to profile store file (hdf5)\n            profile_mapping_file (Path): path to profile mapping file (toml)\n        \"\"\"\n\n        self._update_setting(\"sav\", \"case_study\", psse_files)\n        self._update_setting(\"raw\", \"raw_file\", psse_files)\n        self._update_setting(\"snp\", \"snp_file\", psse_files)\n        self._update_setting(\"dyr\", \"dyr_file\", psse_files)\n        self._update_setting(\"gic\", \"gic_file\", psse_files)\n        self._update_setting(\"rwm\", \"rwm_file\", psse_files)\n\n        if \"dll\" in psse_files:\n            self.project.simulation_settings.simulation.user_models = psse_files[\"dll\"]\n            logger.info(f\"user_models={psse_files['dll']}\")\n        else:\n            logger.info(\"No DLL files found in project path\")\n\n        if \"idv\" in psse_files:\n            self.project.simulation_settings.simulation.setup_files = psse_files[\"idv\"]\n            logger.info(\n                f\"setup_files={psse_files['idv']}\"\n                f\"\\nSequence of IDV setup files is important. Manually change in TOML file if needed\"\n            )\n        else:\n            logger.info(\"No IDV files found in project path\")\n\n        store_path = self.project_path / PROFILES_FOLDER\n        if profile_store_file and Path(profile_store_file).exists():\n            assert Path(profile_store_file).suffix.lower() == \".hdf5\", \"Store file should be a valid hdf5 file\"\n            copy(profile_store_file, store_path)\n        else:\n            ProfileManager(None, self.project.simulation_settings)\n\n        if profile_mapping_file and Path(profile_mapping_file).exists():\n            assert Path(profile_mapping_file).suffix.lower() == \".toml\", \"Profile mapping should be a valid toml file\"\n            copy(profile_mapping_file, store_path)\n            self.project.simulation_settings.simulation.use_profile_manager = True\n        else:\n            # TODO: auto generate mapping file from bus subsystem files\n            with open(os.path.join(store_path, DEFAULT_PROFILE_MAPPING_FILENAME), \"w\") as _:\n                pass\n            self.project.simulation_settings.simulation.use_profile_manager = False\n\n        self._create_default_sub_file()\n\n    def _create_default_sub_file(self):\n        \"\"\"Method creates a subscription file for the HELICS interface\"\"\"\n\n        subscription_fields = [x.value for x in SubscriptionFileRequiredColumns]\n        data = pd.DataFrame({}, columns=list(subscription_fields))\n        data.to_csv(self.project_path / DEFAULT_SUBSCRIPTION_FILENAME, index=False)\n        logger.info(\"Creating subscription template\")\n        self.project.simulation_settings.simulation.subscriptions_file = DEFAULT_SUBSCRIPTION_FILENAME\n\n    def _update_setting(self, f_type: str, key: str, psse_files: dict):\n        \"\"\"updates settings for the new project\n\n        Args:\n            f_type (str): file type\n            key (str): simulation setting to update\n            psse_files (dict): mapping of file type to file path\n        \"\"\"\n        if f_type in psse_files:\n            relevent_files = psse_files[f_type]\n            setattr(self.project.simulation_settings.simulation, key, relevent_files[0])\n            logger.info(f\"Settings:{key}={relevent_files[0]}\")\n            if len(relevent_files) &gt; 1:\n                logger.warning(\n                    f\"More than one file with extension {f_type} exist.\"\n                    f\"\\nFiles found: {relevent_files}\"\n                    f\"\\nManually update the settings toml file\"\n                )\n        else:\n            logger.warning(f\"No file with extension '{f_type}'\")\n</code></pre> <p>Class defination for the simulation result container</p> Source code in <code>pypsse\\result_container.py</code> <pre><code>class Container:\n    \"Class defination for the simulation result container\"\n\n    BULK_WRITE_MODES = [m.value for m in BulkWriteModes]\n    STREAMED_WRITE_MODES = [m.value for m in StreamedWriteModes]\n\n    def __init__(self, settings: SimulationSettings, export_settings: ExportFileOptions):\n        \"\"\"Sets up the result container object\n\n        Args:\n            settings (SimulationSettings): _description_\n            export_settings (ExportAssetTypes): _description_\n        \"\"\"\n\n        export__list = [m.value for m in ModelTypes]\n        self.export_path = settings.simulation.project_path / EXPORTS_FOLDER\n        self.export_settings = export_settings\n        self.settings = settings\n        self.results = {}\n        self.export_vars = {}\n        for class_name in export__list:\n            mapped_name = MAPPED_CLASS_NAMES[class_name.lower()]\n            variables = getattr(export_settings, class_name.lower())\n            if variables:\n                for variable in variables:\n                    self.results[f\"{mapped_name}_{variable.value}\"] = None\n                    if mapped_name not in self.export_vars:\n                        self.export_vars[mapped_name] = []\n                    self.export_vars[mapped_name].append(variable.value)\n\n        time_steps = int(\n            self.settings.simulation.simulation_time.total_seconds()\n            / self.settings.simulation.simulation_step_resolution.total_seconds()\n        )\n        if self.export_settings.file_format not in self.BULK_WRITE_MODES:\n            self.dataWriter = DataWriter(self.export_path, export_settings.file_format.value, time_steps,  self.export_settings.filename_prefix)\n\n    def update_export_variables(self, params: Union[ExportAssetTypes, dict]) -&gt; dict:\n        \"\"\"Updates the container with current system state.\n        Method is called iteratively to store results as a simulation executes\n\n        Args:\n            params (Union[ExportAssetTypes, dict]): _description_\n\n        Returns:\n            dict: mapping of export variables to values\n        \"\"\"\n        export__list = [m.value for m in ModelTypes]\n        self.results = {}\n        self.export_vars = {}\n        if params:\n            if isinstance(params, ExportAssetTypes):\n                class_assets = params\n            else:\n                class_assets = ExportAssetTypes(**params)\n        else:\n            class_assets = self.export_settings\n\n        inv_map = {v: k for k, v in MAPPED_CLASS_NAMES.items()}\n\n        for class_name in export__list:\n            if inv_map[class_name] in params:\n                variables = getattr(class_assets, inv_map[class_name])\n                if variables:\n                    for variable in variables:\n                        self.results[f\"{class_name}_{variable.value}\"] = None\n                        if class_name not in self.export_vars:\n                            self.export_vars[class_name] = []\n                        self.export_vars[class_name].append(variable.value)\n\n        return self.export_vars\n\n    def get_export_variables(self) -&gt; dict:\n        \"\"\"Queries and return results from the current timestep\n\n        Returns:\n            dict: mapping of export variables to values\n        \"\"\"\n\n        return self.export_vars\n\n    def update(self, bus_data: dict, _, time: datetime.datetime, has_converged: bool):\n        \"\"\"Updates the results cotainer\n\n        Args:\n            bus_data (dict): mapping of vairables to values\n            _ (_type_): _description_\n            time (datetime.datetime): simulation time\n            has_converged (bool): flag showing if simulation converged\n        \"\"\"\n\n        if self.export_settings.file_format not in self.BULK_WRITE_MODES:\n            self.dataWriter.write(time, bus_data, has_converged)\n        else:\n            for variable_name, _ in bus_data.items():\n                if not isinstance(self.results[f\"{variable_name}\"], pd.DataFrame):\n                    self.results[f\"{variable_name}\"] = pd.DataFrame(bus_data[variable_name], index=[0])\n                else:\n                    df1 = self.results[f\"{variable_name}\"]\n                    df2 = pd.DataFrame.from_dict([bus_data[variable_name]])\n                    concatenated = pd.concat([df1, df2])\n                    self.results[f\"{variable_name}\"] = concatenated\n        logger.debug(\"result container updated\")\n\n    def export_results(self):\n        \"\"\"exports all results stored to an external file\"\"\"\n\n        if self.export_settings.file_format in self.BULK_WRITE_MODES:\n            for df_name, df in self.results.items():\n                export_path = (\n                    self.settings.simulation.project_path\n                    / EXPORTS_FOLDER\n                    / f'{df_name}.{self.export_settings.file_format}'\n                )\n                if self.export_settings.file_format == BulkWriteModes.CSV:\n                    if isinstance(df, pd.DataFrame):\n                        df.to_csv(export_path)\n                elif self.export_settings.file_format == BulkWriteModes.PKL:\n                    df.to_pickle(export_path)\n                logger.info(f\"results exported to {export_path}\")\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.__init__","title":"<code>__init__(settings, export_settings=None, psse_version=PSSE_VERSIONS.PSSE35.value)</code>","text":"<p>Load a valid PyPSSE project and sets up simulation</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>SimulationSettings</code> <p>simulation settings</p> required <code>export_settings</code> <code>Union[ExportFileOptions, None]</code> <p>export settings</p> <code>None</code> <code>psse_path</code> <code>Union[str, Path]</code> <p>Path to python environment within the PSS/e install directory</p> required Source code in <code>pypsse\\simulator.py</code> <pre><code>def __init__(\n    self,\n    settings: SimulationSettings,\n    export_settings: Union[ExportFileOptions, None] = None,\n    psse_version: str = PSSE_VERSIONS.PSSE35.value,\n):\n    \"\"\"Load a valid PyPSSE project and sets up simulation\n\n    Args:\n        settings (SimulationSettings): simulation settings\n        export_settings (Union[ExportFileOptions, None]): export settings\n        psse_path (Union[str, Path], optional): Path to python environment within the PSS/e install directory\n    \"\"\"\n\n    self._status = SimulationStatus.STARTING_INSTANCE\n    self.settings = settings\n\n    logger.debug(f\"Instantiating psse version {psse_version}\")\n    __import__(psse_version, fromlist=[\"\"])  # noqa: F401\n\n    import dyntools\n    import psspy\n    logger.debug(f\"Imported psspy suscessfully\")\n\n    ierr = psspy.psseinit(N_BUS)\n    assert ierr == 0, f\"Error code: {ierr}\"\n    logger.debug(f\"PSSE initialized sucessfully suscessfully\")\n    if export_settings is None:\n        export_settings_path = (\n            Path(self.settings.simulation.project_path)\n            / EXPORTS_SETTINGS_FILENAME\n        )\n        assert (\n            export_settings_path.exists()\n        ), f\"{export_settings_path} does nor exist\"\n        export_settings = toml.load(export_settings_path)\n        export_settings = ExportFileOptions(**export_settings)\n\n    self.export_settings = export_settings\n    log_path = os.path.join(\n        self.settings.simulation.project_path, LOGS_FOLDER\n    )\n    logger.debug(\"Starting PSSE instance\")\n\n    self.dyntools = dyntools\n    self.psse = psspy\n    # logger.debug('Initializing PSS/E. connecting to license server')\n\n    self.start_simulation()\n    self.init()\n    self._status = SimulationStatus.INITIALIZATION_COMPLETE\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.build_contingencies","title":"<code>build_contingencies()</code>","text":"<p>Builds user defined contengingies</p> <p>Returns:</p> Type Description <code>List[Union[BusTripObject, BusFaultObject, LineTripObject, LineFaultObject, MachineTripObject]]</code> <p>List[Union[BusFault, LineFault, LineTrip, BusTrip, MachineTrip]]: List of contingencies</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def build_contingencies(\n    self,\n) -&gt; List[\n    Union[\n        BusTripObject,\n        BusFaultObject,\n        LineTripObject,\n        LineFaultObject,\n        MachineTripObject,\n    ]\n]:\n    \"\"\"Builds user defined contengingies\n\n    Returns:\n        List[Union[BusFault, LineFault, LineTrip, BusTrip, MachineTrip]]: List of contingencies\n    \"\"\"\n\n    contingencies = c.build_contingencies(self.psse, self.settings)\n    return contingencies\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.define_bus_subsystems","title":"<code>define_bus_subsystems()</code>","text":"<p>Defines a bussystem in the loaded PSSE model</p> <p>Raises:</p> Type Description <code>LookupError</code> <p>Failed to create bus subsystem chosen buses.</p> <code>ValueError</code> <p>Number of subsystems can not be more that 12. See PSSE documentation</p> <code>RuntimeError</code> <p>Failed to add buses to bus subsystem</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>(dict, list)</code> <p>mapping of bus subsystems to buses</p> <code>list</code> <code>(dict, list)</code> <p>List of bus subsystems</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def define_bus_subsystems(self) -&gt; (dict, list):\n    \"\"\"Defines a bussystem in the loaded PSSE model\n\n    Raises:\n        LookupError: Failed to create bus subsystem chosen buses.\n        ValueError: Number of subsystems can not be more that 12. See PSSE documentation\n        RuntimeError: Failed to add buses to bus subsystem\n\n    Returns:\n        dict: mapping of bus subsystems to buses\n        list: List of bus subsystems\n    \"\"\"\n\n    bus_subsystems_dict = {}\n    bus_subsystems = self.get_bus_indices()\n    # valid bus subsystem ID. Valid bus subsystem IDs range from 0 to 11 (PSSE documentation)\n    if len(bus_subsystems) &gt; MAX_PSSE_BUSSYSTEMS:\n        msg = \"Number of subsystems can not be more that 12. See PSSE documentation\"\n        raise ValueError(msg)\n\n    all_subsysten_buses = []\n    for i, buses in enumerate(bus_subsystems):\n        if not buses:\n            continue\n\n        all_subsysten_buses.extend(buses)\n        ierr = self.psse.bsysinit(i)\n        if ierr:\n            msg = \"Failed to create bus subsystem chosen buses.\"\n            raise LookupError(msg)\n        else:\n            logger.debug(f'Bus subsystem \"{i}\" created')\n\n        ierr = self.psse.bsys(sid=i, numbus=len(buses), buses=buses)\n        if ierr:\n            msg = \"Failed to add buses to bus subsystem.\"\n            raise RuntimeError(msg)\n        else:\n            bus_subsystems_dict[i] = buses\n            logger.debug(f'Buses {buses} added to subsystem \"{i}\"')\n    all_subsysten_buses = [str(x) for x in all_subsysten_buses]\n    return bus_subsystems_dict, all_subsysten_buses\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.dump_settings","title":"<code>dump_settings(dest_dir, simulation_file=SIMULATION_SETTINGS_FILENAME, export_file=EXPORTS_SETTINGS_FILENAME)</code>","text":"<p>Dumps simulation settings to a provided path</p> <p>Parameters:</p> Name Type Description Default <code>dest_dir</code> <code>Path</code> <p>Directory where settins are dumped</p> required <code>simulation_file</code> <code>str</code> <p>simulation filename. Defaults to SIMULATION_SETTINGS_FILENAME.</p> <code>SIMULATION_SETTINGS_FILENAME</code> <code>export_file</code> <code>str</code> <p>export setting filename. Defaults to EXPORTS_SETTINGS_FILENAME.</p> <code>EXPORTS_SETTINGS_FILENAME</code> Source code in <code>pypsse\\simulator.py</code> <pre><code>def dump_settings(\n    self,\n    dest_dir: Path,\n    simulation_file: str = SIMULATION_SETTINGS_FILENAME,\n    export_file: str = EXPORTS_SETTINGS_FILENAME,\n):\n    \"\"\"Dumps simulation settings to a provided path\n\n    Args:\n        dest_dir (Path): Directory where settins are dumped\n        simulation_file (str, optional): simulation filename. Defaults to SIMULATION_SETTINGS_FILENAME.\n        export_file (str, optional): export setting filename. Defaults to EXPORTS_SETTINGS_FILENAME.\n    \"\"\"\n\n    settings_json = self.settings.model_dump_json()\n    json.dump(settings_json, open(dest_dir / simulation_file, \"w\"))\n\n    export_settings_json = self.settings.model_dump_json()\n    json.dump(export_settings_json, open(dest_dir / export_file, \"w\"))\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.force_psse_halt","title":"<code>force_psse_halt()</code>","text":"<p>forces cleaup of pypss imort</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def force_psse_halt(self):\n    \"\"\"forces cleaup of pypss imort\"\"\"\n    ierr = self.psse.pssehalt_2()\n    assert ierr == 0, f\"failed to halt PSSE. Error code - {ierr}\"\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.from_setting_files","title":"<code>from_setting_files(simulation_settiings_file, export_Settings_file=None)</code>  <code>classmethod</code>","text":"<p>build 'Simulator' from toml settings files</p> <p>Parameters:</p> Name Type Description Default <code>simulation_settiings_file</code> <code>Path</code> <p>simulation settings</p> required <code>export_Settings_file</code> <code>Path</code> <p>export settings</p> <code>None</code> Source code in <code>pypsse\\simulator.py</code> <pre><code>@classmethod\ndef from_setting_files(\n    cls, simulation_settiings_file: Path, export_Settings_file: Path = None\n):\n    \"\"\"build 'Simulator' from toml settings files\n\n    Args:\n        simulation_settiings_file (Path): simulation settings\n        export_Settings_file (Path): export settings\n    \"\"\"\n    simulation_settiings = toml.load(simulation_settiings_file)\n    if export_Settings_file:\n        export_Settings = toml.load(export_Settings_file)\n    else:\n        export_Settings = toml.load(\n            simulation_settiings_file.parent / EXPORTS_SETTINGS_FILENAME\n        )\n\n    simulation_settiings = SimulationSettings(**simulation_settiings)\n    export_Settings = ExportFileOptions(**export_Settings)\n    return cls(simulation_settiings, export_Settings)\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.get_bus_ids","title":"<code>get_bus_ids()</code>","text":"<p>Returns bus IDs</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>Array of bus numbers</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def get_bus_ids(self) -&gt; list:\n    \"\"\"Returns bus IDs\n\n    Returns:\n        list: Array of bus numbers\n    \"\"\"\n\n    ierr, iarray = self.psse.abusint(-1, 1, \"NUMBER\")\n    assert ierr == 0, f\"Error code: {ierr}\"\n    return iarray\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.get_bus_indices","title":"<code>get_bus_indices()</code>","text":"<p>Returns bus indices for bus subsystems</p> <p>Returns:</p> Name Type Description <code>BusSubsystems</code> <code>BusSubsystems</code> <p>Bus subsystem model</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def get_bus_indices(self) -&gt; BusSubsystems:\n    \"\"\"Returns bus indices for bus subsystems\n\n    Returns:\n        BusSubsystems: Bus subsystem model\n    \"\"\"\n\n    if self.settings.bus_subsystems.from_file:\n        bus_file = self.settings.bus_subsystems.bus_file\n        bus_info = pd.read_csv(bus_file, index_col=None)\n        bus_info = bus_info.values\n        _, n_cols = bus_info.shape\n        bus_data = []\n        for col in range(n_cols):\n            data = [int(x) for x in bus_info[:, col] if not np.isnan(x)]\n            bus_data.append(data)\n    else:\n        bus_data = self.settings.bus_subsystems.bus_subsystem_list\n    return bus_data\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.get_results","title":"<code>get_results(params)</code>","text":"<p>Returns queried simulation results</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Union[ExportAssetTypes, dict]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>simulation results</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def get_results(self, params: Union[ExportAssetTypes, dict]) -&gt; dict:\n    \"\"\"Returns queried simulation results\n\n    Args:\n        params (Union[ExportAssetTypes, dict]): _description_\n\n    Returns:\n        dict: simulation results\n    \"\"\"\n\n    self._status = SimulationStatus.STARTING_RESULT_EXPORT\n    self.exp_vars = self.results.update_export_variables(params)\n    curr_results = (\n        self.sim.read_subsystems(self.exp_vars, self.all_subsysten_buses)\n        if self.export_settings.defined_subsystems_only\n        else self.sim.read_subsystems(self.exp_vars, self.raw_data.buses)\n    )\n    self._status = SimulationStatus.RESULT_EXPORT_COMPLETE\n    return curr_results\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.init","title":"<code>init()</code>","text":"<p>Initializes the model</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def init(self):\n    \"\"\"Initializes the model\"\"\"\n\n    self.sim.init(self.bus_subsystems)\n\n    if self.settings.simulation.use_profile_manager:\n        self.pm = ProfileManager(self.sim, self.settings)\n        self.pm.setup_profiles()\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        self.hi.enter_execution_mode()\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.inject_contingencies_external","title":"<code>inject_contingencies_external(contigencies)</code>","text":"<p>Inject external contingencies.</p> <p>Parameters:</p> Name Type Description Default <code>contigencies</code> <code>Contingencies</code> <p>Contigencies Object</p> required Source code in <code>pypsse\\simulator.py</code> <pre><code>def inject_contingencies_external(self, contigencies: Contingencies):\n    \"\"\"Inject external contingencies.\n\n    Args:\n        contigencies (Contingencies): Contigencies Object\n    \"\"\"\n    contingencies = c.build_contingencies(self.psse, contigencies)\n    self.contingencies.extend(contingencies)\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.parse_gic_file","title":"<code>parse_gic_file()</code>","text":"<p>Parses the GIC file (if included in the project)</p> <p>Returns:</p> Name Type Description <code>Graph</code> <code>Graph</code> <p>Networkx graph representation for the model</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def parse_gic_file(self) -&gt; Graph:\n    \"\"\"Parses the GIC file (if included in the project)\n\n    Returns:\n        Graph: Networkx graph representation for the model\n    \"\"\"\n\n    gicdata = gp.GICParser(self.settings)\n    return gicdata.psse_graph\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.publish_data","title":"<code>publish_data()</code>","text":"<p>Updates publications (co-simulation mode only)</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def publish_data(self):\n    \"\"\"Updates publications (co-simulation mode only)\"\"\"\n\n    self.hi.publish()\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.run","title":"<code>run()</code>","text":"<p>Launches the simulation</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def run(self):\n    \"\"\"Launches the simulation\"\"\"\n\n    self._status = SimulationStatus.RUNNING_SIMULATION\n    if self.sim.initialization_complete:\n        if self.settings.plots and self.settings.plots.enable_dynamic_plots:\n            bokeh_server_proc = subprocess.Popen(\n                [\"bokeh\", \"serve\"], stdout=subprocess.PIPE\n            )  # noqa: S603,S607\n        else:\n            bokeh_server_proc = None\n\n        logger.debug(\n            f\"Running dynamic simulation for time {self.settings.simulation.simulation_time.total_seconds()} sec\"\n        )\n        total_simulation_time = (\n            self.settings.simulation.simulation_time.total_seconds()\n        )\n        t = 0\n        while True:\n            self.step(t)\n            if self.inc_time:\n                t += (\n                    self.settings.simulation.simulation_step_resolution.total_seconds()\n                )\n            if t &gt;= total_simulation_time:\n                break\n\n        self.psse.pssehalt_2()\n        if not self.export_settings.export_results_using_channels:\n            self.results.export_results()\n        else:\n            self.sim.export()\n\n        if bokeh_server_proc is not None:\n            bokeh_server_proc.terminate()\n    else:\n        logger.error(\n            \"Run init() command to initialize models before running the simulation\"\n        )\n    self._status = \"Simulation complete\"\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.start_simulation","title":"<code>start_simulation()</code>","text":"<p>Starts a loaded simulation</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Please pass a RAW or SAV file in the settings dictionary</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def start_simulation(self):\n    \"\"\"Starts a loaded simulation\n\n    Raises:\n        Exception: Please pass a RAW or SAV file in the settings dictionary\n    \"\"\"\n\n    self.hi = None\n    self.simStartTime = time.time()\n\n    if self.settings.simulation.case_study.exists():\n        self.psse.case(str(self.settings.simulation.case_study))\n    elif self.settings.simulation.raw_file.exists():\n        self.psse.read(0, str(self.settings.simulation.raw_file))\n    else:\n        msg = \"Please pass a RAW or SAV file in the settings dictionary\"\n        raise Exception(msg)\n\n    logger.info(\n        f\"Trying to read a file &gt;&gt;{self.settings.simulation.case_study}\"\n    )\n    self.raw_data = rd.Reader(self.psse)\n    (\n        self.bus_subsystems,\n        self.all_subsysten_buses,\n    ) = self.define_bus_subsystems()\n\n    if self.export_settings.defined_subsystems_only:\n        valid_buses = self.all_subsysten_buses\n    else:\n        valid_buses = self.raw_data.buses\n\n    self.sim = sc.sim_controller(\n        self.psse,\n        self.dyntools,\n        self.settings,\n        self.export_settings,\n        valid_buses,\n        self.raw_data,\n    )\n\n    self.contingencies = self.build_contingencies()\n\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        if self.settings.simulation.simulation_mode in [\n            SimulationModes.DYNAMIC,\n            SimulationModes.SNAP,\n        ]:\n            ...\n        self.hi = HelicsInterface(\n            self.psse,\n            self.sim,\n            self.settings,\n            self.export_settings,\n            self.bus_subsystems,\n        )\n        self.publications = self.hi.register_publications(\n            self.bus_subsystems\n        )\n        if self.settings.helics.create_subscriptions:\n            self.subscriptions = self.hi.register_subscriptions()\n\n    if self.settings.simulation.gic_file:\n        self.network_graph = self.parse_gic_file()\n        self.bus_ids = self.network_graph.nodes.keys()\n    else:\n        self.network_graph = None\n\n    self.results = Container(self.settings, self.export_settings)\n    self.exp_vars = self.results.get_export_variables()\n    self.inc_time = True\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.status","title":"<code>status()</code>","text":"<p>returns current simulation status</p> <p>Returns:</p> Name Type Description <code>SimulationStatus</code> <code>SimulationStatus</code> <p>state of the simulator</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def status(self) -&gt; SimulationStatus:\n    \"\"\"returns current simulation status\n\n    Returns:\n        SimulationStatus: state of the simulator\n    \"\"\"\n    return self._status.value\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.step","title":"<code>step(t)</code>","text":"<p>Steps through a single simulation time step. Is called iteratively to increment the simualtion</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>time step for the simulation</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>results from the current timestep</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def step(self, t: float) -&gt; dict:\n    \"\"\"Steps through a single simulation time step. Is called iteratively to increment the simualtion\n\n    Args:\n        t (float): time step for the simulation\n\n    Returns:\n        dict: results from the current timestep\n    \"\"\"\n\n    self.update_contingencies(t)\n    if self.settings.simulation.use_profile_manager:\n        self.pm.update()\n    ctime = time.time() - self.simStartTime\n    logger.debug(\n        f\"Simulation time: {t} seconds\\nRun time: {ctime}\\npsse time: {self.sim.get_time()}\"\n    )\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        if self.settings.helics.create_subscriptions:\n            self.update_subscriptions()\n            logger.debug(f\"Time requested: {t}\")\n            self.inc_time, helics_time = self.update_federate_time(t)\n            logger.debug(f\"Time granted: {helics_time}\")\n\n    if self.inc_time:\n        self.sim.step(t)\n    else:\n        self.sim.resolve_step()\n\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        self.publish_data()\n\n    curr_results = self.update_result_container(t)\n    return curr_results\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.update_contingencies","title":"<code>update_contingencies(t)</code>","text":"<p>Updates contingencies during the simualtion run</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>simulation time in seconds</p> required Source code in <code>pypsse\\simulator.py</code> <pre><code>def update_contingencies(self, t: float):\n    \"\"\"Updates contingencies during the simualtion run\n\n    Args:\n        t (float): simulation time in seconds\n    \"\"\"\n\n    for contingency in self.contingencies:\n        contingency.update(t)\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.update_federate_time","title":"<code>update_federate_time(t)</code>","text":"<p>Makes a time request to teh HELICS broker (co-simulation mode only)</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>simulation time in seconds</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>(float, float)</code> <p>requested time in seconds</p> <code>float</code> <code>(float, float)</code> <p>current simualtion time in seconds</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def update_federate_time(self, t: float) -&gt; (float, float):\n    \"\"\"Makes a time request to teh HELICS broker (co-simulation mode only)\n\n    Args:\n        t (float): simulation time in seconds\n\n    Returns:\n        float: requested time in seconds\n        float: current simualtion time in seconds\n    \"\"\"\n\n    inc_time, curr_time = self.hi.request_time(t)\n    return inc_time, curr_time\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.update_result_container","title":"<code>update_result_container(t)</code>","text":"<p>Updates the result container with results from the current time step</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>simulation time in seconds</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>simulation reults from the current time step</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def update_result_container(self, t: float) -&gt; dict:\n    \"\"\"Updates the result container with results from the current time step\n\n    Args:\n        t (float): simulation time in seconds\n\n    Returns:\n        dict: simulation reults from the current time step\n    \"\"\"\n\n    if self.export_settings.defined_subsystems_only:\n        curr_results = self.sim.read_subsystems(\n            self.exp_vars, self.all_subsysten_buses\n        )\n    else:\n        curr_results = self.sim.read_subsystems(\n            self.exp_vars, self.raw_data.buses\n        )\n\n    if not USING_NAERM:\n        if not self.export_settings.export_results_using_channels:\n            self.results.update(\n                curr_results,\n                t,\n                self.sim.get_time(),\n                self.sim.has_converged(),\n            )\n    return curr_results\n</code></pre>"},{"location":"code/reference/#pypsse.simulator.Simulator.update_subscriptions","title":"<code>update_subscriptions()</code>","text":"<p>Updates subscriptions (co-simulation mode only)</p> Source code in <code>pypsse\\simulator.py</code> <pre><code>def update_subscriptions(self):\n    \"\"\"Updates subscriptions (co-simulation mode only)\"\"\"\n\n    self.hi.subscribe()\n</code></pre>"},{"location":"code/reference/#pypsse.project.Project.create","title":"<code>create(parent_path, project_name, psse_folder, simulation_settings_file, export_settings_file, profile_store_file, profile_mapping_file, overwrite=True, autofill=True)</code>","text":"<p>The methods creates a new PyPSSE project</p> <p>Parameters:</p> Name Type Description Default <code>parent_path</code> <code>Path</code> <p>path to new pypsse project</p> required <code>project_name</code> <code>str</code> <p>project name</p> required <code>psse_folder</code> <code>Path</code> <p>description</p> required <code>simulation_settings_file</code> <code>Path</code> <p>simulation settings toml file path</p> required <code>export_settings_file</code> <code>Path</code> <p>export settings toml file path</p> required <code>profile_store_file</code> <code>Path</code> <p>path to a valid Profiles.hdf5 file (Contains profiles for time series simulations)</p> required <code>profile_mapping_file</code> <code>Path</code> <p>path to a valid Profile_mapping.toml file (used to map profile to PSSE elements)</p> required <code>overwrite</code> <code>bool</code> <p>Attempt to auto fill settings. (Verify manually settings file is correct). Defaults to True.</p> <code>True</code> <code>autofill</code> <code>bool</code> <p>Overwrite project is it already exists. Defaults to True.</p> <code>True</code> Source code in <code>pypsse\\project.py</code> <pre><code>def create(\n    self,\n    parent_path: Path,\n    project_name: str,\n    psse_folder: Path,\n    simulation_settings_file: Path,\n    export_settings_file: Path,\n    profile_store_file: Path,\n    profile_mapping_file: Path,\n    overwrite: bool = True,\n    autofill: bool = True,\n):\n    \"\"\"The methods creates a new PyPSSE project\n\n    Args:\n        parent_path (Path): path to new pypsse project\n        project_name (str): project name\n        psse_folder (Path): _description_\n        simulation_settings_file (Path): simulation settings toml file path\n        export_settings_file (Path): export settings toml file path\n        profile_store_file (Path): path to a valid Profiles.hdf5 file (Contains profiles for time series simulations)\n        profile_mapping_file (Path): path to a valid Profile_mapping.toml file (used to map profile to PSSE elements)\n        overwrite (bool, optional): Attempt to auto fill settings. (Verify manually settings file is correct). Defaults to True.\n        autofill (bool, optional): Overwrite project is it already exists. Defaults to True.\n    \"\"\"\n\n    self.project_path = Path(parent_path) / project_name\n\n    exports_dict = toml.load(self.basepath / DEFAULTS_FOLDER / EXPORTS_SETTINGS_FILENAME)\n    export_settings = ExportFileOptions(**exports_dict)\n\n    if export_settings_file:\n        export_settings_file = Path(export_settings_file)\n        assert export_settings_file.exists(), f\"Export file '{export_settings_file}' does not exist\"\n        new_export_settings = toml.load(export_settings_file)\n        export_settings.update(**new_export_settings)\n\n    sim_setting_dict = toml.load(self.basepath / DEFAULTS_FOLDER / SIMULATION_SETTINGS_FILENAME)\n    sim_setting_dict[\"simulation\"][\"project_path\"] = str(self.project_path)\n    simulation_settings = SimulationSettings(**sim_setting_dict)\n\n    if simulation_settings_file:\n        simulation_settings_file = Path(simulation_settings_file)\n        assert simulation_settings_file.exists(), f\"Export file '{simulation_settings_file}' does not exist\"\n        sim_setting_dict = toml.load(simulation_settings_file)\n        simulation_settings.update(**sim_setting_dict)\n\n    simulation_settings.simulation.project_path = Path(parent_path) / project_name\n\n    self.project = ProjectDefination(\n        project_name=project_name,\n        simulation_settings=simulation_settings,\n        export_settings=export_settings,\n        overwrite=overwrite,\n        autofill=autofill,\n    )\n\n    self._create_folders()\n\n    if psse_folder:\n        psse_files = self._copy_psse_project_files(psse_folder)\n        if autofill and psse_files:\n            self._autofill_settings(psse_files, profile_store_file, profile_mapping_file)\n\n    self._update_export_files()\n    self._write_setting_files()\n</code></pre>"},{"location":"code/reference/#pypsse.result_container.Container.__init__","title":"<code>__init__(settings, export_settings)</code>","text":"<p>Sets up the result container object</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>SimulationSettings</code> <p>description</p> required <code>export_settings</code> <code>ExportAssetTypes</code> <p>description</p> required Source code in <code>pypsse\\result_container.py</code> <pre><code>def __init__(self, settings: SimulationSettings, export_settings: ExportFileOptions):\n    \"\"\"Sets up the result container object\n\n    Args:\n        settings (SimulationSettings): _description_\n        export_settings (ExportAssetTypes): _description_\n    \"\"\"\n\n    export__list = [m.value for m in ModelTypes]\n    self.export_path = settings.simulation.project_path / EXPORTS_FOLDER\n    self.export_settings = export_settings\n    self.settings = settings\n    self.results = {}\n    self.export_vars = {}\n    for class_name in export__list:\n        mapped_name = MAPPED_CLASS_NAMES[class_name.lower()]\n        variables = getattr(export_settings, class_name.lower())\n        if variables:\n            for variable in variables:\n                self.results[f\"{mapped_name}_{variable.value}\"] = None\n                if mapped_name not in self.export_vars:\n                    self.export_vars[mapped_name] = []\n                self.export_vars[mapped_name].append(variable.value)\n\n    time_steps = int(\n        self.settings.simulation.simulation_time.total_seconds()\n        / self.settings.simulation.simulation_step_resolution.total_seconds()\n    )\n    if self.export_settings.file_format not in self.BULK_WRITE_MODES:\n        self.dataWriter = DataWriter(self.export_path, export_settings.file_format.value, time_steps,  self.export_settings.filename_prefix)\n</code></pre>"},{"location":"code/reference/#pypsse.result_container.Container.export_results","title":"<code>export_results()</code>","text":"<p>exports all results stored to an external file</p> Source code in <code>pypsse\\result_container.py</code> <pre><code>def export_results(self):\n    \"\"\"exports all results stored to an external file\"\"\"\n\n    if self.export_settings.file_format in self.BULK_WRITE_MODES:\n        for df_name, df in self.results.items():\n            export_path = (\n                self.settings.simulation.project_path\n                / EXPORTS_FOLDER\n                / f'{df_name}.{self.export_settings.file_format}'\n            )\n            if self.export_settings.file_format == BulkWriteModes.CSV:\n                if isinstance(df, pd.DataFrame):\n                    df.to_csv(export_path)\n            elif self.export_settings.file_format == BulkWriteModes.PKL:\n                df.to_pickle(export_path)\n            logger.info(f\"results exported to {export_path}\")\n</code></pre>"},{"location":"code/reference/#pypsse.result_container.Container.get_export_variables","title":"<code>get_export_variables()</code>","text":"<p>Queries and return results from the current timestep</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>mapping of export variables to values</p> Source code in <code>pypsse\\result_container.py</code> <pre><code>def get_export_variables(self) -&gt; dict:\n    \"\"\"Queries and return results from the current timestep\n\n    Returns:\n        dict: mapping of export variables to values\n    \"\"\"\n\n    return self.export_vars\n</code></pre>"},{"location":"code/reference/#pypsse.result_container.Container.update","title":"<code>update(bus_data, _, time, has_converged)</code>","text":"<p>Updates the results cotainer</p> <p>Parameters:</p> Name Type Description Default <code>bus_data</code> <code>dict</code> <p>mapping of vairables to values</p> required <code>_</code> <code>_type_</code> <p>description</p> required <code>time</code> <code>datetime</code> <p>simulation time</p> required <code>has_converged</code> <code>bool</code> <p>flag showing if simulation converged</p> required Source code in <code>pypsse\\result_container.py</code> <pre><code>def update(self, bus_data: dict, _, time: datetime.datetime, has_converged: bool):\n    \"\"\"Updates the results cotainer\n\n    Args:\n        bus_data (dict): mapping of vairables to values\n        _ (_type_): _description_\n        time (datetime.datetime): simulation time\n        has_converged (bool): flag showing if simulation converged\n    \"\"\"\n\n    if self.export_settings.file_format not in self.BULK_WRITE_MODES:\n        self.dataWriter.write(time, bus_data, has_converged)\n    else:\n        for variable_name, _ in bus_data.items():\n            if not isinstance(self.results[f\"{variable_name}\"], pd.DataFrame):\n                self.results[f\"{variable_name}\"] = pd.DataFrame(bus_data[variable_name], index=[0])\n            else:\n                df1 = self.results[f\"{variable_name}\"]\n                df2 = pd.DataFrame.from_dict([bus_data[variable_name]])\n                concatenated = pd.concat([df1, df2])\n                self.results[f\"{variable_name}\"] = concatenated\n    logger.debug(\"result container updated\")\n</code></pre>"},{"location":"code/reference/#pypsse.result_container.Container.update_export_variables","title":"<code>update_export_variables(params)</code>","text":"<p>Updates the container with current system state. Method is called iteratively to store results as a simulation executes</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Union[ExportAssetTypes, dict]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>mapping of export variables to values</p> Source code in <code>pypsse\\result_container.py</code> <pre><code>def update_export_variables(self, params: Union[ExportAssetTypes, dict]) -&gt; dict:\n    \"\"\"Updates the container with current system state.\n    Method is called iteratively to store results as a simulation executes\n\n    Args:\n        params (Union[ExportAssetTypes, dict]): _description_\n\n    Returns:\n        dict: mapping of export variables to values\n    \"\"\"\n    export__list = [m.value for m in ModelTypes]\n    self.results = {}\n    self.export_vars = {}\n    if params:\n        if isinstance(params, ExportAssetTypes):\n            class_assets = params\n        else:\n            class_assets = ExportAssetTypes(**params)\n    else:\n        class_assets = self.export_settings\n\n    inv_map = {v: k for k, v in MAPPED_CLASS_NAMES.items()}\n\n    for class_name in export__list:\n        if inv_map[class_name] in params:\n            variables = getattr(class_assets, inv_map[class_name])\n            if variables:\n                for variable in variables:\n                    self.results[f\"{class_name}_{variable.value}\"] = None\n                    if class_name not in self.export_vars:\n                        self.export_vars[class_name] = []\n                    self.export_vars[class_name].append(variable.value)\n\n    return self.export_vars\n</code></pre>"},{"location":"code/reference/#profile-management","title":"Profile management","text":""},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager","title":"<code>ProfileManager</code>","text":"<p>Implentation for the profile manager for PyPSSE. Enables attacheing profilse to all PSSE objects and associated properties</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>class ProfileManager:\n    \"\"\"Implentation for the profile manager for PyPSSE.\n    Enables attacheing profilse to all PSSE objects and associated properties\"\"\"\n\n    def __init__(\n        self, solver: Union[ProductionCostModel, Snap, Static, Dynamic], settings: SimulationSettings, mode: str = \"r+\"\n    ):\n        \"\"\"Creates an instance of the profile manager\n\n        Args:\n            solver (Union[ProductionCostModel, Snap, Static, Dynamic]): instance of simulation controller\n            settings (SimulationSettings): simulation settings\n            mode (str, optional): file update mode. Defaults to \"r+\".\n        \"\"\"\n\n        self.solver = solver\n        self.settings = settings\n\n        file_path = settings.simulation.project_path / PROFILES_FOLDER / DEFAULT_PROFILE_STORE_FILENAME\n\n        if file_path.exists():\n            logger.info(\"Loading existing h5 store\")\n            self.store = h5py.File(file_path, mode)\n        else:\n            logger.info(\"Creating new h5 store\")\n            self.store = h5py.File(file_path, \"w\")\n            for profile_group in [p.value for p in ProfileTypes]:\n                self.store.create_group(profile_group)\n\n    def load_data(self, file_path: Path) -&gt; dict:\n        \"\"\"Load in external profile data\n\n        Args:\n            file_path (Path): path to profile mapping file\n\n        Returns:\n            dict: profile mapping dictionary\n        \"\"\"\n\n        toml_dict = toml.load(file_path)\n        return toml_dict\n\n    def setup_profiles(self):\n        \"\"\"sets up all profiles in the profile manager\n\n        Raises:\n            Exception: raised if mapped object not found in profile DB\n        \"\"\"\n\n        mapping_path = self.settings.simulation.project_path / PROFILES_FOLDER / DEFAULT_PROFILE_MAPPING_FILENAME\n        if mapping_path.exists():\n            self.profile_mapping = self.load_data(mapping_path)\n            self.profiles = {}\n            for group, profile_map in self.profile_mapping.items():\n                if group in self.store:\n                    grp = self.store[group]\n                    for profile_name, mapping_dict in profile_map.items():\n                        if profile_name in grp:\n                            self.profiles[f\"{group}/{profile_name}\"] = Profile(\n                                grp[profile_name], self.solver, mapping_dict\n                            )\n                        else:\n                            logger.warning(rf\"Group {group} \\ data set {profile_name} not found in the h5 store\")\n                else:\n                    logger.warning(f\"Group {group} not found in the h5 store\")\n        else:\n            msg = f\"Profile_mapping.toml file does not exist in path {mapping_path}\"\n            raise Exception(msg)\n\n    def create_dataset(\n        self,\n        dname: str,\n        p_type: ProfileTypes,\n        data: pd.DataFrame,\n        start_time: datetime.datetime,\n        resolution: float,\n        units:str,\n        info: str,\n    ):\n        \"\"\"Create new profile datasets\n\n        Args:\n            dname (str): dateset name\n            p_type (ProfileTypes): profile type\n            data (pd.DataFrame): data\n            start_time (datetime.datetime): profile start time\n            resolution (float): profile resolution\n            _ (_type_): _description_\n            info (:str): profile description\n\n        Raises:\n            Exception: raised if dataset already exists\n        \"\"\"\n\n        grp = self.store[p_type]\n        if dname not in grp:\n            sa, sa_type = self.df_to_sarray(data)\n            dset = grp.create_dataset(\n                dname, data=sa, chunks=True, compression=\"gzip\", compression_opts=4, shuffle=True, dtype=sa_type\n            )\n            self.create_metadata(dset, start_time, resolution, data, list(data.columns), info, p_type)\n        else:\n            logger.error(f'Data set \"{dname}\" already exists in group \"{p_type}\".')\n            msg = f'Data set \"{dname}\" already exists in group \"{p_type}\".'\n            raise Exception(msg)\n\n    def df_to_sarray(self, df: pd.DataFrame) -&gt; [str, str]:\n        \"\"\"Enables data converson\n\n        Args:\n            df (pd.DataFrame): _description_\n\n        Raises:\n            SystemError: raised if unable to convert\n\n        Returns:\n            [str, str]: returns column name and datatype\n        \"\"\"\n\n        def make_col_type(col_type, col):\n            try:\n                if \"numpy.object_\" in str(col_type.type):\n                    maxlens = col.dropna().str.len()\n                    if maxlens.any():\n                        maxlen = maxlens.max().astype(int)\n                        col_type = (\"S%s\" % maxlen, 1)\n                    else:\n                        col_type = \"f2\"\n                return col.name, col_type\n            except:\n                raise SystemError(\"Unable to convert dataframe to np array\")\n\n        v = df.values\n        types = df.dtypes\n        numpy_struct_types = [make_col_type(types[col], df.loc[:, col]) for col in df.columns]\n        dtype = np.dtype(numpy_struct_types)\n        z = np.zeros(v.shape[0], dtype)\n        for i, k in enumerate(z.dtype.names):\n            # This is in case you have problems with the encoding, remove the if branch if not\n            try:\n                if dtype[i].str.startswith(\"|S\"):\n                    z[k] = df[k].str.encode(\"latin\").astype(\"S\")\n                else:\n                    z[k] = v[:, i]\n            except:\n                raise\n\n        return z, dtype\n\n    def add_profiles_from_csv(\n        self,\n        csv_file: Path,\n        name: str,\n        p_type: ProfileTypes,\n        start_time: datetime.date,\n        resolution_sec: float = 900,\n        units: str = \"\",\n        info: str = \"\",\n    ):\n        \"\"\"enables profiles from existing csv files\n\n        Args:\n            csv_file (Path): path to profiles in a csv file\n            name (str): profile name\n            p_type (ProfileTypes): profile type\n            start_time (datetime.date): profile start time\n            resolution_sec (float, optional): profile resolution in seconds. Defaults to 900.\n            units (str, optional): profile units. Defaults to \"\".\n            info (str, optional): profile into. Defaults to \"\".\n\n        Raises:\n            ValueError: rasied if invalid profile name passed\n            ValueError: rasied if invalid profile type passed\n        \"\"\"\n\n        if p_type not in ProfileTypes:\n            msg = f\"Valid profile types are: {list(PROFILE_VALIDATION.keys())}\"\n            raise ValueError(msg)\n        logger.debug(\"Reading profile\")\n        data = pd.read_csv(csv_file)\n\n        for c in data.columns:\n            if c not in PROFILE_VALIDATION[p_type]:\n                msg = f\"{c} is not valid, Valid subtypes for '{p_type}' are: {PROFILE_VALIDATION[p_type]}\"\n                raise ValueError(msg)\n\n        logger.debug(\"Attempting to add a profile\")\n        self.add_profiles(name, data, p_type, start_time, resolution_sec=resolution_sec, units=units, info=info)\n\n    def add_profiles(\n        self,\n        name: str,\n        data: object,\n        p_type: ProfileTypes,\n        start_time: datetime.date,\n        resolution_sec: float = 900,\n        units: str = \"\",\n        info: str = \"\",\n    ):\n        \"\"\"adds a profile to the profile manager\n\n        Args:\n            name (str): profile name\n            data (object): profile data object\n            p_type (ProfileTypes): profile type\n            start_time (datetime.date): profile start time\n            resolution_sec (float, optional): profile resolution in seconds. Defaults to 900.\n            units (str, optional): profile units. Defaults to \"\".\n            info (str, optional): profile into. Defaults to \"\".\n\n        Raises:\n            InvalidParameterError: raised if start_time not a datetime object\n            InvalidParameterError: raised if invalid profile type passed\n        \"\"\"\n\n        if type(start_time) is not datetime.datetime:\n            msg = \"start_time should be a python datetime object\"\n            raise InvalidParameterError(msg)\n\n        if p_type not in ProfileTypes:\n            msg = f\"Valid values for p_type are {ProfileTypes.names()}\"\n            raise InvalidParameterError(msg)\n        self.create_dataset(name, p_type, data, start_time, resolution_sec, units=units, info=info)\n\n    def create_metadata(\n        self,\n        d_set: str,\n        start_time: datetime.date,\n        resolution: float,\n        data: object,\n        units: str,\n        info: str,\n        p_type: ProfileTypes,\n    ):\n        \"\"\"adds a metadata to a new profile\n\n        Args:\n            d_set (str): dataset name\n            start_time (datetime.date): profile start time\n            resolution (float): profile resolution\n            data (object): profile data object\n            units (str): profile units\n            info (str): profile info\n            p_type (ProfileTypes): profile type\n        \"\"\"\n\n        metadata = {\n            \"sTime\": str(start_time),\n            \"eTime\": str(start_time + datetime.timedelta(seconds=resolution * len(data))),\n            \"resTime\": resolution,\n            \"npts\": len(data),\n            \"min\": data.min(),\n            \"max\": data.max(),\n            \"mean\": np.mean(data),\n            \"units\": units,\n            \"info\": info,\n            \"type\": p_type,\n        }\n        for key, value in metadata.items():\n            if isinstance(value, str):\n                value_mod = np.string_(value)\n            else:\n                value_mod = value\n            d_set.attrs[key] = value_mod\n\n    def update(self) -&gt; dict:\n        \"\"\"returns data for the current timestep for all mapped profiles\n\n        Returns:\n            dict: values for profiles at the current time step\n        \"\"\"\n\n        results = {}\n        for profile_name, profile_obj in self.profiles.items():\n            result = profile_obj.update()\n            results[profile_name] = result\n\n        return results\n\n    def __del__(self):\n        self.store.flush()\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.__init__","title":"<code>__init__(solver, settings, mode='r+')</code>","text":"<p>Creates an instance of the profile manager</p> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>Union[ProductionCostModel, Snap, Static, Dynamic]</code> <p>instance of simulation controller</p> required <code>settings</code> <code>SimulationSettings</code> <p>simulation settings</p> required <code>mode</code> <code>str</code> <p>file update mode. Defaults to \"r+\".</p> <code>'r+'</code> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def __init__(\n    self, solver: Union[ProductionCostModel, Snap, Static, Dynamic], settings: SimulationSettings, mode: str = \"r+\"\n):\n    \"\"\"Creates an instance of the profile manager\n\n    Args:\n        solver (Union[ProductionCostModel, Snap, Static, Dynamic]): instance of simulation controller\n        settings (SimulationSettings): simulation settings\n        mode (str, optional): file update mode. Defaults to \"r+\".\n    \"\"\"\n\n    self.solver = solver\n    self.settings = settings\n\n    file_path = settings.simulation.project_path / PROFILES_FOLDER / DEFAULT_PROFILE_STORE_FILENAME\n\n    if file_path.exists():\n        logger.info(\"Loading existing h5 store\")\n        self.store = h5py.File(file_path, mode)\n    else:\n        logger.info(\"Creating new h5 store\")\n        self.store = h5py.File(file_path, \"w\")\n        for profile_group in [p.value for p in ProfileTypes]:\n            self.store.create_group(profile_group)\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.add_profiles","title":"<code>add_profiles(name, data, p_type, start_time, resolution_sec=900, units='', info='')</code>","text":"<p>adds a profile to the profile manager</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>profile name</p> required <code>data</code> <code>object</code> <p>profile data object</p> required <code>p_type</code> <code>ProfileTypes</code> <p>profile type</p> required <code>start_time</code> <code>date</code> <p>profile start time</p> required <code>resolution_sec</code> <code>float</code> <p>profile resolution in seconds. Defaults to 900.</p> <code>900</code> <code>units</code> <code>str</code> <p>profile units. Defaults to \"\".</p> <code>''</code> <code>info</code> <code>str</code> <p>profile into. Defaults to \"\".</p> <code>''</code> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>raised if start_time not a datetime object</p> <code>InvalidParameterError</code> <p>raised if invalid profile type passed</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def add_profiles(\n    self,\n    name: str,\n    data: object,\n    p_type: ProfileTypes,\n    start_time: datetime.date,\n    resolution_sec: float = 900,\n    units: str = \"\",\n    info: str = \"\",\n):\n    \"\"\"adds a profile to the profile manager\n\n    Args:\n        name (str): profile name\n        data (object): profile data object\n        p_type (ProfileTypes): profile type\n        start_time (datetime.date): profile start time\n        resolution_sec (float, optional): profile resolution in seconds. Defaults to 900.\n        units (str, optional): profile units. Defaults to \"\".\n        info (str, optional): profile into. Defaults to \"\".\n\n    Raises:\n        InvalidParameterError: raised if start_time not a datetime object\n        InvalidParameterError: raised if invalid profile type passed\n    \"\"\"\n\n    if type(start_time) is not datetime.datetime:\n        msg = \"start_time should be a python datetime object\"\n        raise InvalidParameterError(msg)\n\n    if p_type not in ProfileTypes:\n        msg = f\"Valid values for p_type are {ProfileTypes.names()}\"\n        raise InvalidParameterError(msg)\n    self.create_dataset(name, p_type, data, start_time, resolution_sec, units=units, info=info)\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.add_profiles_from_csv","title":"<code>add_profiles_from_csv(csv_file, name, p_type, start_time, resolution_sec=900, units='', info='')</code>","text":"<p>enables profiles from existing csv files</p> <p>Parameters:</p> Name Type Description Default <code>csv_file</code> <code>Path</code> <p>path to profiles in a csv file</p> required <code>name</code> <code>str</code> <p>profile name</p> required <code>p_type</code> <code>ProfileTypes</code> <p>profile type</p> required <code>start_time</code> <code>date</code> <p>profile start time</p> required <code>resolution_sec</code> <code>float</code> <p>profile resolution in seconds. Defaults to 900.</p> <code>900</code> <code>units</code> <code>str</code> <p>profile units. Defaults to \"\".</p> <code>''</code> <code>info</code> <code>str</code> <p>profile into. Defaults to \"\".</p> <code>''</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>rasied if invalid profile name passed</p> <code>ValueError</code> <p>rasied if invalid profile type passed</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def add_profiles_from_csv(\n    self,\n    csv_file: Path,\n    name: str,\n    p_type: ProfileTypes,\n    start_time: datetime.date,\n    resolution_sec: float = 900,\n    units: str = \"\",\n    info: str = \"\",\n):\n    \"\"\"enables profiles from existing csv files\n\n    Args:\n        csv_file (Path): path to profiles in a csv file\n        name (str): profile name\n        p_type (ProfileTypes): profile type\n        start_time (datetime.date): profile start time\n        resolution_sec (float, optional): profile resolution in seconds. Defaults to 900.\n        units (str, optional): profile units. Defaults to \"\".\n        info (str, optional): profile into. Defaults to \"\".\n\n    Raises:\n        ValueError: rasied if invalid profile name passed\n        ValueError: rasied if invalid profile type passed\n    \"\"\"\n\n    if p_type not in ProfileTypes:\n        msg = f\"Valid profile types are: {list(PROFILE_VALIDATION.keys())}\"\n        raise ValueError(msg)\n    logger.debug(\"Reading profile\")\n    data = pd.read_csv(csv_file)\n\n    for c in data.columns:\n        if c not in PROFILE_VALIDATION[p_type]:\n            msg = f\"{c} is not valid, Valid subtypes for '{p_type}' are: {PROFILE_VALIDATION[p_type]}\"\n            raise ValueError(msg)\n\n    logger.debug(\"Attempting to add a profile\")\n    self.add_profiles(name, data, p_type, start_time, resolution_sec=resolution_sec, units=units, info=info)\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.create_dataset","title":"<code>create_dataset(dname, p_type, data, start_time, resolution, units, info)</code>","text":"<p>Create new profile datasets</p> <p>Parameters:</p> Name Type Description Default <code>dname</code> <code>str</code> <p>dateset name</p> required <code>p_type</code> <code>ProfileTypes</code> <p>profile type</p> required <code>data</code> <code>DataFrame</code> <p>data</p> required <code>start_time</code> <code>datetime</code> <p>profile start time</p> required <code>resolution</code> <code>float</code> <p>profile resolution</p> required <code>_</code> <code>_type_</code> <p>description</p> required <code>info</code> <p>str): profile description</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>raised if dataset already exists</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def create_dataset(\n    self,\n    dname: str,\n    p_type: ProfileTypes,\n    data: pd.DataFrame,\n    start_time: datetime.datetime,\n    resolution: float,\n    units:str,\n    info: str,\n):\n    \"\"\"Create new profile datasets\n\n    Args:\n        dname (str): dateset name\n        p_type (ProfileTypes): profile type\n        data (pd.DataFrame): data\n        start_time (datetime.datetime): profile start time\n        resolution (float): profile resolution\n        _ (_type_): _description_\n        info (:str): profile description\n\n    Raises:\n        Exception: raised if dataset already exists\n    \"\"\"\n\n    grp = self.store[p_type]\n    if dname not in grp:\n        sa, sa_type = self.df_to_sarray(data)\n        dset = grp.create_dataset(\n            dname, data=sa, chunks=True, compression=\"gzip\", compression_opts=4, shuffle=True, dtype=sa_type\n        )\n        self.create_metadata(dset, start_time, resolution, data, list(data.columns), info, p_type)\n    else:\n        logger.error(f'Data set \"{dname}\" already exists in group \"{p_type}\".')\n        msg = f'Data set \"{dname}\" already exists in group \"{p_type}\".'\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.create_metadata","title":"<code>create_metadata(d_set, start_time, resolution, data, units, info, p_type)</code>","text":"<p>adds a metadata to a new profile</p> <p>Parameters:</p> Name Type Description Default <code>d_set</code> <code>str</code> <p>dataset name</p> required <code>start_time</code> <code>date</code> <p>profile start time</p> required <code>resolution</code> <code>float</code> <p>profile resolution</p> required <code>data</code> <code>object</code> <p>profile data object</p> required <code>units</code> <code>str</code> <p>profile units</p> required <code>info</code> <code>str</code> <p>profile info</p> required <code>p_type</code> <code>ProfileTypes</code> <p>profile type</p> required Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def create_metadata(\n    self,\n    d_set: str,\n    start_time: datetime.date,\n    resolution: float,\n    data: object,\n    units: str,\n    info: str,\n    p_type: ProfileTypes,\n):\n    \"\"\"adds a metadata to a new profile\n\n    Args:\n        d_set (str): dataset name\n        start_time (datetime.date): profile start time\n        resolution (float): profile resolution\n        data (object): profile data object\n        units (str): profile units\n        info (str): profile info\n        p_type (ProfileTypes): profile type\n    \"\"\"\n\n    metadata = {\n        \"sTime\": str(start_time),\n        \"eTime\": str(start_time + datetime.timedelta(seconds=resolution * len(data))),\n        \"resTime\": resolution,\n        \"npts\": len(data),\n        \"min\": data.min(),\n        \"max\": data.max(),\n        \"mean\": np.mean(data),\n        \"units\": units,\n        \"info\": info,\n        \"type\": p_type,\n    }\n    for key, value in metadata.items():\n        if isinstance(value, str):\n            value_mod = np.string_(value)\n        else:\n            value_mod = value\n        d_set.attrs[key] = value_mod\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.df_to_sarray","title":"<code>df_to_sarray(df)</code>","text":"<p>Enables data converson</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>description</p> required <p>Raises:</p> Type Description <code>SystemError</code> <p>raised if unable to convert</p> <p>Returns:</p> Type Description <code>[str, str]</code> <p>[str, str]: returns column name and datatype</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def df_to_sarray(self, df: pd.DataFrame) -&gt; [str, str]:\n    \"\"\"Enables data converson\n\n    Args:\n        df (pd.DataFrame): _description_\n\n    Raises:\n        SystemError: raised if unable to convert\n\n    Returns:\n        [str, str]: returns column name and datatype\n    \"\"\"\n\n    def make_col_type(col_type, col):\n        try:\n            if \"numpy.object_\" in str(col_type.type):\n                maxlens = col.dropna().str.len()\n                if maxlens.any():\n                    maxlen = maxlens.max().astype(int)\n                    col_type = (\"S%s\" % maxlen, 1)\n                else:\n                    col_type = \"f2\"\n            return col.name, col_type\n        except:\n            raise SystemError(\"Unable to convert dataframe to np array\")\n\n    v = df.values\n    types = df.dtypes\n    numpy_struct_types = [make_col_type(types[col], df.loc[:, col]) for col in df.columns]\n    dtype = np.dtype(numpy_struct_types)\n    z = np.zeros(v.shape[0], dtype)\n    for i, k in enumerate(z.dtype.names):\n        # This is in case you have problems with the encoding, remove the if branch if not\n        try:\n            if dtype[i].str.startswith(\"|S\"):\n                z[k] = df[k].str.encode(\"latin\").astype(\"S\")\n            else:\n                z[k] = v[:, i]\n        except:\n            raise\n\n    return z, dtype\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.load_data","title":"<code>load_data(file_path)</code>","text":"<p>Load in external profile data</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>path to profile mapping file</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>profile mapping dictionary</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def load_data(self, file_path: Path) -&gt; dict:\n    \"\"\"Load in external profile data\n\n    Args:\n        file_path (Path): path to profile mapping file\n\n    Returns:\n        dict: profile mapping dictionary\n    \"\"\"\n\n    toml_dict = toml.load(file_path)\n    return toml_dict\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.setup_profiles","title":"<code>setup_profiles()</code>","text":"<p>sets up all profiles in the profile manager</p> <p>Raises:</p> Type Description <code>Exception</code> <p>raised if mapped object not found in profile DB</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def setup_profiles(self):\n    \"\"\"sets up all profiles in the profile manager\n\n    Raises:\n        Exception: raised if mapped object not found in profile DB\n    \"\"\"\n\n    mapping_path = self.settings.simulation.project_path / PROFILES_FOLDER / DEFAULT_PROFILE_MAPPING_FILENAME\n    if mapping_path.exists():\n        self.profile_mapping = self.load_data(mapping_path)\n        self.profiles = {}\n        for group, profile_map in self.profile_mapping.items():\n            if group in self.store:\n                grp = self.store[group]\n                for profile_name, mapping_dict in profile_map.items():\n                    if profile_name in grp:\n                        self.profiles[f\"{group}/{profile_name}\"] = Profile(\n                            grp[profile_name], self.solver, mapping_dict\n                        )\n                    else:\n                        logger.warning(rf\"Group {group} \\ data set {profile_name} not found in the h5 store\")\n            else:\n                logger.warning(f\"Group {group} not found in the h5 store\")\n    else:\n        msg = f\"Profile_mapping.toml file does not exist in path {mapping_path}\"\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile_store.ProfileManager.update","title":"<code>update()</code>","text":"<p>returns data for the current timestep for all mapped profiles</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>values for profiles at the current time step</p> Source code in <code>pypsse\\profile_manager\\profile_store.py</code> <pre><code>def update(self) -&gt; dict:\n    \"\"\"returns data for the current timestep for all mapped profiles\n\n    Returns:\n        dict: values for profiles at the current time step\n    \"\"\"\n\n    results = {}\n    for profile_name, profile_obj in self.profiles.items():\n        result = profile_obj.update()\n        results[profile_name] = result\n\n    return results\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile.Profile","title":"<code>Profile</code>","text":"<p>Class defination fora single profile</p> Source code in <code>pypsse\\profile_manager\\profile.py</code> <pre><code>class Profile:\n    \"Class defination fora single profile\"\n\n    DEFAULT_SETTINGS = {\"multiplier\": 1, \"normalize\": False, \"interpolate\": False}\n\n    def __init__(self, profile_obj, solver, mapping_dict, buffer_size=10, neglect_year=True):\n        self.value_settings = {f\"{x['bus']}__{x['id']}\": {**self.DEFAULT_SETTINGS, **x} for x in mapping_dict}\n        self.mapping_dict = mapping_dict\n        self.buffer_size = buffer_size\n        self.buffer = np.zeros(buffer_size)\n        self.profile = profile_obj\n        self.neglect_year = neglect_year\n        self.solver = solver\n        self.attrs = self.profile.attrs\n        s = self.attrs[\"sTime\"].decode()\n        stime = s if \".\" in s else s + \".00\"\n        e = self.attrs[\"eTime\"].decode()\n        etime = e if \".\" in e else e + \".00\"\n        self.stime = datetime.datetime.strptime(stime, \"%Y-%m-%d %H:%M:%S.%f\").astimezone(None)\n        self.etime = datetime.datetime.strptime(etime, \"%Y-%m-%d %H:%M:%S.%f\").astimezone(None)\n        self.sim_res = self.solver.get_step_size_cec()\n        self.time = copy.deepcopy(self.solver.get_time())\n        self.columns = self.attrs[\"units\"]\n        self.dtype = self.attrs[\"type\"].decode()\n\n    def update(self, update_object_properties=True):\n        \"Returns value at the current timestep in the given profile\"\n        self.time = copy.deepcopy(self.solver.get_time()).astimezone(None)\n        if self.time &lt; self.stime or self.time &gt; self.etime:\n            value = np.array([0] * len(self.profile[0]))\n            value1 = np.array([0] * len(self.profile[0]))\n        else:\n            dt = (self.time - self.stime).total_seconds()\n            n = int(dt / self.attrs[\"resTime\"])\n            value = np.array(list(self.profile[n]))\n            try:\n                valuen1 = np.array(list(self.profile[n + 1]))\n            except Exception as _:\n                valuen1 = value\n\n            dt2 = (\n                self.time - (self.stime + datetime.timedelta(seconds=int(n * self.attrs[\"resTime\"])))\n            ).total_seconds()\n            value1 = value + (valuen1 - value) * dt2 / self.attrs[\"resTime\"]\n\n        if update_object_properties:\n            for obj_name in self.value_settings:\n                bus, object_id = obj_name.split(\"__\")\n                if self.value_settings[obj_name][\"interpolate\"]:\n                    value = value1\n                mult = self.value_settings[obj_name][\"multiplier\"]\n                if isinstance(mult, list):\n                    mult = np.array(mult)\n                if self.value_settings[obj_name][\"normalize\"]:\n                    value_f = value / self.attrs[\"max\"] * mult\n                else:\n                    value_f = value * mult\n                value_f = self.fill_missing_values(value_f)\n                self.solver.update_object(self.dtype, bus, object_id, value_f)\n                logger.debug(f\"Object updated: {object_id}.{bus}.{self.dtype}={value_f}\")\n        return value\n\n    def fill_missing_values(self, value):\n        \"Fixes issues in profile data\"\n        idx = [f\"realar{PROFILE_VALIDATION[self.dtype].index(c) + 1}\" for c in self.columns]\n        x = dict(zip(idx, list(value)))\n        return x\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile.Profile.fill_missing_values","title":"<code>fill_missing_values(value)</code>","text":"<p>Fixes issues in profile data</p> Source code in <code>pypsse\\profile_manager\\profile.py</code> <pre><code>def fill_missing_values(self, value):\n    \"Fixes issues in profile data\"\n    idx = [f\"realar{PROFILE_VALIDATION[self.dtype].index(c) + 1}\" for c in self.columns]\n    x = dict(zip(idx, list(value)))\n    return x\n</code></pre>"},{"location":"code/reference/#pypsse.profile_manager.profile.Profile.update","title":"<code>update(update_object_properties=True)</code>","text":"<p>Returns value at the current timestep in the given profile</p> Source code in <code>pypsse\\profile_manager\\profile.py</code> <pre><code>def update(self, update_object_properties=True):\n    \"Returns value at the current timestep in the given profile\"\n    self.time = copy.deepcopy(self.solver.get_time()).astimezone(None)\n    if self.time &lt; self.stime or self.time &gt; self.etime:\n        value = np.array([0] * len(self.profile[0]))\n        value1 = np.array([0] * len(self.profile[0]))\n    else:\n        dt = (self.time - self.stime).total_seconds()\n        n = int(dt / self.attrs[\"resTime\"])\n        value = np.array(list(self.profile[n]))\n        try:\n            valuen1 = np.array(list(self.profile[n + 1]))\n        except Exception as _:\n            valuen1 = value\n\n        dt2 = (\n            self.time - (self.stime + datetime.timedelta(seconds=int(n * self.attrs[\"resTime\"])))\n        ).total_seconds()\n        value1 = value + (valuen1 - value) * dt2 / self.attrs[\"resTime\"]\n\n    if update_object_properties:\n        for obj_name in self.value_settings:\n            bus, object_id = obj_name.split(\"__\")\n            if self.value_settings[obj_name][\"interpolate\"]:\n                value = value1\n            mult = self.value_settings[obj_name][\"multiplier\"]\n            if isinstance(mult, list):\n                mult = np.array(mult)\n            if self.value_settings[obj_name][\"normalize\"]:\n                value_f = value / self.attrs[\"max\"] * mult\n            else:\n                value_f = value * mult\n            value_f = self.fill_missing_values(value_f)\n            self.solver.update_object(self.dtype, bus, object_id, value_f)\n            logger.debug(f\"Object updated: {object_id}.{bus}.{self.dtype}={value_f}\")\n    return value\n</code></pre>"},{"location":"code/reference/#simulation-modes","title":"Simulation modes","text":""},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic","title":"<code>Dynamic</code>","text":"<p>             Bases: <code>AbstractMode</code>, <code>DynamicUtils</code></p> <p>Class defination for dynamic simulation mode (uses dyr and raw files)</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>class Dynamic(AbstractMode, DynamicUtils):\n    \"Class defination for dynamic simulation mode (uses dyr and raw files)\"\n\n    def __init__(\n        self,\n        psse,\n        dyntools,\n        settings: SimulationSettings,\n        export_settings: ExportFileOptions,\n        subsystem_buses,\n        raw_data,\n    ):\n        super().__init__(psse, dyntools, settings, export_settings, subsystem_buses, raw_data)\n        self.time = settings.simulation.start_time\n        self._StartTime = settings.simulation.start_time\n        self.incTime = settings.simulation.simulation_step_resolution\n        self.init(subsystem_buses)\n\n    def init(self, bus_subsystems):\n        \"Initializes the simulation\"\n        super().init(bus_subsystems)\n        self.iter_const = 100.0\n\n        if self.settings.simulation.rwm_file:\n            self.psse.mcre([1, 0], self.rwn_file)\n\n        self.psse.fnsl([0, 0, 0, 1, 0, 0, 0, self._i])\n\n        self.load_setup_files()\n        self.convert_load()\n\n        self.psse.gnet(1, 0)\n        self.psse.fdns([1, 1, 0, 1, 1, 0, 0, 0])\n        self.psse.fnsl([1, 1, 0, 1, 1, 0, 0, 0])\n        self.psse.cong(0)\n        # Solve for dynamics\n        self.psse.ordr(0)\n        self.psse.fact()\n        self.psse.tysl(0)\n        self.psse.tysl(0)\n        # self.psse.save(self.study_case_path.split('.')[0] + \".sav\")\n        dyr_path = self.settings.simulation.dyr_file\n        assert dyr_path and dyr_path.exists\n        logger.debug(f\"Loading dynamic model....{dyr_path}\")\n        self.psse.dynamicsmode(1)\n        ierr = self.psse.dyre_new([1, 1, 1, 1], str(dyr_path), r\"\"\"conec\"\"\", r\"\"\"conet\"\"\", r\"\"\"compile\"\"\")\n\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            if self.settings.helics.iterative_mode:\n                sim_step = self.settings.simulation.psse_solver_timestep.total_seconds() / self.iter_const\n            else:\n                sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n        else:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n\n        ierr = self.psse.dynamics_solution_param_2(\n            [60, self._i, self._i, self._i, self._i, self._i, self._i, self._i],\n            [0.4, self._f, sim_step, self._f, self._f, self._f, self._f, self._f],\n        )\n\n        if ierr:\n            msg = f'Error loading dynamic model file \"{dyr_path}\". Error code - {ierr}'\n            raise Exception(msg)\n        else:\n            logger.debug(f\"Dynamic file {dyr_path} sucessfully loaded\")\n\n        self.disable_load_models_for_coupled_buses()\n\n        if self.export_settings.export_results_using_channels:\n            self.setup_channels()\n\n        self.psse.delete_all_plot_channels()\n\n        self.setup_all_channels()\n\n        # Load user defined models\n        self.load_user_defined_models()\n\n        # Load flow settings\n        self.psse.fdns([0, 0, 0, 1, 1, 0, 99, 0])\n        # initialize\n        outx_file  = str(self.settings.export.outx_file).split(\"\\\\\")\n        outx_file[-1] = self.export_settings.filename_prefix + \"_\" + outx_file[-1]\n        outx_file = \"\\\\\".join(outx_file)\n        ierr = self.psse.strt_2(\n            [\n                1,\n                self.settings.generators.missing_machine_model,\n            ],\n            outx_file,\n        )\n        if ierr:\n            self.initialization_complete = False\n            msg = f\"Dynamic simulation failed to successfully initialize. Error code - {ierr}\"\n            raise Exception(msg)\n        else:\n            self.initialization_complete = True\n            logger.debug(\"Dynamic simulation initialization sucess!\")\n        # get load info for the sub system\n        # self.load_info = self.get_load_indices(bus_subsystems)\n\n        logger.debug(\"pyPSSE initialization complete!\")\n\n        self.xTime = 0\n\n        return self.initialization_complete\n\n    def step(self, t):\n        \"Increments the simulation\"\n\n        self.time = self.time + self.incTime\n        self.xTime = 0\n        return self.psse.run(0, t, 1, 1, 1)\n\n    # @kapil do you need this?\n\n    # def get_load_indices(self, bus_subsystems):\n    #     \"Returns load indices\"\n\n    #     all_bus_ids = {}\n    #     for bus_subsystem_id in bus_subsystems.keys():\n    #         load_info = {}\n    #         ierr, load_data = self.psse.aloadchar(bus_subsystem_id, 1, [\"ID\", \"NAME\", \"EXNAME\"])\n\n    #         load_data = np.array(load_data)\n    #         ierr, bus_data = self.psse.aloadint(bus_subsystem_id, 1, [\"NUMBER\"])\n\n    #         bus_data = bus_data[0]\n    #         for i, bus_id in enumerate(bus_data):\n    #             load_info[bus_id] = {\n    #                 \"Load ID\": load_data[0, i],\n    #                 \"Bus name\": load_data[1, i],\n    #                 \"Bus name (ext)\": load_data[2, i],\n    #             }\n    #         all_bus_ids[bus_subsystem_id] = load_info\n    #     return all_bus_ids\n\n    def resolve_step(self, t):\n        \"Resolves the current time step\"\n\n        err = self.psse.run(0, t + self.xTime * self.incTime / self.iter_const, 1, 1, 1)\n        self.xTime += 1\n        return err\n\n    def get_time(self):\n        \"Returns current simulator time\"\n\n        return self.time\n\n    def get_total_seconds(self):\n        \"Returns total simulation time\"\n\n        return (self.time - self._StartTime).total_seconds()\n\n    def get_step_size_cec(self):\n        \"Returns simulation timestep resolution\"\n        return self.settings.simulation.simulation_step_resolution.total_seconds()\n\n    @converter\n    def read_subsystems(self, quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None):\n        \"Queries the result container for current results\"\n\n        if ext_string2_info is None:\n            ext_string2_info = {}\n        if mapping_dict is None:\n            mapping_dict = {}\n        results = super().read_subsystems(\n            quantities, subsystem_buses, mapping_dict=mapping_dict, ext_string2_info=ext_string2_info\n        )\n\n        poll_results = self.poll_channels()\n        results.update(poll_results)\n        for class_name, var_list in quantities.items():\n            if class_name in dyn_only_options:\n                for v in var_list:\n                    if v in DYNAMIC_ONLY_PPTY[class_name]:\n                        for func_name in dyn_only_options[class_name]:\n                            if v in dyn_only_options[class_name][func_name]:\n                                con_ind = dyn_only_options[class_name][func_name][v]\n                                for bus in subsystem_buses:\n                                    if class_name == \"Loads\":\n                                        ierr = self.psse.inilod(int(bus))\n\n                                        ierr, ld_id = self.psse.nxtlod(int(bus))\n\n                                        if ld_id is not None:\n                                            ierr, con_index = getattr(self.psse, func_name)(\n                                                int(bus), ld_id, \"CHARAC\", \"CON\"\n                                            )\n\n                                            if con_index is not None:\n                                                act_con_index = con_index + con_ind\n                                                ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n\n                                                res_base = f\"{class_name}_{v}\"\n                                                if res_base not in results:\n                                                    results[res_base] = {}\n                                                obj_name = f\"{bus}_{ld_id}\"\n                                                results[res_base][obj_name] = value\n            else:\n                logger.warning(\"Extend function 'read_subsystems' in the Dynamic class (Dynamic.py)\")\n        return results\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.get_step_size_cec","title":"<code>get_step_size_cec()</code>","text":"<p>Returns simulation timestep resolution</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def get_step_size_cec(self):\n    \"Returns simulation timestep resolution\"\n    return self.settings.simulation.simulation_step_resolution.total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.get_time","title":"<code>get_time()</code>","text":"<p>Returns current simulator time</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def get_time(self):\n    \"Returns current simulator time\"\n\n    return self.time\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.get_total_seconds","title":"<code>get_total_seconds()</code>","text":"<p>Returns total simulation time</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def get_total_seconds(self):\n    \"Returns total simulation time\"\n\n    return (self.time - self._StartTime).total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.init","title":"<code>init(bus_subsystems)</code>","text":"<p>Initializes the simulation</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def init(self, bus_subsystems):\n    \"Initializes the simulation\"\n    super().init(bus_subsystems)\n    self.iter_const = 100.0\n\n    if self.settings.simulation.rwm_file:\n        self.psse.mcre([1, 0], self.rwn_file)\n\n    self.psse.fnsl([0, 0, 0, 1, 0, 0, 0, self._i])\n\n    self.load_setup_files()\n    self.convert_load()\n\n    self.psse.gnet(1, 0)\n    self.psse.fdns([1, 1, 0, 1, 1, 0, 0, 0])\n    self.psse.fnsl([1, 1, 0, 1, 1, 0, 0, 0])\n    self.psse.cong(0)\n    # Solve for dynamics\n    self.psse.ordr(0)\n    self.psse.fact()\n    self.psse.tysl(0)\n    self.psse.tysl(0)\n    # self.psse.save(self.study_case_path.split('.')[0] + \".sav\")\n    dyr_path = self.settings.simulation.dyr_file\n    assert dyr_path and dyr_path.exists\n    logger.debug(f\"Loading dynamic model....{dyr_path}\")\n    self.psse.dynamicsmode(1)\n    ierr = self.psse.dyre_new([1, 1, 1, 1], str(dyr_path), r\"\"\"conec\"\"\", r\"\"\"conet\"\"\", r\"\"\"compile\"\"\")\n\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        if self.settings.helics.iterative_mode:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds() / self.iter_const\n        else:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n    else:\n        sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n\n    ierr = self.psse.dynamics_solution_param_2(\n        [60, self._i, self._i, self._i, self._i, self._i, self._i, self._i],\n        [0.4, self._f, sim_step, self._f, self._f, self._f, self._f, self._f],\n    )\n\n    if ierr:\n        msg = f'Error loading dynamic model file \"{dyr_path}\". Error code - {ierr}'\n        raise Exception(msg)\n    else:\n        logger.debug(f\"Dynamic file {dyr_path} sucessfully loaded\")\n\n    self.disable_load_models_for_coupled_buses()\n\n    if self.export_settings.export_results_using_channels:\n        self.setup_channels()\n\n    self.psse.delete_all_plot_channels()\n\n    self.setup_all_channels()\n\n    # Load user defined models\n    self.load_user_defined_models()\n\n    # Load flow settings\n    self.psse.fdns([0, 0, 0, 1, 1, 0, 99, 0])\n    # initialize\n    outx_file  = str(self.settings.export.outx_file).split(\"\\\\\")\n    outx_file[-1] = self.export_settings.filename_prefix + \"_\" + outx_file[-1]\n    outx_file = \"\\\\\".join(outx_file)\n    ierr = self.psse.strt_2(\n        [\n            1,\n            self.settings.generators.missing_machine_model,\n        ],\n        outx_file,\n    )\n    if ierr:\n        self.initialization_complete = False\n        msg = f\"Dynamic simulation failed to successfully initialize. Error code - {ierr}\"\n        raise Exception(msg)\n    else:\n        self.initialization_complete = True\n        logger.debug(\"Dynamic simulation initialization sucess!\")\n    # get load info for the sub system\n    # self.load_info = self.get_load_indices(bus_subsystems)\n\n    logger.debug(\"pyPSSE initialization complete!\")\n\n    self.xTime = 0\n\n    return self.initialization_complete\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.read_subsystems","title":"<code>read_subsystems(quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None)</code>","text":"<p>Queries the result container for current results</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>@converter\ndef read_subsystems(self, quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None):\n    \"Queries the result container for current results\"\n\n    if ext_string2_info is None:\n        ext_string2_info = {}\n    if mapping_dict is None:\n        mapping_dict = {}\n    results = super().read_subsystems(\n        quantities, subsystem_buses, mapping_dict=mapping_dict, ext_string2_info=ext_string2_info\n    )\n\n    poll_results = self.poll_channels()\n    results.update(poll_results)\n    for class_name, var_list in quantities.items():\n        if class_name in dyn_only_options:\n            for v in var_list:\n                if v in DYNAMIC_ONLY_PPTY[class_name]:\n                    for func_name in dyn_only_options[class_name]:\n                        if v in dyn_only_options[class_name][func_name]:\n                            con_ind = dyn_only_options[class_name][func_name][v]\n                            for bus in subsystem_buses:\n                                if class_name == \"Loads\":\n                                    ierr = self.psse.inilod(int(bus))\n\n                                    ierr, ld_id = self.psse.nxtlod(int(bus))\n\n                                    if ld_id is not None:\n                                        ierr, con_index = getattr(self.psse, func_name)(\n                                            int(bus), ld_id, \"CHARAC\", \"CON\"\n                                        )\n\n                                        if con_index is not None:\n                                            act_con_index = con_index + con_ind\n                                            ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n\n                                            res_base = f\"{class_name}_{v}\"\n                                            if res_base not in results:\n                                                results[res_base] = {}\n                                            obj_name = f\"{bus}_{ld_id}\"\n                                            results[res_base][obj_name] = value\n        else:\n            logger.warning(\"Extend function 'read_subsystems' in the Dynamic class (Dynamic.py)\")\n    return results\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.resolve_step","title":"<code>resolve_step(t)</code>","text":"<p>Resolves the current time step</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def resolve_step(self, t):\n    \"Resolves the current time step\"\n\n    err = self.psse.run(0, t + self.xTime * self.incTime / self.iter_const, 1, 1, 1)\n    self.xTime += 1\n    return err\n</code></pre>"},{"location":"code/reference/#pypsse.modes.dynamic.Dynamic.step","title":"<code>step(t)</code>","text":"<p>Increments the simulation</p> Source code in <code>pypsse\\modes\\dynamic.py</code> <pre><code>def step(self, t):\n    \"Increments the simulation\"\n\n    self.time = self.time + self.incTime\n    self.xTime = 0\n    return self.psse.run(0, t, 1, 1, 1)\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap","title":"<code>Snap</code>","text":"<p>             Bases: <code>AbstractMode</code>, <code>DynamicUtils</code></p> <p>Class defination for snapshat simulation mode (uses snp and sav files)</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>class Snap(AbstractMode, DynamicUtils):\n    \"Class defination for snapshat simulation mode (uses snp and sav files)\"\n\n    def __init__(\n        self,\n        psse,\n        dyntools,\n        settings: SimulationSettings,\n        export_settings: ExportFileOptions,\n        subsystem_buses,\n        raw_data,\n    ):\n        super().__init__(psse, dyntools, settings, export_settings, subsystem_buses, raw_data)\n        self.time = settings.simulation.start_time\n        self._StartTime = settings.simulation.start_time\n        self.incTime = settings.simulation.simulation_step_resolution\n        self.init(subsystem_buses)\n\n    def init(self, bus_subsystems):\n        \"Initializes the simulation\"\n        super().init(bus_subsystems)\n\n        self.iter_const = 100.0\n        self.xTime = 0\n\n        ierr = self.psse.case(str(self.settings.simulation.case_study))\n\n        self.load_setup_files()\n        self.convert_load()\n\n        logger.info(f\"Load snap file: {self.settings.simulation.snp_file}\")\n        ierr = self.psse.rstr(str(self.settings.simulation.snp_file))\n        #\n\n        # The following logic only runs when the helics interface is enabled\n        self.disable_load_models_for_coupled_buses()\n        self.disable_generation_for_coupled_buses()\n        # self.save_model()\n        ############# ------------------------------------- ###############\n        outx_file  = str(self.settings.export.outx_file).split(\"\\\\\")\n        outx_file[-1] = self.export_settings.filename_prefix + \"_\" + outx_file[-1]\n        outx_file = \"\\\\\".join(outx_file)\n\n        ierr = self.psse.strt_2([0, 1],  outx_file)\n\n        if ierr == 1:\n            self.psse.cong(0)\n            ierr = self.psse.strt_2([0, 1],  outx_file)\n\n        elif ierr &gt; 1:\n            msg = \"Error starting simulation\"\n            raise Exception(msg)\n\n        self.load_user_defined_models()\n\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            if self.settings.helics.iterative_mode:\n                sim_step = self.settings.simulation.psse_solver_timestep.total_seconds() / self.iter_const\n            else:\n                sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n        else:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n\n        self.psse.dynamics_solution_param_2(\n            [60, self._i, self._i, self._i, self._i, self._i, self._i, self._i],\n            [0.4, self._f, sim_step, self._f, self._f, self._f, self._f, self._f],\n        )\n\n        self.psse.delete_all_plot_channels()\n\n        self.setup_all_channels()\n\n        logger.debug(\"pyPSSE initialization complete!\")\n        self.initialization_complete = True\n        return self.initialization_complete\n\n    def step(self, t):\n        \"Increments the simulation\"\n        self.time = self.time + self.incTime\n        self.xTime = 0\n        return self.psse.run(0, t, 1, 1, 1)\n\n    def resolve_step(self, t):\n        \"Resolves the current time step\"\n        self.xTime += 1\n        return self.psse.run(0, t + self.xTime * self.incTime / self.iter_const, 1, 1, 1)\n\n    def get_load_indices(self, bus_subsystems):\n        \"Returns load indices\"\n        all_bus_ids = {}\n        for bus_subsystem_id in bus_subsystems.keys():\n            load_info = {}\n            ierr, load_data = self.psse.aloadchar(bus_subsystem_id, 1, [\"ID\", \"NAME\", \"EXNAME\"])\n\n            load_data = np.array(load_data)\n            ierr, bus_data = self.psse.aloadint(bus_subsystem_id, 1, [\"NUMBER\"])\n\n            bus_data = bus_data[0]\n            for i, bus_id in enumerate(bus_data):\n                load_info[bus_id] = {\n                    \"Load ID\": load_data[0, i],\n                    \"Bus name\": load_data[1, i],\n                    \"Bus name (ext)\": load_data[2, i],\n                }\n            all_bus_ids[bus_subsystem_id] = load_info\n        return all_bus_ids\n\n    def get_time(self):\n        \"Returns current simulator time\"\n        return self.time\n\n    def get_total_seconds(self):\n        \"Returns total simulation time\"\n        return (self.time - self._StartTime).total_seconds()\n\n    def get_step_size_cec(self):\n        \"Returns simulation timestep resolution\"\n        return self.settings.simulation.simulation_step_resolution.total_seconds()\n\n    @converter\n    def read_subsystems(self, quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None):\n        \"Queries the result container for current results\"\n        if ext_string2_info is None:\n            ext_string2_info = {}\n        if mapping_dict is None:\n            mapping_dict = {}\n        results = super().read_subsystems(\n            quantities, subsystem_buses, mapping_dict=mapping_dict, ext_string2_info=ext_string2_info\n        )\n\n        poll_results = self.poll_channels()\n        results.update(poll_results)\n        \"\"\" Add \"\"\"\n        for class_name, var_list in quantities.items():\n            if class_name in dyn_only_options:\n                for v in var_list:\n                    if v in DYNAMIC_ONLY_PPTY[class_name]:\n                        for func_name in dyn_only_options[class_name]:\n                            if v in dyn_only_options[class_name][func_name]:\n                                con_ind = dyn_only_options[class_name][func_name][v]\n                                for bus in subsystem_buses:\n                                    if class_name == \"Loads\":\n                                        ierr = self.psse.inilod(int(bus))\n\n                                        ierr, ld_id = self.psse.nxtlod(int(bus))\n\n                                        if ld_id is not None:\n                                            ierr, con_index = getattr(self.psse, func_name)(\n                                                int(bus), ld_id, \"CHARAC\", \"CON\"\n                                            )\n\n                                            if con_index is not None:\n                                                act_con_index = con_index + con_ind\n                                                ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n\n                                                res_base = f\"{class_name}_{v}\"\n                                                if res_base not in results:\n                                                    results[res_base] = {}\n                                                obj_name = f\"{bus}_{ld_id}\"\n                                                results[res_base][obj_name] = value\n            else:\n                logger.warning(\"Extend function 'read_subsystems' in the Snap class (Snap.py)\")\n\n        return results\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.get_load_indices","title":"<code>get_load_indices(bus_subsystems)</code>","text":"<p>Returns load indices</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def get_load_indices(self, bus_subsystems):\n    \"Returns load indices\"\n    all_bus_ids = {}\n    for bus_subsystem_id in bus_subsystems.keys():\n        load_info = {}\n        ierr, load_data = self.psse.aloadchar(bus_subsystem_id, 1, [\"ID\", \"NAME\", \"EXNAME\"])\n\n        load_data = np.array(load_data)\n        ierr, bus_data = self.psse.aloadint(bus_subsystem_id, 1, [\"NUMBER\"])\n\n        bus_data = bus_data[0]\n        for i, bus_id in enumerate(bus_data):\n            load_info[bus_id] = {\n                \"Load ID\": load_data[0, i],\n                \"Bus name\": load_data[1, i],\n                \"Bus name (ext)\": load_data[2, i],\n            }\n        all_bus_ids[bus_subsystem_id] = load_info\n    return all_bus_ids\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.get_step_size_cec","title":"<code>get_step_size_cec()</code>","text":"<p>Returns simulation timestep resolution</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def get_step_size_cec(self):\n    \"Returns simulation timestep resolution\"\n    return self.settings.simulation.simulation_step_resolution.total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.get_time","title":"<code>get_time()</code>","text":"<p>Returns current simulator time</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def get_time(self):\n    \"Returns current simulator time\"\n    return self.time\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.get_total_seconds","title":"<code>get_total_seconds()</code>","text":"<p>Returns total simulation time</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def get_total_seconds(self):\n    \"Returns total simulation time\"\n    return (self.time - self._StartTime).total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.init","title":"<code>init(bus_subsystems)</code>","text":"<p>Initializes the simulation</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def init(self, bus_subsystems):\n    \"Initializes the simulation\"\n    super().init(bus_subsystems)\n\n    self.iter_const = 100.0\n    self.xTime = 0\n\n    ierr = self.psse.case(str(self.settings.simulation.case_study))\n\n    self.load_setup_files()\n    self.convert_load()\n\n    logger.info(f\"Load snap file: {self.settings.simulation.snp_file}\")\n    ierr = self.psse.rstr(str(self.settings.simulation.snp_file))\n    #\n\n    # The following logic only runs when the helics interface is enabled\n    self.disable_load_models_for_coupled_buses()\n    self.disable_generation_for_coupled_buses()\n    # self.save_model()\n    ############# ------------------------------------- ###############\n    outx_file  = str(self.settings.export.outx_file).split(\"\\\\\")\n    outx_file[-1] = self.export_settings.filename_prefix + \"_\" + outx_file[-1]\n    outx_file = \"\\\\\".join(outx_file)\n\n    ierr = self.psse.strt_2([0, 1],  outx_file)\n\n    if ierr == 1:\n        self.psse.cong(0)\n        ierr = self.psse.strt_2([0, 1],  outx_file)\n\n    elif ierr &gt; 1:\n        msg = \"Error starting simulation\"\n        raise Exception(msg)\n\n    self.load_user_defined_models()\n\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        if self.settings.helics.iterative_mode:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds() / self.iter_const\n        else:\n            sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n    else:\n        sim_step = self.settings.simulation.psse_solver_timestep.total_seconds()\n\n    self.psse.dynamics_solution_param_2(\n        [60, self._i, self._i, self._i, self._i, self._i, self._i, self._i],\n        [0.4, self._f, sim_step, self._f, self._f, self._f, self._f, self._f],\n    )\n\n    self.psse.delete_all_plot_channels()\n\n    self.setup_all_channels()\n\n    logger.debug(\"pyPSSE initialization complete!\")\n    self.initialization_complete = True\n    return self.initialization_complete\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.read_subsystems","title":"<code>read_subsystems(quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None)</code>","text":"<p>Queries the result container for current results</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>@converter\ndef read_subsystems(self, quantities, subsystem_buses, ext_string2_info=None, mapping_dict=None):\n    \"Queries the result container for current results\"\n    if ext_string2_info is None:\n        ext_string2_info = {}\n    if mapping_dict is None:\n        mapping_dict = {}\n    results = super().read_subsystems(\n        quantities, subsystem_buses, mapping_dict=mapping_dict, ext_string2_info=ext_string2_info\n    )\n\n    poll_results = self.poll_channels()\n    results.update(poll_results)\n    \"\"\" Add \"\"\"\n    for class_name, var_list in quantities.items():\n        if class_name in dyn_only_options:\n            for v in var_list:\n                if v in DYNAMIC_ONLY_PPTY[class_name]:\n                    for func_name in dyn_only_options[class_name]:\n                        if v in dyn_only_options[class_name][func_name]:\n                            con_ind = dyn_only_options[class_name][func_name][v]\n                            for bus in subsystem_buses:\n                                if class_name == \"Loads\":\n                                    ierr = self.psse.inilod(int(bus))\n\n                                    ierr, ld_id = self.psse.nxtlod(int(bus))\n\n                                    if ld_id is not None:\n                                        ierr, con_index = getattr(self.psse, func_name)(\n                                            int(bus), ld_id, \"CHARAC\", \"CON\"\n                                        )\n\n                                        if con_index is not None:\n                                            act_con_index = con_index + con_ind\n                                            ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n\n                                            res_base = f\"{class_name}_{v}\"\n                                            if res_base not in results:\n                                                results[res_base] = {}\n                                            obj_name = f\"{bus}_{ld_id}\"\n                                            results[res_base][obj_name] = value\n        else:\n            logger.warning(\"Extend function 'read_subsystems' in the Snap class (Snap.py)\")\n\n    return results\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.resolve_step","title":"<code>resolve_step(t)</code>","text":"<p>Resolves the current time step</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def resolve_step(self, t):\n    \"Resolves the current time step\"\n    self.xTime += 1\n    return self.psse.run(0, t + self.xTime * self.incTime / self.iter_const, 1, 1, 1)\n</code></pre>"},{"location":"code/reference/#pypsse.modes.snap.Snap.step","title":"<code>step(t)</code>","text":"<p>Increments the simulation</p> Source code in <code>pypsse\\modes\\snap.py</code> <pre><code>def step(self, t):\n    \"Increments the simulation\"\n    self.time = self.time + self.incTime\n    self.xTime = 0\n    return self.psse.run(0, t, 1, 1, 1)\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static","title":"<code>Static</code>","text":"<p>             Bases: <code>AbstractMode</code></p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>class Static(AbstractMode):\n    def __init__(self, psse, dyntools, settings, export_settings, subsystem_buses, raw_data):\n        \"Class defination for steady-state simulation mode\"\n\n        super().__init__(psse, dyntools, settings, export_settings, subsystem_buses, raw_data)\n        self.time = settings.simulation.start_time\n        self._StartTime = settings.simulation.start_time\n        self.incTime = settings.simulation.simulation_step_resolution\n\n    def init(self, bussubsystems):\n        super().init(bussubsystems)\n        self.initialization_complete = True\n\n    def step(self, _):\n        \"Increments the simulation\"\n        ierr = self.psse.fnsl()\n        # check if powerflow completed successfully\n        if ierr == 0:\n            self.time = self.time + self.incTime\n        else:\n            msg = f\"Error code {ierr} returned from PSSE while running powerflow, please follow \\\n                            PSSE doumentation to know more about error\"\n            raise Exception(msg)\n\n    def resolve_step(self):\n        \"Resolves the current time step\"\n        ierr = self.psse.fnsl()\n        if ierr &gt; 0:\n            msg = f\"Error code {ierr} returned from PSSE while running powerflow, please follow \\\n                                        PSSE doumentation to know more about error\"\n            raise Exception(msg)\n\n    def get_time(self):\n        \"Returns current simulator time\"\n        return self.time\n\n    def get_total_seconds(self):\n        \"Returns total simulation time\"\n        return (self.time - self._StartTime).total_seconds()\n\n    def get_step_size_cec(self):\n        \"Returns simulation timestep resolution\"\n        return self.settings.simulation.simulation_step_resolution.total_seconds()\n\n    def export(self):\n        \"Exports simulation results\"\n        logger.debug(\"Starting export process. Can take a few minutes for large files\")\n        excelpath = os.path.join(self.export_path, self.settings[\"Excel file\"])\n        achnf = self.dyntools.CHNF(self.outx_path)\n        achnf.xlsout(channels=\"\", show=False, xlsfile=excelpath, outfile=\"\", sheet=\"Sheet1\", overwritesheet=True)\n        logger.debug(f\"{self.settings.export.excel_file} exported\")\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.__init__","title":"<code>__init__(psse, dyntools, settings, export_settings, subsystem_buses, raw_data)</code>","text":"<p>Class defination for steady-state simulation mode</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def __init__(self, psse, dyntools, settings, export_settings, subsystem_buses, raw_data):\n    \"Class defination for steady-state simulation mode\"\n\n    super().__init__(psse, dyntools, settings, export_settings, subsystem_buses, raw_data)\n    self.time = settings.simulation.start_time\n    self._StartTime = settings.simulation.start_time\n    self.incTime = settings.simulation.simulation_step_resolution\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.export","title":"<code>export()</code>","text":"<p>Exports simulation results</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def export(self):\n    \"Exports simulation results\"\n    logger.debug(\"Starting export process. Can take a few minutes for large files\")\n    excelpath = os.path.join(self.export_path, self.settings[\"Excel file\"])\n    achnf = self.dyntools.CHNF(self.outx_path)\n    achnf.xlsout(channels=\"\", show=False, xlsfile=excelpath, outfile=\"\", sheet=\"Sheet1\", overwritesheet=True)\n    logger.debug(f\"{self.settings.export.excel_file} exported\")\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.get_step_size_cec","title":"<code>get_step_size_cec()</code>","text":"<p>Returns simulation timestep resolution</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def get_step_size_cec(self):\n    \"Returns simulation timestep resolution\"\n    return self.settings.simulation.simulation_step_resolution.total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.get_time","title":"<code>get_time()</code>","text":"<p>Returns current simulator time</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def get_time(self):\n    \"Returns current simulator time\"\n    return self.time\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.get_total_seconds","title":"<code>get_total_seconds()</code>","text":"<p>Returns total simulation time</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def get_total_seconds(self):\n    \"Returns total simulation time\"\n    return (self.time - self._StartTime).total_seconds()\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.resolve_step","title":"<code>resolve_step()</code>","text":"<p>Resolves the current time step</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def resolve_step(self):\n    \"Resolves the current time step\"\n    ierr = self.psse.fnsl()\n    if ierr &gt; 0:\n        msg = f\"Error code {ierr} returned from PSSE while running powerflow, please follow \\\n                                    PSSE doumentation to know more about error\"\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.modes.static.Static.step","title":"<code>step(_)</code>","text":"<p>Increments the simulation</p> Source code in <code>pypsse\\modes\\static.py</code> <pre><code>def step(self, _):\n    \"Increments the simulation\"\n    ierr = self.psse.fnsl()\n    # check if powerflow completed successfully\n    if ierr == 0:\n        self.time = self.time + self.incTime\n    else:\n        msg = f\"Error code {ierr} returned from PSSE while running powerflow, please follow \\\n                        PSSE doumentation to know more about error\"\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.simulation_controller.sim_controller","title":"<code>sim_controller(psse, dyntools, settings, export_settings, subsystem_buses, raw_data)</code>","text":"<p>sets up an appropriate simualtion controller based on user input</p> <p>Parameters:</p> Name Type Description Default <code>psse</code> <code>object</code> <p>simulator instance</p> required <code>dyntools</code> <code>object</code> <p>psse dyntools instance</p> required <code>settings</code> <code>SimulationSettings</code> <p>simulation settings</p> required <code>export_settings</code> <code>ExportFileOptions</code> <p>export settings</p> required <code>subsystem_buses</code> <code>dict</code> <p>mapping of bus subsystems to buses</p> required <code>raw_data</code> <code>Reader</code> <p>instance of model reader</p> required <p>Returns:</p> Type Description <code>Union[Dynamic, ProductionCostModel, Snap, Static]</code> <p>Union[Dynamic, ProductionCostModel, Snap, Static]: simulator controller instance</p> Source code in <code>pypsse\\simulation_controller.py</code> <pre><code>def sim_controller(\n    psse: object,\n    dyntools: object,\n    settings: SimulationSettings,\n    export_settings: ExportFileOptions,\n    subsystem_buses: dict,\n    raw_data: Reader,\n) -&gt; Union[Dynamic, ProductionCostModel, Snap, Static]:\n    \"\"\"sets up an appropriate simualtion controller based on user input\n\n    Args:\n        psse (object): simulator instance\n        dyntools (object): psse dyntools instance\n        settings (SimulationSettings): simulation settings\n        export_settings (ExportFileOptions): export settings\n        subsystem_buses (dict): mapping of bus subsystems to buses\n        raw_data (Reader): instance of model reader\n\n    Returns:\n        Union[Dynamic, ProductionCostModel, Snap, Static]: simulator controller instance\n    \"\"\"\n\n    sim_modes = {\"Dynamic\": Dynamic, \"Steady-state\": Static, \"Snap\": Snap, \"ProductionCostModel\": ProductionCostModel}\n\n    sim = sim_modes[settings.simulation.simulation_mode.value](\n        psse, dyntools, settings, export_settings, subsystem_buses, raw_data\n    )\n    logger.debug(f\"Simulator contoller of type {settings.simulation.simulation_mode.value} created\")\n    return sim\n</code></pre>"},{"location":"code/reference/#model-parsers","title":"Model parsers","text":""},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser","title":"<code>GICParser</code>","text":"<p>parser for the psse GIC file</p> Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>class GICParser:\n    \"\"\"parser for the psse GIC file\"\"\"\n\n    valid_verions = [\"3\"]\n\n    def __init__(self, settings: SimulationSettings):\n        \"\"\"create GIC parser object\n\n        Args:\n            settings (SimulationSettings): simulation settings\n        \"\"\"\n        logger.debug(\"Starting RAW parser\")\n\n        self.settings = settings\n        self.filepath = str(settings.simulation.gic_file)\n\n        self.filehandle = open(self.filepath)\n        verion = self.filehandle.readline()\n        if \"GICFILEVRSN=\" in verion:\n            verion = verion.replace(\"GICFILEVRSN=\", \"\").replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n            if verion in self.valid_verions:\n                logger.debug(f\"Reading GIC file verion {verion}\")\n            else:\n                vers = \",\".join(self.valid_verions)\n                logger.debug(f\"Version {verion} is not supported.\\nFollowing version are currently supported: {vers}\")\n        else:\n            logger.debug(\"GIC file structue does not seem to be valid\")\n\n        self.get_bus_coordinates()\n        self.psse_graph = nx.Graph()\n        self.create_graph()\n        pos = {}\n        for node in self.psse_graph.nodes:\n            pos[node] = [\n                float(self.psse_graph.nodes[node][\"latitude\"]),\n                float(self.psse_graph.nodes[node][\"longitude\"]),\n            ]\n        export_path = os.path.join(\n            self.settings[\"Simulation\"][\"Project Path\"],\n            \"Exports\",\n            self.settings[\"Export_settings\"][\"NetworkX graph file\"],\n        )\n        nx.write_gpickle(self.psse_graph, export_path)\n        # nx.draw(self.psse_graph ,pos)\n        # plt.show()\n\n    def create_graph(self):\n        \"\"\"creates graph representation\"\"\"\n\n        self.parse_substation_data()\n        self.parse_transformer_data()\n        self.parse_branch_data()\n        nx.set_node_attributes(self.psse_graph, self.bus_data)\n\n    def parse_substation_data(self):\n        \"\"\"parses substation data\"\"\"\n\n        logger.debug(\"Parsing substation data...\")\n        linedata = \"\"\n        while True:\n            linedata = self.filehandle.readline()\n            if \"End of Bus Substation Data\" in linedata:\n                break\n            if self.settings[\"GIC_export_settings\"][\"include substation connections\"]:\n                buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n                buses = buses.split(\" \")\n                if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                    self.psse_graph.add_edge(buses[0], buses[1])\n                else:\n                    logger.debug(\n                        f\"Error parsing substation data egde: {buses}.\\nOne of the bus id does not exist in bus data\"\n                    )\n\n    def parse_transformer_data(self):\n        \"\"\"parses transformer data\"\"\"\n\n        logger.debug(\"Parsing transformer data...\")\n        linedata = \"\"\n        while True:\n            linedata = self.filehandle.readline()\n            if \"End of Transformer Data\" in linedata:\n                break\n\n            if self.settings[\"GIC_export_settings\"][\"include transfomer connections\"]:\n                buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n                buses = buses.split(\" \")[:3]\n                if buses[2] == \"\":\n                    if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                        self.psse_graph.add_edge(buses[0], buses[1])\n                    else:\n                        logger.debug(\n                            f\"Error parsing transformer data egde: {buses}.\"\n                            f\"\\nOne of the bus id does not exist in bus data\"\n                        )\n                else:\n                    if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                        self.psse_graph.add_edge(buses[0], buses[1])\n                    if buses[2] in self.bus_data and buses[1] in self.bus_data:\n                        self.psse_graph.add_edge(buses[1], buses[2])\n                    if buses[2] in self.bus_data and buses[0] in self.bus_data:\n                        self.psse_graph.add_edge(buses[2], buses[0])\n                    pass\n\n    def parse_branch_data(self):\n        \"\"\"parses branch data\"\"\"\n\n        logger.debug(\"Parsing branch data...\")\n        linedata = \"\"\n        while True:\n            linedata = self.filehandle.readline()\n            if \"End of Branch Data\" in linedata:\n                break\n            if self.settings[\"GIC_export_settings\"][\"include branch connections\"]:\n                buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n                buses = buses.split(\" \")[:2]\n                if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                    self.psse_graph.add_edge(buses[0], buses[1])\n                else:\n                    logger.debug(\n                        f\"Error parsing branch data egde: {buses}.\\nOne of the bus id does not exist in bus data\"\n                    )\n\n    def get_bus_coordinates(self):\n        \"\"\"parses bus coordinates\"\"\"\n\n        logger.debug(\"Parsing bus coordinates...\")\n        bus_data_headers = [\"subsystem/bustype?\", \"latitude\", \"longitude\", \"angle?\"]\n        self.bus_data = {}\n        linedata = \"\"\n        start = \"'\"\n        end = \"'\"\n        while True:\n            linedata = self.filehandle.readline()\n            if \"End of Substation data\" in linedata:\n                break\n\n            bus_name = linedata[linedata.find(start) + len(start) : linedata.rfind(end)]\n            data = linedata.replace(f\" {start}{bus_name}{end}\", \"\")\n            data = data.replace(\"  \", \" \")\n            data = data.replace(\"  \", \" \")\n            data = data.split(\" \")\n            bus_id = data[0]\n\n            if bus_id not in self.bus_data:\n                self.bus_data[bus_id] = {}\n\n            self.bus_data[bus_id][\"bus_name\"] = bus_name\n            for val, label in zip(data[1:], bus_data_headers):\n                self.bus_data[bus_id][label] = val\n\n        bus_data = pd.DataFrame(self.bus_data).T\n        export_path = os.path.join(\n            self.settings[\"Simulation\"][\"Project Path\"], \"Exports\", self.settings[\"Export_settings\"][\"Coordinate file\"]\n        )\n        bus_data.to_csv(export_path)\n        logger.debug(f\"Bus coordinate file exported to: {export_path}\")\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser.__init__","title":"<code>__init__(settings)</code>","text":"<p>create GIC parser object</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>SimulationSettings</code> <p>simulation settings</p> required Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>def __init__(self, settings: SimulationSettings):\n    \"\"\"create GIC parser object\n\n    Args:\n        settings (SimulationSettings): simulation settings\n    \"\"\"\n    logger.debug(\"Starting RAW parser\")\n\n    self.settings = settings\n    self.filepath = str(settings.simulation.gic_file)\n\n    self.filehandle = open(self.filepath)\n    verion = self.filehandle.readline()\n    if \"GICFILEVRSN=\" in verion:\n        verion = verion.replace(\"GICFILEVRSN=\", \"\").replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n        if verion in self.valid_verions:\n            logger.debug(f\"Reading GIC file verion {verion}\")\n        else:\n            vers = \",\".join(self.valid_verions)\n            logger.debug(f\"Version {verion} is not supported.\\nFollowing version are currently supported: {vers}\")\n    else:\n        logger.debug(\"GIC file structue does not seem to be valid\")\n\n    self.get_bus_coordinates()\n    self.psse_graph = nx.Graph()\n    self.create_graph()\n    pos = {}\n    for node in self.psse_graph.nodes:\n        pos[node] = [\n            float(self.psse_graph.nodes[node][\"latitude\"]),\n            float(self.psse_graph.nodes[node][\"longitude\"]),\n        ]\n    export_path = os.path.join(\n        self.settings[\"Simulation\"][\"Project Path\"],\n        \"Exports\",\n        self.settings[\"Export_settings\"][\"NetworkX graph file\"],\n    )\n    nx.write_gpickle(self.psse_graph, export_path)\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser.create_graph","title":"<code>create_graph()</code>","text":"<p>creates graph representation</p> Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>def create_graph(self):\n    \"\"\"creates graph representation\"\"\"\n\n    self.parse_substation_data()\n    self.parse_transformer_data()\n    self.parse_branch_data()\n    nx.set_node_attributes(self.psse_graph, self.bus_data)\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser.get_bus_coordinates","title":"<code>get_bus_coordinates()</code>","text":"<p>parses bus coordinates</p> Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>def get_bus_coordinates(self):\n    \"\"\"parses bus coordinates\"\"\"\n\n    logger.debug(\"Parsing bus coordinates...\")\n    bus_data_headers = [\"subsystem/bustype?\", \"latitude\", \"longitude\", \"angle?\"]\n    self.bus_data = {}\n    linedata = \"\"\n    start = \"'\"\n    end = \"'\"\n    while True:\n        linedata = self.filehandle.readline()\n        if \"End of Substation data\" in linedata:\n            break\n\n        bus_name = linedata[linedata.find(start) + len(start) : linedata.rfind(end)]\n        data = linedata.replace(f\" {start}{bus_name}{end}\", \"\")\n        data = data.replace(\"  \", \" \")\n        data = data.replace(\"  \", \" \")\n        data = data.split(\" \")\n        bus_id = data[0]\n\n        if bus_id not in self.bus_data:\n            self.bus_data[bus_id] = {}\n\n        self.bus_data[bus_id][\"bus_name\"] = bus_name\n        for val, label in zip(data[1:], bus_data_headers):\n            self.bus_data[bus_id][label] = val\n\n    bus_data = pd.DataFrame(self.bus_data).T\n    export_path = os.path.join(\n        self.settings[\"Simulation\"][\"Project Path\"], \"Exports\", self.settings[\"Export_settings\"][\"Coordinate file\"]\n    )\n    bus_data.to_csv(export_path)\n    logger.debug(f\"Bus coordinate file exported to: {export_path}\")\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser.parse_branch_data","title":"<code>parse_branch_data()</code>","text":"<p>parses branch data</p> Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>def parse_branch_data(self):\n    \"\"\"parses branch data\"\"\"\n\n    logger.debug(\"Parsing branch data...\")\n    linedata = \"\"\n    while True:\n        linedata = self.filehandle.readline()\n        if \"End of Branch Data\" in linedata:\n            break\n        if self.settings[\"GIC_export_settings\"][\"include branch connections\"]:\n            buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n            buses = buses.split(\" \")[:2]\n            if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                self.psse_graph.add_edge(buses[0], buses[1])\n            else:\n                logger.debug(\n                    f\"Error parsing branch data egde: {buses}.\\nOne of the bus id does not exist in bus data\"\n                )\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser.parse_substation_data","title":"<code>parse_substation_data()</code>","text":"<p>parses substation data</p> Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>def parse_substation_data(self):\n    \"\"\"parses substation data\"\"\"\n\n    logger.debug(\"Parsing substation data...\")\n    linedata = \"\"\n    while True:\n        linedata = self.filehandle.readline()\n        if \"End of Bus Substation Data\" in linedata:\n            break\n        if self.settings[\"GIC_export_settings\"][\"include substation connections\"]:\n            buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n            buses = buses.split(\" \")\n            if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                self.psse_graph.add_edge(buses[0], buses[1])\n            else:\n                logger.debug(\n                    f\"Error parsing substation data egde: {buses}.\\nOne of the bus id does not exist in bus data\"\n                )\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.gic_parser.GICParser.parse_transformer_data","title":"<code>parse_transformer_data()</code>","text":"<p>parses transformer data</p> Source code in <code>pypsse\\parsers\\gic_parser.py</code> <pre><code>def parse_transformer_data(self):\n    \"\"\"parses transformer data\"\"\"\n\n    logger.debug(\"Parsing transformer data...\")\n    linedata = \"\"\n    while True:\n        linedata = self.filehandle.readline()\n        if \"End of Transformer Data\" in linedata:\n            break\n\n        if self.settings[\"GIC_export_settings\"][\"include transfomer connections\"]:\n            buses = linedata.replace(\"\\r\", \"\").replace(\"\\n\", \"\")\n            buses = buses.split(\" \")[:3]\n            if buses[2] == \"\":\n                if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                    self.psse_graph.add_edge(buses[0], buses[1])\n                else:\n                    logger.debug(\n                        f\"Error parsing transformer data egde: {buses}.\"\n                        f\"\\nOne of the bus id does not exist in bus data\"\n                    )\n            else:\n                if buses[0] in self.bus_data and buses[1] in self.bus_data:\n                    self.psse_graph.add_edge(buses[0], buses[1])\n                if buses[2] in self.bus_data and buses[1] in self.bus_data:\n                    self.psse_graph.add_edge(buses[1], buses[2])\n                if buses[2] in self.bus_data and buses[0] in self.bus_data:\n                    self.psse_graph.add_edge(buses[2], buses[0])\n                pass\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.reader.Reader","title":"<code>Reader</code>","text":"<p>Parser for indexing all PSSE model assets</p> Source code in <code>pypsse\\parsers\\reader.py</code> <pre><code>class Reader:\n    \"Parser for indexing all PSSE model assets\"\n\n    def __init__(self, psse_instance: object):\n        \"\"\"creates pypsse model reader\n\n        Args:\n            psse_instance (object): simulator instance\n        \"\"\"\n        self.psse = psse_instance\n        self.buses = self.get_data(\"abus\", tails=[\"int\"], strings=[\"NUMBER\"], flags=[2])\n        self.loads = self.get_data(\"aload\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ID\"], flags=[4, 4])\n        self.loads = self.get_data(\"aload\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ID\"], flags=[4, 4])\n        self.fixed_stunts = self.get_data(\"afxshunt\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ID\"], flags=[4, 4])\n        self.generators = self.get_data(\"amach\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ID\"], flags=[4, 4])\n        self.branches = self.get_data(\n            \"abrn\", tails=[\"int\", \"int\", \"char\"], strings=[\"FROMNUMBER\", \"TONUMBER\", \"ID\"], flags=[2, 2, 2]\n        )\n        self.transformers = self.get_data(\n            \"atr3\", tails=[\"int\", \"int\", \"int\"], strings=[\"WIND1NUMBER\", \"WIND2NUMBER\", \"WIND3NUMBER\"], flags=[2, 2, 2]\n        )\n        self.area = self.get_data(\n            \"aarea\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"AREANAME\"], flags=[2, 2]\n        )  # Talk to Aadil\n        self.dc_branch = self.get_data(\n            \"a2trmdc\", tails=[\"int\", \"int\"], strings=[\"FROMNUMBER\", \"TONUMBER\"], flags=[2, 2]\n        )  # three terminal dc lines not implemented\n        self.multi_term_dc = self.get_data(\n            \"amultitrmdc\", tails=[\"int\", \"int\"], strings=[\"VCNPOSNUMBER\", \"VCNNEGNUMBER\"], flags=[2, 2]\n        )\n        self.switched_shunt = self.get_data(\n            \"aswsh\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"DEVICENAME\"], flags=[4, 4]\n        )\n        self.zones = self.get_data(\"azone\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ZONENAME\"], flags=[2, 2])\n        self.owners = self.get_data(\"aowner\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"OWNERNAME\"], flags=[2, 2])\n\n    def get_data(self, func_name: str, tails: list = [], strings: list = [], flags: List[int] = []) -&gt; list:\n        \"\"\"returns list of assets matching signature\n\n        Args:\n            func_name (str): _description_\n            tails (list, optional): method tail. Defaults to [].\n            strings (list, optional): data types. Defaults to [].\n            flags (List[int], optional): list of flags for filtering. Defaults to [].\n\n        Returns:\n            list: list of asset names\n        \"\"\"\n\n        array_list = []\n        for tail, string, flag in zip(tails, strings, flags):\n            func = getattr(self.psse, func_name.lower() + tail)\n            ierr, array_1 = func(sid=-1, flag=flag, string=string)\n            assert ierr == 0, f\"Error code {ierr}, while running function '{func_name.lower() + tail}'\"\n            array_list.append([x for array in array_1 for x in array])\n\n        logger.info(f\"{func_name} count - {len(array_1)}\")\n        if len(array_list) == 1:\n            return array_list[0]\n\n        return list(zip(*array_list))\n\n    def __str__(self) -&gt; str:\n        \"\"\"overrides default 'print' behavior\n\n        Returns:\n            str: summary of model assets\n        \"\"\"\n        str_name = \"Model asset summary:\\n\"\n        for model in MAPPED_CLASS_NAMES:\n            str_name += f\"   {model}-{len(getattr(self, model))}\"\n        return str_name\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.reader.Reader.__init__","title":"<code>__init__(psse_instance)</code>","text":"<p>creates pypsse model reader</p> <p>Parameters:</p> Name Type Description Default <code>psse_instance</code> <code>object</code> <p>simulator instance</p> required Source code in <code>pypsse\\parsers\\reader.py</code> <pre><code>def __init__(self, psse_instance: object):\n    \"\"\"creates pypsse model reader\n\n    Args:\n        psse_instance (object): simulator instance\n    \"\"\"\n    self.psse = psse_instance\n    self.buses = self.get_data(\"abus\", tails=[\"int\"], strings=[\"NUMBER\"], flags=[2])\n    self.loads = self.get_data(\"aload\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ID\"], flags=[4, 4])\n    self.loads = self.get_data(\"aload\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ID\"], flags=[4, 4])\n    self.fixed_stunts = self.get_data(\"afxshunt\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ID\"], flags=[4, 4])\n    self.generators = self.get_data(\"amach\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ID\"], flags=[4, 4])\n    self.branches = self.get_data(\n        \"abrn\", tails=[\"int\", \"int\", \"char\"], strings=[\"FROMNUMBER\", \"TONUMBER\", \"ID\"], flags=[2, 2, 2]\n    )\n    self.transformers = self.get_data(\n        \"atr3\", tails=[\"int\", \"int\", \"int\"], strings=[\"WIND1NUMBER\", \"WIND2NUMBER\", \"WIND3NUMBER\"], flags=[2, 2, 2]\n    )\n    self.area = self.get_data(\n        \"aarea\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"AREANAME\"], flags=[2, 2]\n    )  # Talk to Aadil\n    self.dc_branch = self.get_data(\n        \"a2trmdc\", tails=[\"int\", \"int\"], strings=[\"FROMNUMBER\", \"TONUMBER\"], flags=[2, 2]\n    )  # three terminal dc lines not implemented\n    self.multi_term_dc = self.get_data(\n        \"amultitrmdc\", tails=[\"int\", \"int\"], strings=[\"VCNPOSNUMBER\", \"VCNNEGNUMBER\"], flags=[2, 2]\n    )\n    self.switched_shunt = self.get_data(\n        \"aswsh\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"DEVICENAME\"], flags=[4, 4]\n    )\n    self.zones = self.get_data(\"azone\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"ZONENAME\"], flags=[2, 2])\n    self.owners = self.get_data(\"aowner\", tails=[\"int\", \"char\"], strings=[\"NUMBER\", \"OWNERNAME\"], flags=[2, 2])\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.reader.Reader.__str__","title":"<code>__str__()</code>","text":"<p>overrides default 'print' behavior</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>summary of model assets</p> Source code in <code>pypsse\\parsers\\reader.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"overrides default 'print' behavior\n\n    Returns:\n        str: summary of model assets\n    \"\"\"\n    str_name = \"Model asset summary:\\n\"\n    for model in MAPPED_CLASS_NAMES:\n        str_name += f\"   {model}-{len(getattr(self, model))}\"\n    return str_name\n</code></pre>"},{"location":"code/reference/#pypsse.parsers.reader.Reader.get_data","title":"<code>get_data(func_name, tails=[], strings=[], flags=[])</code>","text":"<p>returns list of assets matching signature</p> <p>Parameters:</p> Name Type Description Default <code>func_name</code> <code>str</code> <p>description</p> required <code>tails</code> <code>list</code> <p>method tail. Defaults to [].</p> <code>[]</code> <code>strings</code> <code>list</code> <p>data types. Defaults to [].</p> <code>[]</code> <code>flags</code> <code>List[int]</code> <p>list of flags for filtering. Defaults to [].</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list of asset names</p> Source code in <code>pypsse\\parsers\\reader.py</code> <pre><code>def get_data(self, func_name: str, tails: list = [], strings: list = [], flags: List[int] = []) -&gt; list:\n    \"\"\"returns list of assets matching signature\n\n    Args:\n        func_name (str): _description_\n        tails (list, optional): method tail. Defaults to [].\n        strings (list, optional): data types. Defaults to [].\n        flags (List[int], optional): list of flags for filtering. Defaults to [].\n\n    Returns:\n        list: list of asset names\n    \"\"\"\n\n    array_list = []\n    for tail, string, flag in zip(tails, strings, flags):\n        func = getattr(self.psse, func_name.lower() + tail)\n        ierr, array_1 = func(sid=-1, flag=flag, string=string)\n        assert ierr == 0, f\"Error code {ierr}, while running function '{func_name.lower() + tail}'\"\n        array_list.append([x for array in array_1 for x in array])\n\n    logger.info(f\"{func_name} count - {len(array_1)}\")\n    if len(array_list) == 1:\n        return array_list[0]\n\n    return list(zip(*array_list))\n</code></pre>"},{"location":"code/reference/#command-line-interface","title":"Command line interface","text":"<p>CLI to run a PyDSS project</p> <p>CLI to create a new PyPSSE project</p> <p>CLI to run a PyDSS project</p> <p>CLI to run the PyDSS server</p>"},{"location":"code/reference/#pypsse.cli.create_profiles.create_profiles","title":"<code>create_profiles(project_path, csv_file_path, profile_folder, profile_name, profile_type, start_time, profile_res, profile_info)</code>","text":"<p>Creates profiles for PyPSSE project.</p> Source code in <code>pypsse\\cli\\create_profiles.py</code> <pre><code>@click.argument(\n    \"project-path\",\n)\n@click.option(\n    \"-f\",\n    \"--csv-file-path\",\n    help=\"Path to a csv valid file\",\n    required=False,\n    default=\"\",\n)\n@click.option(\n    \"-p\",\n    \"--profile-folder\",\n    help=\"\"\"Path to folder containing csv profiles.\n    CSV file names should follow the following format: {profile-type}_{profile-name}\"\"\",\n    required=False,\n    default=\"\",\n)\n@click.option(\n    \"-n\",\n    \"--profile-name\",\n    required=False,\n    default=DEFAULT_PROFILE_NAME,\n    show_default=True,\n    help=\"Profile name\",\n)\n@click.option(\n    \"-t\",\n    \"--profile-type\",\n    required=False,\n    default=DEFAULT_PROFILE_TYPE,\n    show_default=True,\n    help=f\"Profile type; Possible values: {list(PROFILE_VALIDATION.keys())}\",\n)\n@click.option(\n    \"-T\",\n    \"--start-time\",\n    required=False,\n    default=DEFAULT_START_TIME,\n    show_default=True,\n    help=\"Time index for the first time step, format = Y-m-d H:M:S.f\",\n)\n@click.option(\n    \"-r\",\n    \"--profile-res\",\n    required=False,\n    default=DEFAULT_PROFILE_RESOLUTION,\n    show_default=True,\n    help=\"Profile time resolution in seconds\",\n)\n@click.option(\n    \"-i\",\n    \"--profile-info\",\n    required=False,\n    default=\"\",\n    show_default=True,\n    help=\"Profile time resolution in seconds\",\n)\n@click.command()\ndef create_profiles(\n    project_path, csv_file_path, profile_folder, profile_name, profile_type, start_time, profile_res, profile_info\n):\n    \"\"\"Creates profiles for PyPSSE project.\"\"\"\n    settings_file = os.path.join(project_path, \"Settings\", SIMULATION_SETTINGS_FILENAME)\n    if os.path.exists(settings_file):\n        if csv_file_path and os.path.exists(csv_file_path):\n            settings = toml.load(settings_file)\n            a = ProfileManager(None, settings)\n            a.add_profiles_from_csv(\n                csv_file=csv_file_path,\n                name=profile_name,\n                pType=profile_type,\n                startTime=dt.datetime.strptime(start_time, \"%Y-%m-%d %H:%M:%S.%f\").astimezone(None),\n                resolution_sec=profile_res,\n                info=profile_info,\n            )\n            logger.info(f\"Profile '{profile_name}' added to group '{profile_type}'\")\n        elif os.path.exists(profile_folder):\n            settings = toml.load(settings_file)\n            a = ProfileManager(None, settings)\n            for _, _, files in os.walk(profile_folder):\n                for file in files:\n                    if file.endswith(\".csv\"):\n                        filename = file.replace(\".csv\", \"\")\n                        if \"__\" in filename:\n                            dtype, p_name = filename.split(\"__\")\n                            a.add_profiles_from_csv(\n                                csv_file=os.path.join(profile_folder, file),\n                                name=p_name,\n                                pType=dtype,\n                                startTime=dt.datetime.strptime(start_time, \"%Y-%m-%d %H:%M:%S.%f\").astimezone(None),\n                                resolution_sec=profile_res,\n                                info=profile_info,\n                            )\n                            msg = f\"Profile '{p_name}'' added to group '{dtype}'\"\n                            logger.info(msg)\n        else:\n            msg = \"Value for either -f or -p flag has to be passed\"\n            raise Exception(msg)\n    else:\n        msg = f\"{project_path} is not a valid pypsse project\"\n        raise Exception(msg)\n</code></pre>"},{"location":"code/reference/#pypsse.cli.create_project.create_project","title":"<code>create_project(path=None, project=None, psse_project_folder=None, simulation_file=None, export_settings_file=None, profile_store=None, profile_mapping=None, overwrite=None, autofill=None)</code>","text":"<p>Create a new PyPSSE project.</p> Source code in <code>pypsse\\cli\\create_project.py</code> <pre><code>@click.argument(\n    \"path\",\n)\n@click.option(\n    \"-p\",\n    \"--project\",\n    required=True,\n    help=\"project name\",\n)\n@click.option(\n    \"-F\",\n    \"--psse-project-folder\",\n    default=None,\n    required=False,\n    type=click.Path(exists=True),\n    help=\"PSS/E project folder path\",\n)\n@click.option(\n    \"-f\",\n    \"--simulation-file\",\n    required=False,\n    show_default=True,\n    default=\"\",\n    help=\"Simulation settings toml file path\",\n)\n@click.option(\n    \"-e\",\n    \"--export-settings-file\",\n    default=\"\",\n    help=\"Export settings toml file path\",\n)\n@click.option(\n    \"-s\",\n    \"--profile-store\",\n    default=\"\",\n    help=\"Path to a valid Profiles.hdf5 file (Contains profiles for time series simulations)\",\n)\n@click.option(\n    \"-m\",\n    \"--profile-mapping\",\n    default=\"\",\n    help=\"Path to a valid Profile_mapping.toml file (used to map profile to PSSE elements)\",\n)\n@click.option(\n    \"-a\",\n    \"--autofill\",\n    help=\"Attempt to auto fill settings. (Verify manually settings file is correct)\",\n    is_flag=True,\n    default=True,\n    show_default=True,\n)\n@click.option(\n    \"-o\",\n    \"--overwrite\",\n    help=\"Overwrite project is it already exists\",\n    is_flag=True,\n    default=True,\n    show_default=True,\n)\n@click.command()\ndef create_project(\n    path=None,\n    project=None,\n    psse_project_folder=None,\n    simulation_file=None,\n    export_settings_file=None,\n    profile_store=None,\n    profile_mapping=None,\n    overwrite=None,\n    autofill=None,\n):\n    \"\"\"Create a new PyPSSE project.\"\"\"\n    if os.path.exists(path):\n        s_settings = toml.load(simulation_file) if simulation_file else {}\n        e_settings = toml.load(export_settings_file) if export_settings_file else {}\n        # TODO: Validate settings\n        a = Project()\n        a.create(\n            path,\n            project,\n            psse_project_folder,\n            s_settings,\n            e_settings,\n            profile_store,\n            profile_mapping,\n            overwrite,\n            autofill,\n        )\n</code></pre>"},{"location":"code/reference/#pypsse.cli.run.run","title":"<code>run(project_path, simulations_file=None)</code>","text":"<p>Runs a valid PyPSSE simulation.</p> Source code in <code>pypsse\\cli\\run.py</code> <pre><code>@click.argument(\n    \"project-path\",\n)\n@click.option(\n    \"-s\",\n    \"--simulations-file\",\n    required=False,\n    default=SIMULATION_SETTINGS_FILENAME,\n    show_default=True,\n    help=\"scenario toml file to run (over rides default)\",\n)\n@click.command()\ndef run(project_path, simulations_file=None):\n    \"\"\"Runs a valid PyPSSE simulation.\"\"\"\n    file_path = Path(project_path) / simulations_file\n    msg = \"Simulation file not found. Use -s to choose a valid settings file\"\n    \"if its name differs from the default file name.\"\n    assert file_path.exists(), msg\n    x = Simulator.from_setting_files(file_path)\n    x.run()\n</code></pre>"},{"location":"code/reference/#pypsse.cli.serve.serve","title":"<code>serve(host_ip='127.0.0.1', port=9090)</code>","text":"<p>Run a PyPSSE RESTful API server.</p> Source code in <code>pypsse\\cli\\serve.py</code> <pre><code>@click.option(\n    \"-p\",\n    \"--port\",\n    default=9090,\n    show_default=True,\n    help=\"Socket port for the server\",\n)\n@click.option(\n    \"-h\",\n    \"--host-ip\",\n    default=\"127.0.0.1\",\n    show_default=True,\n    help=\"IP for the server\",\n)\n@click.command()\ndef serve(host_ip=\"127.0.0.1\", port=9090):\n    \"\"\"Run a PyPSSE RESTful API server.\"\"\"\n    run_server(host_ip, port)\n</code></pre>"},{"location":"code/reference/#data-interfaces","title":"Data interfaces","text":""},{"location":"code/reference/#pypsse.data_writers.data_writer.DataWriter","title":"<code>DataWriter</code>","text":"<p>Data writer class defination</p> Source code in <code>pypsse\\data_writers\\data_writer.py</code> <pre><code>class DataWriter:\n    \"Data writer class defination\"\n    modes = {\n        \"h5\": HDF5Writer,\n        \"csv\": CSVWriter,\n        \"json\": JSONWriter,\n        \"none\": DummyWriter,\n    }\n\n    def __init__(self, log_dir, formatnm, column_length, filename_prefix):\n        \"Sets up a data writer as per user input\"\n        self.writer = self.modes[formatnm](log_dir, column_length, filename_prefix)\n\n    def write(self, currenttime, powerflow_output, convergence):\n        \"Enables incremental write to the data writer object\"\n        self.writer.write(currenttime, powerflow_output, convergence)\n\n    def close_store(self):\n        pass\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.data_writer.DataWriter.__init__","title":"<code>__init__(log_dir, formatnm, column_length, filename_prefix)</code>","text":"<p>Sets up a data writer as per user input</p> Source code in <code>pypsse\\data_writers\\data_writer.py</code> <pre><code>def __init__(self, log_dir, formatnm, column_length, filename_prefix):\n    \"Sets up a data writer as per user input\"\n    self.writer = self.modes[formatnm](log_dir, column_length, filename_prefix)\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.data_writer.DataWriter.write","title":"<code>write(currenttime, powerflow_output, convergence)</code>","text":"<p>Enables incremental write to the data writer object</p> Source code in <code>pypsse\\data_writers\\data_writer.py</code> <pre><code>def write(self, currenttime, powerflow_output, convergence):\n    \"Enables incremental write to the data writer object\"\n    self.writer.write(currenttime, powerflow_output, convergence)\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.csv.CSVWriter","title":"<code>CSVWriter</code>","text":"<p>Class that handles writing simulation results to csv files.</p> Source code in <code>pypsse\\data_writers\\csv.py</code> <pre><code>class CSVWriter:\n    \"\"\"Class that handles writing simulation results to csv\n    files.\n    \"\"\"\n\n    def __init__(self, log_dir: Path, column_length: int, filename_prefix:str=\"\"):\n        \"\"\"Constructor for csv writer\n\n        Args:\n            log_dir (Path): output path (dirctory)\n            column_length (int): number of data columns\n        \"\"\"\n        self.filename_prefix=filename_prefix\n        self.column_length = column_length\n        self.log_dir = log_dir\n        self.timestamps = []\n        self.chunkRows = 1\n        self.dfs = {}\n        self.step = 0\n        # Create arrow writer for each object type\n\n    def write(self, currenttime: datetime, powerflow_output: dict):\n        \"\"\"Writes the status of assets at a particular timestep to a csv file.\n\n        Args:\n            currenttime (datetime): simulator time step\n            powerflow_output (dict): simulation results\n        \"\"\"\n\n        # Iterate through each object type\n        self.timestamps.append(currenttime)\n        for obj_type in powerflow_output:\n            data = powerflow_output[obj_type]\n            if obj_type not in self.dfs:\n                self.dfs[obj_type] = [data]\n            else:\n                if self.dfs[obj_type] is None:\n                    self.dfs[obj_type] = [data]\n                else:\n                    self.dfs[obj_type].append(data)\n\n            if self.step % self.chunkRows == self.chunkRows - 1:\n                fpath = os.path.join(self.log_dir, f\"{self.filename_prefix}_{obj_type}.csv\")\n                self.dfs[obj_type] = pd.DataFrame(self.dfs[obj_type], index=self.timestamps)\n                self.dfs[obj_type].to_csv(fpath, mode=\"a\")\n\n                self.dfs[obj_type] = None\n            self.Timestamp[self.step - 1] = np.string_(str(currenttime))\n        self.step += 1\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.csv.CSVWriter.__init__","title":"<code>__init__(log_dir, column_length, filename_prefix='')</code>","text":"<p>Constructor for csv writer</p> <p>Parameters:</p> Name Type Description Default <code>log_dir</code> <code>Path</code> <p>output path (dirctory)</p> required <code>column_length</code> <code>int</code> <p>number of data columns</p> required Source code in <code>pypsse\\data_writers\\csv.py</code> <pre><code>def __init__(self, log_dir: Path, column_length: int, filename_prefix:str=\"\"):\n    \"\"\"Constructor for csv writer\n\n    Args:\n        log_dir (Path): output path (dirctory)\n        column_length (int): number of data columns\n    \"\"\"\n    self.filename_prefix=filename_prefix\n    self.column_length = column_length\n    self.log_dir = log_dir\n    self.timestamps = []\n    self.chunkRows = 1\n    self.dfs = {}\n    self.step = 0\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.csv.CSVWriter.write","title":"<code>write(currenttime, powerflow_output)</code>","text":"<p>Writes the status of assets at a particular timestep to a csv file.</p> <p>Parameters:</p> Name Type Description Default <code>currenttime</code> <code>datetime</code> <p>simulator time step</p> required <code>powerflow_output</code> <code>dict</code> <p>simulation results</p> required Source code in <code>pypsse\\data_writers\\csv.py</code> <pre><code>def write(self, currenttime: datetime, powerflow_output: dict):\n    \"\"\"Writes the status of assets at a particular timestep to a csv file.\n\n    Args:\n        currenttime (datetime): simulator time step\n        powerflow_output (dict): simulation results\n    \"\"\"\n\n    # Iterate through each object type\n    self.timestamps.append(currenttime)\n    for obj_type in powerflow_output:\n        data = powerflow_output[obj_type]\n        if obj_type not in self.dfs:\n            self.dfs[obj_type] = [data]\n        else:\n            if self.dfs[obj_type] is None:\n                self.dfs[obj_type] = [data]\n            else:\n                self.dfs[obj_type].append(data)\n\n        if self.step % self.chunkRows == self.chunkRows - 1:\n            fpath = os.path.join(self.log_dir, f\"{self.filename_prefix}_{obj_type}.csv\")\n            self.dfs[obj_type] = pd.DataFrame(self.dfs[obj_type], index=self.timestamps)\n            self.dfs[obj_type].to_csv(fpath, mode=\"a\")\n\n            self.dfs[obj_type] = None\n        self.Timestamp[self.step - 1] = np.string_(str(currenttime))\n    self.step += 1\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.json.JSONWriter","title":"<code>JSONWriter</code>","text":"<p>Class that handles writing simulation results to json files.</p> Source code in <code>pypsse\\data_writers\\json.py</code> <pre><code>class JSONWriter:\n    \"\"\"Class that handles writing simulation results to json\n    files.\n    \"\"\"\n\n    def __init__(self, log_dir: Path, column_length: int, filename_prefix:str=\"\"):\n        \"\"\"Constructor for json writer\n\n        Args:\n            log_dir (Path): output path (dirctory)\n            column_length (int): number of data columns\n        \"\"\"\n        self.filename_prefix=filename_prefix\n        self.column_length = column_length\n        self.log_dir = log_dir\n        self.chunk_rows = 1\n        self.handles = {}\n        self.dfs = {}\n        self.step = 0\n        # Create arrow writer for each object type\n\n    def write(self, currenttime: datetime, powerflow_output: dict, _:bool=None):\n        \"\"\"Writes the status of assets at a particular timestep to a json file.\n\n        Args:\n            currenttime (datetime): simulator time step\n            powerflow_output (dict): simulation results\n        \"\"\"\n        # Iterate through each object type\n\n        for obj_type in powerflow_output:\n\n            fpath = os.path.join(self.log_dir, f\"{self.filename_prefix}_{obj_type}.json\")\n            if self.step == 0:\n                f = open(fpath, \"w\")\n                f.close()\n                self.handles[obj_type] = open(fpath, \"a\")\n            data = powerflow_output[obj_type]\n            if obj_type not in self.dfs:\n                self.dfs[obj_type] = {str(currenttime): data}\n            else:\n                if self.dfs[obj_type] is None:\n                    self.dfs[obj_type] = {str(currenttime): data}\n                else:\n                    self.dfs[obj_type][currenttime] = data\n            if self.step % self.chunk_rows == self.chunk_rows - 1:\n                try:\n                    json.dump(self.dfs[obj_type], self.handles[obj_type], indent=4)\n                    self.handles[obj_type].flush()\n                    self.dfs[obj_type] = None\n                except Exception as E:\n                    logger.warning(f\"Unable to write property {obj_type} to file: {E!s}\")\n\n        self.step += 1\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.json.JSONWriter.__init__","title":"<code>__init__(log_dir, column_length, filename_prefix='')</code>","text":"<p>Constructor for json writer</p> <p>Parameters:</p> Name Type Description Default <code>log_dir</code> <code>Path</code> <p>output path (dirctory)</p> required <code>column_length</code> <code>int</code> <p>number of data columns</p> required Source code in <code>pypsse\\data_writers\\json.py</code> <pre><code>def __init__(self, log_dir: Path, column_length: int, filename_prefix:str=\"\"):\n    \"\"\"Constructor for json writer\n\n    Args:\n        log_dir (Path): output path (dirctory)\n        column_length (int): number of data columns\n    \"\"\"\n    self.filename_prefix=filename_prefix\n    self.column_length = column_length\n    self.log_dir = log_dir\n    self.chunk_rows = 1\n    self.handles = {}\n    self.dfs = {}\n    self.step = 0\n</code></pre>"},{"location":"code/reference/#pypsse.data_writers.json.JSONWriter.write","title":"<code>write(currenttime, powerflow_output, _=None)</code>","text":"<p>Writes the status of assets at a particular timestep to a json file.</p> <p>Parameters:</p> Name Type Description Default <code>currenttime</code> <code>datetime</code> <p>simulator time step</p> required <code>powerflow_output</code> <code>dict</code> <p>simulation results</p> required Source code in <code>pypsse\\data_writers\\json.py</code> <pre><code>def write(self, currenttime: datetime, powerflow_output: dict, _:bool=None):\n    \"\"\"Writes the status of assets at a particular timestep to a json file.\n\n    Args:\n        currenttime (datetime): simulator time step\n        powerflow_output (dict): simulation results\n    \"\"\"\n    # Iterate through each object type\n\n    for obj_type in powerflow_output:\n\n        fpath = os.path.join(self.log_dir, f\"{self.filename_prefix}_{obj_type}.json\")\n        if self.step == 0:\n            f = open(fpath, \"w\")\n            f.close()\n            self.handles[obj_type] = open(fpath, \"a\")\n        data = powerflow_output[obj_type]\n        if obj_type not in self.dfs:\n            self.dfs[obj_type] = {str(currenttime): data}\n        else:\n            if self.dfs[obj_type] is None:\n                self.dfs[obj_type] = {str(currenttime): data}\n            else:\n                self.dfs[obj_type][currenttime] = data\n        if self.step % self.chunk_rows == self.chunk_rows - 1:\n            try:\n                json.dump(self.dfs[obj_type], self.handles[obj_type], indent=4)\n                self.handles[obj_type].flush()\n                self.dfs[obj_type] = None\n            except Exception as E:\n                logger.warning(f\"Unable to write property {obj_type} to file: {E!s}\")\n\n    self.step += 1\n</code></pre>"},{"location":"code/reference/#utility-functions","title":"Utility functions","text":""},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils","title":"<code>DynamicUtils</code>","text":"<p>Utility functions for dynamic simulations</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>class DynamicUtils:\n    \"Utility functions for dynamic simulations\"\n\n    dynamic_params: ClassVar[List[str]] = [\"FmA\", \"FmB\", \"FmC\", \"FmD\", \"Fel\"]\n\n    def disable_generation_for_coupled_buses(self):\n        \"\"\"Disables generation of coupled buses (co-simulation mode only)\"\"\"\n        if (\n            self.settings.helics\n            and self.settings.helics.cosimulation_mode\n            and self.settings.helics.disable_generation_on_coupled_buses\n        ):\n            sub_data = pd.read_csv(self.settings.simulation.subscriptions_file)\n            sub_data = sub_data[sub_data[\"element_type\"] == \"Load\"]\n            generators = {}\n            generator_list = {}\n\n            for gen_bus, gen_id in self.raw_data.generators:\n                if gen_bus not in generator_list:\n                    generator_list[gen_bus] = []\n                generator_list[gen_bus].append(gen_id)\n\n            for _, row in sub_data.iterrows():\n                bus = row[\"bus\"]\n                generators[bus] = generator_list[bus]\n\n            for bus_id, machines in generators.items():\n                for machine in machines:\n                    intgar = [0, self._i, self._i, self._i, self._i, self._i]\n                    realar = [\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                        self._f,\n                    ]\n                    self.psse.machine_chng_2(bus_id, machine, intgar, realar)\n                    logger.info(f\"Machine disabled: {bus_id}_{machine}\")\n\n    def disable_load_models_for_coupled_buses(self):\n        \"\"\"Disables loads of coupled buses (co-simulation mode only)\"\"\"\n        if self.settings.helics and self.settings.helics.cosimulation_mode:\n            sub_data = pd.read_csv(self.settings.simulation.subscriptions_file)\n            sub_data = sub_data[sub_data[\"element_type\"] == \"Load\"]\n\n            self.psse_dict = {}\n            for _, row in sub_data.iterrows():\n                bus = row[\"bus\"]\n                load = row[\"element_id\"]\n                ierr = self.psse.ldmod_status(0, int(bus), str(load), 1, 0)\n                if ierr == 0:\n                    logger.info(f\"Dynamic model for load {load} connected to bus {bus} has been disabled\")\n                elif ierr == 5:\n                    logger.error(f\"No dynamic model found for load {load} connected to bus {bus}\")\n                else:\n                    raise Exception(f\"error={ierr}\") \n\n    def break_loads(self, loads: list = None, components_to_replace: List[str] = []):\n        \"\"\"Implements the load split logic\n\n        Args:\n            loads (list, optional): list of coupled loads. Defaults to None.\n            components_to_replace (List[str], optional): components to be simulated on distribution side. Defaults to [].\n        \"\"\"\n\n        components_to_stay = [x for x in self.dynamic_params if x not in components_to_replace]\n        if loads is None:\n            loads = self._get_coupled_loads()\n        loads = self._get_load_static_data(loads)\n        loads = self._get_load_dynamic_data(loads)\n        loads = self._replicate_coupled_load(loads, components_to_replace)\n        self._update_dynamic_parameters(loads, components_to_stay, components_to_replace)\n\n    def _update_dynamic_parameters(self, loads: dict, components_to_stay: list, components_to_replace: list):\n        \"\"\"Updates dynamic parameters of composite old / replicated load models\n\n        Args:\n            loads (dict): load dictionary\n            components_to_stay (list): components to be simulated on transmission side\n            components_to_replace (list): components to be simulated on distribution side\n        \"\"\"\n\n        new_percentages = {}\n        for load in loads:\n            count = 0\n            for comp in components_to_stay:\n                count += load[comp]\n            for comp in components_to_stay:\n                new_percentages[comp] = load[comp] / count\n            for comp in components_to_replace:\n                new_percentages[comp] = 0.0\n\n            settings = self._get_load_dynamic_properties(load)\n            #\n            for k, v in new_percentages.items():\n                idx = dyn_only_options[\"Loads\"][\"lmodind\"][k]\n                settings[idx] = v\n                # self.psse.change_ldmod_con(load['bus'], 'XX' ,r\"\"\"CMLDBLU2\"\"\" ,idx ,v)\n            values = list(settings.values())\n            self.psse.add_load_model(load[\"bus\"], \"XX\", 0, 1, r\"\"\"CMLDBLU2\"\"\", 2, [0, 0], [\"\", \"\"], 133, values)\n            logger.info(f\"Dynamic model parameters for load {load['id']} at bus 'XX' changed.\")\n\n    def _get_load_dynamic_properties(self, load):\n        \"Returns dynamic parameters of composite load models\"\n        settings = {}\n        for i in range(133):\n            ierr, con_index = self.psse.lmodind(load[\"bus\"], str(load[\"id\"]), \"CHARAC\", \"CON\")\n            if con_index is not None:\n                act_con_index = con_index + i\n                ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n                assert ierr == 0, f\"error={ierr}\"\n                settings[i] = value\n        return settings\n\n    def _replicate_coupled_load(self, loads: dict, components_to_replace: list):\n        \"\"\"create a replica of composite load model\n\n        Args:\n            loads (dict): load dictionary\n            components_to_replace (list): composite load models to replace on distribution side\n\n        Returns:\n            dict: updated load dictionary\n        \"\"\"\n\n        for load in loads:\n            dynamic_percentage = load[\"FmA\"] + load[\"FmB\"] + load[\"FmC\"] + load[\"FmD\"] + load[\"Fel\"]\n            static_percentage = 1.0 - dynamic_percentage\n            for comp in components_to_replace:\n                static_percentage += load[comp]\n            remaining_load = 1 - static_percentage\n            total_load = load[\"MVA\"]\n            total_distribution_load = total_load * static_percentage\n            total_transmission_load = total_load * remaining_load\n            # ceate new load\n            self.psse.load_data_5(\n                load[\"bus\"],\n                \"XX\",\n                realar=[total_transmission_load.real, total_transmission_load.imag, 0.0, 0.0, 0.0, 0.0],\n                lodtyp=\"replica\",\n            )\n            # ierr, cmpval = self.psse.loddt2(load[\"bus\"], \"XX\" ,\"MVA\" , \"ACT\")\n            # modify old load\n            self.psse.load_data_5(\n                load[\"bus\"],\n                str(load[\"id\"]),\n                realar=[total_distribution_load.real, total_distribution_load.imag, 0.0, 0.0, 0.0, 0.0],\n                lodtyp=\"original\",\n            )\n            # ierr, cmpval = self.psse.loddt2(load[\"bus\"], load[\"id\"] ,\"MVA\" , \"ACT\")\n            logger.info(f\"Original load {load['id']} @ bus {load['bus']}: {total_load}\")\n            logger.info(f\"New load 'XX' @ bus {load['bus']} created successfully: {total_transmission_load}\")\n            logger.info(f\"Load {load['id']} @ bus {load['bus']} updated : {total_distribution_load}\")\n            load[\"distribution\"] = total_distribution_load\n            load[\"transmission\"] = total_transmission_load\n        return loads\n\n    def _get_coupled_loads(self) -&gt; list:\n        \"\"\"Returns a list of all coupled loads ina give simualtion\n\n        Returns:\n            list: list of coupled loads\n        \"\"\"\n\n        sub_data = pd.read_csv(\n            os.path.join(\n                self.settings[\"Simulation\"][\"Project Path\"], \"Settings\", self.settings[\"HELICS\"][\"Subscriptions file\"]\n            )\n        )\n        load = []\n        for _, row in sub_data.iterrows():\n            if row[\"element_type\"] == \"Load\":\n                load.append(\n                    {\n                        \"type\": row[\"element_type\"],\n                        \"id\": row[\"element_id\"],\n                        \"bus\": row[\"bus\"],\n                    }\n                )\n        return load\n\n    def _get_load_static_data(self, loads: list) -&gt; dict:\n        \"\"\"Returns static data for load models\n\n        Args:\n            loads (list): list of load names\n\n        Returns:\n            dict: mapping load to static values\n        \"\"\"\n\n        values = [\"MVA\", \"IL\", \"YL\", \"TOTAL\"]\n        for load in loads:\n            for v in values:\n                ierr, cmpval = self.psse.loddt2(load[\"bus\"], str(load[\"id\"]), v, \"ACT\")\n                load[v] = cmpval\n        return loads\n\n    def _get_load_dynamic_data(self, loads: list) -&gt; dict:\n        \"\"\"Returns dynamic data for load models\n\n        Args:\n            loads (list): list of load names\n\n        Returns:\n            dict: mapping load to dynamic values\n        \"\"\"\n\n        values = dyn_only_options[\"Loads\"][\"lmodind\"]\n        for load in loads:\n            for v, con_ind in values.items():\n                ierr = self.psse.inilod(load[\"bus\"])\n                assert ierr == 0, f\"error={ierr}\"\n                ierr, ld_id = self.psse.nxtlod(load[\"bus\"])\n                assert ierr == 0, f\"error={ierr}\"\n                if ld_id is not None:\n                    ierr, con_index = self.psse.lmodind(load[\"bus\"], ld_id, \"CHARAC\", \"CON\")\n                    assert ierr == 0, f\"error={ierr}\"\n                    if con_index is not None:\n                        act_con_index = con_index + con_ind\n                        ierr, value = self.psse.dsrval(\"CON\", act_con_index)\n                        assert ierr == 0, f\"error={ierr}\"\n                        load[v] = value\n        return loads\n\n    def setup_machine_channels(self, machines: dict, properties: list):\n        \"\"\"sets up machine channels\n\n        Args:\n            machines (dict): mapping machine to connected bus\n            properties (list): list of machine properties\n        \"\"\"\n\n        for _, qty in enumerate(properties):\n            if qty not in self.channel_map:\n                nqty = f\"MACHINE_{qty}\"\n                self.channel_map[nqty] = {}\n            for mch, b in machines:\n                if qty in MACHINE_CHANNELS:\n                    self.channel_map[nqty][f\"{b}_{mch}\"] = [self.chnl_idx]\n                    chnl_id = MACHINE_CHANNELS[qty]\n                    logger.info(f\"{qty} for machine {b}_{mch} added to channel {self.chnl_idx}\")\n                    self.psse.machine_array_channel([self.chnl_idx, chnl_id, int(b)], mch, \"\")\n                    self.chnl_idx += 1\n\n    def setup_load_channels(self, loads: list):\n        \"\"\"Sets up load channels\n\n        Args:\n            loads (list): list of loads\n        \"\"\"\n\n        if \"LOAD_P\" not in self.channel_map:\n            self.channel_map[\"LOAD_P\"] = {}\n            self.channel_map[\"LOAD_Q\"] = {}\n\n        for ld, b in loads:\n            self.channel_map[\"LOAD_P\"][f\"{b}_{ld}\"] = [self.chnl_idx]\n            self.channel_map[\"LOAD_Q\"][f\"{b}_{ld}\"] = [self.chnl_idx + 1]\n            self.psse.load_array_channel([self.chnl_idx, 1, int(b)], ld, \"\")\n            self.psse.load_array_channel([self.chnl_idx + 1, 2, int(b)], ld, \"\")\n            logger.info(f\"P and Q for load {b}_{ld} added to channel {self.chnl_idx} and {self.chnl_idx + 1}\")\n            self.chnl_idx += 2\n\n    def setup_bus_channels(self, buses: list, properties: list):\n        \"\"\"Sets up bus channels\n\n        Args:\n            buses (list): list of buses\n            properties (dict): list of bus properties\n        \"\"\"\n\n        for _, qty in enumerate(properties):\n            if qty not in self.channel_map:\n                self.channel_map[qty] = {}\n            for _, b in enumerate(buses):\n                if qty == \"frequency\":\n                    self.channel_map[qty][b] = [self.chnl_idx]\n                    self.psse.bus_frequency_channel([self.chnl_idx, int(b)], \"\")\n                    logger.info(f\"Frequency for bus {b} added to channel { self.chnl_idx}\")\n                    self.chnl_idx += 1\n                elif qty == \"voltage_and_angle\":\n                    self.channel_map[qty][b] = [self.chnl_idx, self.chnl_idx + 1]\n                    self.psse.voltage_and_angle_channel([self.chnl_idx, -1, -1, int(b)], \"\")\n                    logger.info(f\"Voltage and angle for bus {b} added to channel {self.chnl_idx} and {self.chnl_idx+1}\")\n                    self.chnl_idx += 2\n\n    def poll_channels(self) -&gt; dict:\n        \"\"\"Polls all channels adde during the setup process\n\n        Returns:\n            dict: mapping of polled channels to values\n        \"\"\"\n\n        results = {}\n        for ppty, b_dict in self.channel_map.items():\n            ppty_new = ppty.split(\"_and_\")\n            for b, indices in b_dict.items():\n                for n, idx in zip(ppty_new, indices):\n                    if \"_\" not in n:\n                        n_name = f\"BUS_{n}\"\n                    else:\n                        n_name = n\n                    if n_name not in results:\n                        results[n_name] = {}\n                    ierr, value = self.psse.chnval(idx)\n                    assert ierr == 0, f\"error={ierr}\"\n                    if value is None:\n                        value = -1\n                    results[n_name][b] = value\n        return results\n\n    def setup_all_channels(self):\n        \"\"\"Sets up all user-defined channels for a project\"\"\"\n\n        self.channel_map = {}\n        self.chnl_idx = 1\n        if not self.export_settings.channel_setup:\n            return\n\n        for channel in self.export_settings.channel_setup:\n            method_type = channel.asset_type\n            if method_type == \"buses\":\n                self.setup_bus_channels(channel.asset_list, channel.asset_properties)\n            elif method_type == \"loads\":\n                load_list = [[x, int(y)] for x, y in channel.asset_list]\n                self.setup_load_channels(load_list)\n            elif method_type == \"machines\":\n                machine_list = [[x, int(y)] for x, y in channel.asset_list]\n                self.setup_machine_channels(machine_list, channel.asset_properties)\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.break_loads","title":"<code>break_loads(loads=None, components_to_replace=[])</code>","text":"<p>Implements the load split logic</p> <p>Parameters:</p> Name Type Description Default <code>loads</code> <code>list</code> <p>list of coupled loads. Defaults to None.</p> <code>None</code> <code>components_to_replace</code> <code>List[str]</code> <p>components to be simulated on distribution side. Defaults to [].</p> <code>[]</code> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def break_loads(self, loads: list = None, components_to_replace: List[str] = []):\n    \"\"\"Implements the load split logic\n\n    Args:\n        loads (list, optional): list of coupled loads. Defaults to None.\n        components_to_replace (List[str], optional): components to be simulated on distribution side. Defaults to [].\n    \"\"\"\n\n    components_to_stay = [x for x in self.dynamic_params if x not in components_to_replace]\n    if loads is None:\n        loads = self._get_coupled_loads()\n    loads = self._get_load_static_data(loads)\n    loads = self._get_load_dynamic_data(loads)\n    loads = self._replicate_coupled_load(loads, components_to_replace)\n    self._update_dynamic_parameters(loads, components_to_stay, components_to_replace)\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.disable_generation_for_coupled_buses","title":"<code>disable_generation_for_coupled_buses()</code>","text":"<p>Disables generation of coupled buses (co-simulation mode only)</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def disable_generation_for_coupled_buses(self):\n    \"\"\"Disables generation of coupled buses (co-simulation mode only)\"\"\"\n    if (\n        self.settings.helics\n        and self.settings.helics.cosimulation_mode\n        and self.settings.helics.disable_generation_on_coupled_buses\n    ):\n        sub_data = pd.read_csv(self.settings.simulation.subscriptions_file)\n        sub_data = sub_data[sub_data[\"element_type\"] == \"Load\"]\n        generators = {}\n        generator_list = {}\n\n        for gen_bus, gen_id in self.raw_data.generators:\n            if gen_bus not in generator_list:\n                generator_list[gen_bus] = []\n            generator_list[gen_bus].append(gen_id)\n\n        for _, row in sub_data.iterrows():\n            bus = row[\"bus\"]\n            generators[bus] = generator_list[bus]\n\n        for bus_id, machines in generators.items():\n            for machine in machines:\n                intgar = [0, self._i, self._i, self._i, self._i, self._i]\n                realar = [\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                    self._f,\n                ]\n                self.psse.machine_chng_2(bus_id, machine, intgar, realar)\n                logger.info(f\"Machine disabled: {bus_id}_{machine}\")\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.disable_load_models_for_coupled_buses","title":"<code>disable_load_models_for_coupled_buses()</code>","text":"<p>Disables loads of coupled buses (co-simulation mode only)</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def disable_load_models_for_coupled_buses(self):\n    \"\"\"Disables loads of coupled buses (co-simulation mode only)\"\"\"\n    if self.settings.helics and self.settings.helics.cosimulation_mode:\n        sub_data = pd.read_csv(self.settings.simulation.subscriptions_file)\n        sub_data = sub_data[sub_data[\"element_type\"] == \"Load\"]\n\n        self.psse_dict = {}\n        for _, row in sub_data.iterrows():\n            bus = row[\"bus\"]\n            load = row[\"element_id\"]\n            ierr = self.psse.ldmod_status(0, int(bus), str(load), 1, 0)\n            if ierr == 0:\n                logger.info(f\"Dynamic model for load {load} connected to bus {bus} has been disabled\")\n            elif ierr == 5:\n                logger.error(f\"No dynamic model found for load {load} connected to bus {bus}\")\n            else:\n                raise Exception(f\"error={ierr}\") \n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.poll_channels","title":"<code>poll_channels()</code>","text":"<p>Polls all channels adde during the setup process</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>mapping of polled channels to values</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def poll_channels(self) -&gt; dict:\n    \"\"\"Polls all channels adde during the setup process\n\n    Returns:\n        dict: mapping of polled channels to values\n    \"\"\"\n\n    results = {}\n    for ppty, b_dict in self.channel_map.items():\n        ppty_new = ppty.split(\"_and_\")\n        for b, indices in b_dict.items():\n            for n, idx in zip(ppty_new, indices):\n                if \"_\" not in n:\n                    n_name = f\"BUS_{n}\"\n                else:\n                    n_name = n\n                if n_name not in results:\n                    results[n_name] = {}\n                ierr, value = self.psse.chnval(idx)\n                assert ierr == 0, f\"error={ierr}\"\n                if value is None:\n                    value = -1\n                results[n_name][b] = value\n    return results\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.setup_all_channels","title":"<code>setup_all_channels()</code>","text":"<p>Sets up all user-defined channels for a project</p> Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def setup_all_channels(self):\n    \"\"\"Sets up all user-defined channels for a project\"\"\"\n\n    self.channel_map = {}\n    self.chnl_idx = 1\n    if not self.export_settings.channel_setup:\n        return\n\n    for channel in self.export_settings.channel_setup:\n        method_type = channel.asset_type\n        if method_type == \"buses\":\n            self.setup_bus_channels(channel.asset_list, channel.asset_properties)\n        elif method_type == \"loads\":\n            load_list = [[x, int(y)] for x, y in channel.asset_list]\n            self.setup_load_channels(load_list)\n        elif method_type == \"machines\":\n            machine_list = [[x, int(y)] for x, y in channel.asset_list]\n            self.setup_machine_channels(machine_list, channel.asset_properties)\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.setup_bus_channels","title":"<code>setup_bus_channels(buses, properties)</code>","text":"<p>Sets up bus channels</p> <p>Parameters:</p> Name Type Description Default <code>buses</code> <code>list</code> <p>list of buses</p> required <code>properties</code> <code>dict</code> <p>list of bus properties</p> required Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def setup_bus_channels(self, buses: list, properties: list):\n    \"\"\"Sets up bus channels\n\n    Args:\n        buses (list): list of buses\n        properties (dict): list of bus properties\n    \"\"\"\n\n    for _, qty in enumerate(properties):\n        if qty not in self.channel_map:\n            self.channel_map[qty] = {}\n        for _, b in enumerate(buses):\n            if qty == \"frequency\":\n                self.channel_map[qty][b] = [self.chnl_idx]\n                self.psse.bus_frequency_channel([self.chnl_idx, int(b)], \"\")\n                logger.info(f\"Frequency for bus {b} added to channel { self.chnl_idx}\")\n                self.chnl_idx += 1\n            elif qty == \"voltage_and_angle\":\n                self.channel_map[qty][b] = [self.chnl_idx, self.chnl_idx + 1]\n                self.psse.voltage_and_angle_channel([self.chnl_idx, -1, -1, int(b)], \"\")\n                logger.info(f\"Voltage and angle for bus {b} added to channel {self.chnl_idx} and {self.chnl_idx+1}\")\n                self.chnl_idx += 2\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.setup_load_channels","title":"<code>setup_load_channels(loads)</code>","text":"<p>Sets up load channels</p> <p>Parameters:</p> Name Type Description Default <code>loads</code> <code>list</code> <p>list of loads</p> required Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def setup_load_channels(self, loads: list):\n    \"\"\"Sets up load channels\n\n    Args:\n        loads (list): list of loads\n    \"\"\"\n\n    if \"LOAD_P\" not in self.channel_map:\n        self.channel_map[\"LOAD_P\"] = {}\n        self.channel_map[\"LOAD_Q\"] = {}\n\n    for ld, b in loads:\n        self.channel_map[\"LOAD_P\"][f\"{b}_{ld}\"] = [self.chnl_idx]\n        self.channel_map[\"LOAD_Q\"][f\"{b}_{ld}\"] = [self.chnl_idx + 1]\n        self.psse.load_array_channel([self.chnl_idx, 1, int(b)], ld, \"\")\n        self.psse.load_array_channel([self.chnl_idx + 1, 2, int(b)], ld, \"\")\n        logger.info(f\"P and Q for load {b}_{ld} added to channel {self.chnl_idx} and {self.chnl_idx + 1}\")\n        self.chnl_idx += 2\n</code></pre>"},{"location":"code/reference/#pypsse.utils.dynamic_utils.DynamicUtils.setup_machine_channels","title":"<code>setup_machine_channels(machines, properties)</code>","text":"<p>sets up machine channels</p> <p>Parameters:</p> Name Type Description Default <code>machines</code> <code>dict</code> <p>mapping machine to connected bus</p> required <code>properties</code> <code>list</code> <p>list of machine properties</p> required Source code in <code>pypsse\\utils\\dynamic_utils.py</code> <pre><code>def setup_machine_channels(self, machines: dict, properties: list):\n    \"\"\"sets up machine channels\n\n    Args:\n        machines (dict): mapping machine to connected bus\n        properties (list): list of machine properties\n    \"\"\"\n\n    for _, qty in enumerate(properties):\n        if qty not in self.channel_map:\n            nqty = f\"MACHINE_{qty}\"\n            self.channel_map[nqty] = {}\n        for mch, b in machines:\n            if qty in MACHINE_CHANNELS:\n                self.channel_map[nqty][f\"{b}_{mch}\"] = [self.chnl_idx]\n                chnl_id = MACHINE_CHANNELS[qty]\n                logger.info(f\"{qty} for machine {b}_{mch} added to channel {self.chnl_idx}\")\n                self.psse.machine_array_channel([self.chnl_idx, chnl_id, int(b)], mch, \"\")\n                self.chnl_idx += 1\n</code></pre>"},{"location":"code/reference/#contincency-interface","title":"Contincency interface","text":"<p>This module manages contingency modeling in PyPSSE</p>"},{"location":"code/reference/#pypsse.contingencies.BaseFault","title":"<code>BaseFault</code>","text":"<p>Base class defination for all fault types</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class BaseFault:\n    \"Base class defination for all fault types\"\n    __metaclass__ = ABCMeta\n\n    requirements = []\n    fault_settings = {}\n    fault_method = \"\"\n    element = None\n\n    def __init__(self, psse, settings, contingency_type):\n        self.contingency_type = contingency_type\n        self.settings = settings\n        self.psse = psse\n        self.enabled = False\n        self.tripped = False\n\n    def update(self, t: float):\n        \"\"\"updates a fault event\n\n        Args:\n            t (float): simuation time in seconds\n        \"\"\"\n        self.t = t\n        if hasattr(self.settings, \"duration\"):\n            if (\n                self.settings.time + self.settings.duration\n                &gt; t\n                &gt;= self.settings.time\n                and not self.enabled\n            ):\n                self.enabled = True\n                self.enable_fault()\n            if (\n                t &gt;= self.settings.time + self.settings.duration\n                and self.enabled\n            ):\n                self.enabled = False\n                self.disable_fault()\n        elif (\n            not hasattr(self.settings, \"duration\")\n            and t &gt;= self.settings.time\n            and not self.tripped\n        ):\n            self.enable_fault()\n            self.tripped = True\n\n    def enable_fault(self):\n        \"\"\"enables a fault event\"\"\"\n        err = getattr(self.psse, self.fault_method)(**self.fault_settings)\n        if err:\n            logger.warning(\n                f\"Unable to enable {self.fault_method} at element {self.element}\"\n            )\n        else:\n            logger.debug(\n                f\"{self.fault_method} applied to {self.element} at time {self.t} seconds\"\n            )\n\n    def disable_fault(self):\n        \"\"\"disables a fault event\"\"\"\n        err = self.psse.dist_clear_fault()\n        if err:\n            logger.warning(\n                f\"Unable to clear {self.fault_method} at element {self.element}\"\n            )\n        else:\n            logger.debug(\n                f\"{self.fault_method} cleared at element {self.element} at time {self.t} seconds\"\n            )\n\n    def is_enabled(self):\n        \"\"\"Returns enabled status\n\n        Returns:\n            _type_: rue if the fault object is enabled else false\n        \"\"\"\n        return self.enabled\n\n    def is_tripped(self) -&gt; bool:\n        \"\"\"Returns trip status\n\n        Returns:\n            bool: true if the fault object is tripped else false\n        \"\"\"\n        return self.tripped\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BaseFault.disable_fault","title":"<code>disable_fault()</code>","text":"<p>disables a fault event</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def disable_fault(self):\n    \"\"\"disables a fault event\"\"\"\n    err = self.psse.dist_clear_fault()\n    if err:\n        logger.warning(\n            f\"Unable to clear {self.fault_method} at element {self.element}\"\n        )\n    else:\n        logger.debug(\n            f\"{self.fault_method} cleared at element {self.element} at time {self.t} seconds\"\n        )\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BaseFault.enable_fault","title":"<code>enable_fault()</code>","text":"<p>enables a fault event</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def enable_fault(self):\n    \"\"\"enables a fault event\"\"\"\n    err = getattr(self.psse, self.fault_method)(**self.fault_settings)\n    if err:\n        logger.warning(\n            f\"Unable to enable {self.fault_method} at element {self.element}\"\n        )\n    else:\n        logger.debug(\n            f\"{self.fault_method} applied to {self.element} at time {self.t} seconds\"\n        )\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BaseFault.is_enabled","title":"<code>is_enabled()</code>","text":"<p>Returns enabled status</p> <p>Returns:</p> Name Type Description <code>_type_</code> <p>rue if the fault object is enabled else false</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def is_enabled(self):\n    \"\"\"Returns enabled status\n\n    Returns:\n        _type_: rue if the fault object is enabled else false\n    \"\"\"\n    return self.enabled\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BaseFault.is_tripped","title":"<code>is_tripped()</code>","text":"<p>Returns trip status</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if the fault object is tripped else false</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def is_tripped(self) -&gt; bool:\n    \"\"\"Returns trip status\n\n    Returns:\n        bool: true if the fault object is tripped else false\n    \"\"\"\n    return self.tripped\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BaseFault.update","title":"<code>update(t)</code>","text":"<p>updates a fault event</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>simuation time in seconds</p> required Source code in <code>pypsse\\contingencies.py</code> <pre><code>def update(self, t: float):\n    \"\"\"updates a fault event\n\n    Args:\n        t (float): simuation time in seconds\n    \"\"\"\n    self.t = t\n    if hasattr(self.settings, \"duration\"):\n        if (\n            self.settings.time + self.settings.duration\n            &gt; t\n            &gt;= self.settings.time\n            and not self.enabled\n        ):\n            self.enabled = True\n            self.enable_fault()\n        if (\n            t &gt;= self.settings.time + self.settings.duration\n            and self.enabled\n        ):\n            self.enabled = False\n            self.disable_fault()\n    elif (\n        not hasattr(self.settings, \"duration\")\n        and t &gt;= self.settings.time\n        and not self.tripped\n    ):\n        self.enable_fault()\n        self.tripped = True\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BusFaultObject","title":"<code>BusFaultObject</code>","text":"<p>             Bases: <code>BaseFault</code></p> <p>Class defination for a bus fault</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class BusFaultObject(BaseFault):\n    \"Class defination for a bus fault\"\n    fault_method = \"dist_bus_fault\"\n    fault_settings = {}\n\n    def __init__(self, psse: object, settings: BusFault, contingency_type: str):\n        \"\"\"bus fault object\n\n        Args:\n            psse (object): simulator type\n            settings (BusFault): bus fault object\n            contingency_type (str): contingency type\n        \"\"\"\n        super().__init__(psse, settings, contingency_type)\n        self.fault_settings[\"ibus\"] = settings.bus_id\n        self.fault_settings[\"units\"] = 3\n        self.fault_settings[\"values\"] = settings.fault_impedance\n        self.fault_settings[\"basekv\"] = 0.0\n        self.element = settings.bus_id\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BusFaultObject.__init__","title":"<code>__init__(psse, settings, contingency_type)</code>","text":"<p>bus fault object</p> <p>Parameters:</p> Name Type Description Default <code>psse</code> <code>object</code> <p>simulator type</p> required <code>settings</code> <code>BusFault</code> <p>bus fault object</p> required <code>contingency_type</code> <code>str</code> <p>contingency type</p> required Source code in <code>pypsse\\contingencies.py</code> <pre><code>def __init__(self, psse: object, settings: BusFault, contingency_type: str):\n    \"\"\"bus fault object\n\n    Args:\n        psse (object): simulator type\n        settings (BusFault): bus fault object\n        contingency_type (str): contingency type\n    \"\"\"\n    super().__init__(psse, settings, contingency_type)\n    self.fault_settings[\"ibus\"] = settings.bus_id\n    self.fault_settings[\"units\"] = 3\n    self.fault_settings[\"values\"] = settings.fault_impedance\n    self.fault_settings[\"basekv\"] = 0.0\n    self.element = settings.bus_id\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BusTripObject","title":"<code>BusTripObject</code>","text":"<p>             Bases: <code>BaseFault</code></p> <p>Class defination for a bus trip</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class BusTripObject(BaseFault):\n    \"Class defination for a bus trip\"\n    fault_method = \"dist_bus_trip\"\n    fault_settings = {}\n\n    def __init__(self, psse: object, settings: BusTrip, contingency_type: str):\n        \"\"\"Bus trip contingency\n\n        Args:\n            psse (object): simulator instance\n            settings (BusTrip): bus trip model\n            contingency_type (str): type of contingency\n        \"\"\"\n        super().__init__(psse, settings, contingency_type)\n        self.fault_settings[\"ibus\"] = settings.bus_id\n        self.element = settings.bus_id\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.BusTripObject.__init__","title":"<code>__init__(psse, settings, contingency_type)</code>","text":"<p>Bus trip contingency</p> <p>Parameters:</p> Name Type Description Default <code>psse</code> <code>object</code> <p>simulator instance</p> required <code>settings</code> <code>BusTrip</code> <p>bus trip model</p> required <code>contingency_type</code> <code>str</code> <p>type of contingency</p> required Source code in <code>pypsse\\contingencies.py</code> <pre><code>def __init__(self, psse: object, settings: BusTrip, contingency_type: str):\n    \"\"\"Bus trip contingency\n\n    Args:\n        psse (object): simulator instance\n        settings (BusTrip): bus trip model\n        contingency_type (str): type of contingency\n    \"\"\"\n    super().__init__(psse, settings, contingency_type)\n    self.fault_settings[\"ibus\"] = settings.bus_id\n    self.element = settings.bus_id\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.LineFaultObject","title":"<code>LineFaultObject</code>","text":"<p>             Bases: <code>BaseFault</code></p> <p>Class defination for a line fault</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class LineFaultObject(BaseFault):\n    \"Class defination for a line fault\"\n    fault_method = \"dist_branch_fault\"\n    fault_settings = {}\n\n    def __init__(\n        self, psse: object, settings: LineFault, contingency_type: str\n    ):\n        \"\"\"line fault model\n\n        Args:\n            psse (object): simulator instance\n            settings (LineFault): line fault model\n            contingency_type (str): contingecy type\n        \"\"\"\n        super().__init__(psse, settings, contingency_type)\n        self.fault_settings[\"ibus\"] = settings.bus_ids[0]\n        self.fault_settings[\"jbus\"] = settings.bus_ids[1]\n        self.fault_settings[\"id\"] = settings.bus_ids[2]\n        self.fault_settings[\"units\"] = 3\n        self.fault_settings[\"values\"] = settings.fault_impedance\n        self.fault_settings[\"basekv\"] = 0.0\n        self.element = settings.bus_ids\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.LineFaultObject.__init__","title":"<code>__init__(psse, settings, contingency_type)</code>","text":"<p>line fault model</p> <p>Parameters:</p> Name Type Description Default <code>psse</code> <code>object</code> <p>simulator instance</p> required <code>settings</code> <code>LineFault</code> <p>line fault model</p> required <code>contingency_type</code> <code>str</code> <p>contingecy type</p> required Source code in <code>pypsse\\contingencies.py</code> <pre><code>def __init__(\n    self, psse: object, settings: LineFault, contingency_type: str\n):\n    \"\"\"line fault model\n\n    Args:\n        psse (object): simulator instance\n        settings (LineFault): line fault model\n        contingency_type (str): contingecy type\n    \"\"\"\n    super().__init__(psse, settings, contingency_type)\n    self.fault_settings[\"ibus\"] = settings.bus_ids[0]\n    self.fault_settings[\"jbus\"] = settings.bus_ids[1]\n    self.fault_settings[\"id\"] = settings.bus_ids[2]\n    self.fault_settings[\"units\"] = 3\n    self.fault_settings[\"values\"] = settings.fault_impedance\n    self.fault_settings[\"basekv\"] = 0.0\n    self.element = settings.bus_ids\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.LineTripObject","title":"<code>LineTripObject</code>","text":"<p>             Bases: <code>BaseFault</code></p> <p>Class defination for a line trip</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class LineTripObject(BaseFault):\n    \"Class defination for a line trip\"\n    fault_method = \"dist_branch_trip\"\n    fault_settings = {}\n\n    def __init__(self, psse: object, settings: LineTrip, contingency_type: str):\n        \"\"\"line trip model\n\n        Args:\n            psse (object): simulator instance\n            settings (LineTrip): line trip model\n            contingency_type (str): contingency type\n        \"\"\"\n        super().__init__(psse, settings, contingency_type)\n        self.fault_settings[\"ibus\"] = settings.bus_ids[0]\n        self.fault_settings[\"jbus\"] = settings.bus_ids[1]\n        self.element = settings.bus_ids\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.LineTripObject.__init__","title":"<code>__init__(psse, settings, contingency_type)</code>","text":"<p>line trip model</p> <p>Parameters:</p> Name Type Description Default <code>psse</code> <code>object</code> <p>simulator instance</p> required <code>settings</code> <code>LineTrip</code> <p>line trip model</p> required <code>contingency_type</code> <code>str</code> <p>contingency type</p> required Source code in <code>pypsse\\contingencies.py</code> <pre><code>def __init__(self, psse: object, settings: LineTrip, contingency_type: str):\n    \"\"\"line trip model\n\n    Args:\n        psse (object): simulator instance\n        settings (LineTrip): line trip model\n        contingency_type (str): contingency type\n    \"\"\"\n    super().__init__(psse, settings, contingency_type)\n    self.fault_settings[\"ibus\"] = settings.bus_ids[0]\n    self.fault_settings[\"jbus\"] = settings.bus_ids[1]\n    self.element = settings.bus_ids\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.MachineTripObject","title":"<code>MachineTripObject</code>","text":"<p>             Bases: <code>BaseFault</code></p> <p>Class defination for a machine fault</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>class MachineTripObject(BaseFault):\n    \"Class defination for a machine fault\"\n    fault_method = \"dist_machine_trip\"\n    fault_settings = {}\n\n    def __init__(\n        self, psse: object, settings: MachineTrip, contingency_type: str\n    ):\n        \"\"\"Machine trip contingency\n\n        Args:\n            psse (object): simulator instance\n            settings (MachineTrip): machine trip model\n            contingency_type (str): type of contingency\n        \"\"\"\n        super().__init__(psse, settings, contingency_type)\n        self.fault_settings[\"ibus\"] = settings.bus_id\n        self.fault_settings[\"id\"] = settings.machine_id\n        self.element = settings.bus_id\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.MachineTripObject.__init__","title":"<code>__init__(psse, settings, contingency_type)</code>","text":"<p>Machine trip contingency</p> <p>Parameters:</p> Name Type Description Default <code>psse</code> <code>object</code> <p>simulator instance</p> required <code>settings</code> <code>MachineTrip</code> <p>machine trip model</p> required <code>contingency_type</code> <code>str</code> <p>type of contingency</p> required Source code in <code>pypsse\\contingencies.py</code> <pre><code>def __init__(\n    self, psse: object, settings: MachineTrip, contingency_type: str\n):\n    \"\"\"Machine trip contingency\n\n    Args:\n        psse (object): simulator instance\n        settings (MachineTrip): machine trip model\n        contingency_type (str): type of contingency\n    \"\"\"\n    super().__init__(psse, settings, contingency_type)\n    self.fault_settings[\"ibus\"] = settings.bus_id\n    self.fault_settings[\"id\"] = settings.machine_id\n    self.element = settings.bus_id\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.add_contingency","title":"<code>add_contingency(contingency, cont_dict, dt, system_contingencies)</code>","text":"<p>Adds a new contingency</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def add_contingency(contingency, cont_dict, dt, system_contingencies):\n    \"Adds a new contingency\"\n    ontingency_type = contingency.__class__.__name__\n    if ontingency_type in contingencies:\n        system_contingencies.append(contingencies[ontingency_type](**cont_dict))\n    else:\n        msg = \"Invalid contingency type. Valid values are: {}\".format(\n            \",\".join(contingencies.keys())\n        )\n        raise Exception(msg)\n    return system_contingencies, dt\n</code></pre>"},{"location":"code/reference/#pypsse.contingencies.build_contingencies","title":"<code>build_contingencies(psse, contingencies_)</code>","text":"<p>Builds all contingencies defined in the settings file</p> <p>Parameters:</p> Name Type Description Default <code>psse</code> <code>object</code> <p>simulator instance</p> required <code>settings</code> <code>SimulationSettings</code> <p>simulation settings</p> required <p>Returns:</p> Type Description <code>List[Union[BusFaultObject, BusTripObject, LineFaultObject, LineTripObject, MachineTripObject]]</code> <p>List[Union[BusFaultObject, BusTripObject, LineFaultObject, LineTripObject, MachineTripObject]]: list of contingencies</p> Source code in <code>pypsse\\contingencies.py</code> <pre><code>def build_contingencies(\n    psse: object, contingencies_: Union[Contingencies, SimulationSettings]\n) -&gt; List[\n    Union[\n        BusFaultObject,\n        BusTripObject,\n        LineFaultObject,\n        LineTripObject,\n        MachineTripObject,\n    ]\n]:\n    \"\"\"Builds all contingencies defined in the settings file\n\n    Args:\n        psse (object): simulator instance\n        settings (SimulationSettings): simulation settings\n\n    Returns:\n        List[Union[BusFaultObject, BusTripObject, LineFaultObject, LineTripObject, MachineTripObject]]: list of contingencies\n    \"\"\"\n\n    system_contingencies = []\n    if contingencies_.contingencies:\n        for contingency in contingencies_.contingencies:\n            contingency_type = contingency.__class__.__name__\n            if contingency_type in contingencies:\n                system_contingencies.append(\n                    contingencies[contingency_type](\n                        psse, contingency, contingency_type\n                    )\n                )\n                logger.debug(f'Contingency of type \"{contingency_type}\" added')\n            else:\n                logger.warning(\n                    \"Invalid contingency type. Valid values are: {}\".format(\n                        \",\".join(contingencies)\n                    )\n                )\n    else:\n        logger.debug(\"No contingencies to build\")\n    return system_contingencies\n</code></pre>"}]}